<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基础知识</title>
    <url>/JavaSE/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="自增自减"><a href="#自增自减" class="headerlink" title="自增自减"></a>自增自减</h2><p>自增运算符在前, 是先自增再得到结果, 自增运算符在后, 是先得到结果再自增</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ++a; <span class="comment">//b -&gt; 2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a++; <span class="comment">//c -&gt; 1</span></span><br></pre></td></tr></table></figure></div>

<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符直接以二进制形式操作目标，位运算符包括：<code>&amp; </code>   <code>|</code>    <code>^</code>   <code>~</code></p>
<blockquote>
<p><code>&amp;</code> <mark style="background: #D2B3FFA6;">与</mark> 运算符对二进制的每一位进行比较, 如果一致返回 1 不一致返回 0. 例如以下计算</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a &amp; b;<span class="comment">// 结果为 1</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>a &#x3D; 9 &#x3D; 1001</li>
<li>b &#x3D; 3 &#x3D; 0011</li>
<li>c &#x3D; 1 &#x3D; 0001</li>
</ul>
<blockquote>
<p><code>|</code> <mark style="background: #ADCCFFA6;">或</mark> 运算符对二进制的每一位进行比较, 对比双方只要有一边为 1 则返回 1, 例如以下计算</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a | b;<span class="comment">// 结果为 11</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>a &#x3D; 9 &#x3D; 1001</li>
<li>b &#x3D; 3 &#x3D; 0011</li>
<li>c &#x3D; 11 &#x3D; 1011</li>
</ul>
<blockquote>
<p><code>^</code> <mark style="background: #FFB86CA6;">异或</mark> 运算符对二进制的每一位进行比较, 对比双方不相同返回 1. 例如以下计算</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a ^ b;<span class="comment">// 结果为 10</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>a &#x3D; 9 &#x3D; 1001</li>
<li>b &#x3D; 3 &#x3D; 0011</li>
<li>c &#x3D; 10 &#x3D; 1010</li>
</ul>
<blockquote>
<p><code>~</code> <mark style="background: #FFB8EBA6;">取反</mark> 运算符操作二进制的每一位, 把1变成0 把0变成1. 例如以下计算</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> ~<span class="number">127</span>;<span class="comment">//a值为 -128</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>a &#x3D; 127 &#x3D; 01111111</li>
<li>b &#x3D; -128 &#x3D; 10000000</li>
</ul>
<h2 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h2><blockquote>
<p><code>&lt;&lt;</code> <mark style="background: #FFF3A3A6;">左移</mark> 运算符将二进制值往左移动两位</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>1 &#x3D; 00000001</li>
<li>4 &#x3D; 00000100（左移两位之后，1跑到前面去了，尾部使用<strong>0</strong>填充，此时就是4）</li>
</ul>
<blockquote>
<p><code>&gt;&gt;</code> <mark style="background: #ADCCFFA6;">右移</mark> 运算符将二进制值往右移动两位</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span> &gt;&gt; <span class="number">2</span>; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>8 &#x3D; 00001000</li>
<li>2 &#x3D; 00000010（右移两位之后，1跑到后面去了，头部使用<mark style="background: #FFB8EBA6;"><strong>符号位数字</strong></mark>填充，此时变成2）</li>
</ul>
<blockquote>
<p>对负数来说, 移位不会影响符号位</p>
</blockquote>
<ul>
<li>-4   &#x3D; 11111100</li>
<li>-2   &#x3D; 11111110（前面这一长串1都被推到后面一位了，因为是负数，头部需要使用<mark style="background: #FFB86CA6;">符号位数字</mark>来进行填充）</li>
</ul>
<h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><table>
<thead>
<tr>
<th align="center">优先级</th>
<th align="center">运算符</th>
<th align="center">结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">( )</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">~   -   +  (强制类型转换)  ++   –</td>
<td align="center">从右向左</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">*   &#x2F;  %</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">+   -</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">&lt;&lt;   &gt;&gt;   &gt;&gt;&gt;</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">&amp;</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">^</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">|</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">&#x3D;  +&#x3D;  -&#x3D;  *&#x3D;   &#x2F;&#x3D;   %&#x3D;   &amp;&#x3D;   |&#x3D;   ^&#x3D;   &lt;&lt;&#x3D;  &gt;&gt;&#x3D;  &gt;&gt;&gt;&#x3D;</td>
<td align="center">从右向左</td>
</tr>
</tbody></table>
<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>问: 以下语句输出什么?</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o1);</span><br></pre></td></tr></table></figure></div>
<p>答: 将输出 1.0</p>
<ol>
<li>三目运算符只能使用基本数据类型，所以编译自动拆箱为int、double</li>
<li>三目运算符要求数据类型一致，所以编译int自动提升为double</li>
</ol>
<h2 id="Integer的创建机制"><a href="#Integer的创建机制" class="headerlink" title="Integer的创建机制"></a>Integer的创建机制</h2><ul>
<li>Integer类里有个内部类IntegerCache</li>
<li>IntegerCache定义了一个大小范围用作Integer的缓存 [-128, 127] 最高值默认127, 可通过jvm参数 <em>-XX:AutoBoxCacheMax</em> 修改</li>
<li>当使用Integer.valueOf(number)获取Integer实例时, 如果number的值在这个缓存区间里, 将会直接返回对应实例, 如果不在这个区间, 则会返回一个新的Integer对象</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下为Integer.valueOf() 源码</span></span><br><span class="line"><span class="comment"> * if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span></span><br><span class="line"><span class="comment"> *     return IntegerCache.cache[i + (-IntegerCache.low)]; </span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * return new Integer(i);</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(a1 == b1); <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><ol>
<li>当final关键字被使用在类上时, 该类就无法被其他类继承<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//如果尝试继承MyClass编译器就会报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Class2</span> <span class="keyword">extends</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>当final关键字被使用在方法上时, 该方法就无法被重写<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCar</span> &#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">testM</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;mmmmm&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTrunk</span> <span class="keyword">extends</span> <span class="title class_">MyCar</span> &#123;</span><br><span class="line">    <span class="comment">//尝试重写, 编译器报错</span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testM</span><span class="params">()</span> &#123;</span><br><span class="line">	    System.out.println(<span class="string">&quot;EEEEE&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
<li>当final关键字被使用在属性字段上时, 该属性字段一旦被赋值, 就无法被修改。需要注意的是, 这里的不可修改指的是: 无法修改该属性字段的地址值, 但数据本身是可以修改的<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//可以修改数组里的值</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//但不能重新指向新的数组, 不可以修改arr的地址</span></span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><blockquote>
<p>有且仅有一个抽象方法的接口，如Runnable</p>
</blockquote>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><blockquote>
<p><code>Function&lt;T,R&gt;</code> 两个常用方法，T表示输入数据类型，R表示输出数据类型</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Function</span> <span class="variable">trim1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o.trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//lambda简化，结果是一样的</span></span><br><span class="line"><span class="type">Function</span> <span class="variable">trim2</span> <span class="operator">=</span> s -&gt; String.valueOf(s).trim();</span><br><span class="line">System.out.println(trim2.apply(<span class="string">&quot; 123 &quot;</span>)); <span class="comment">//123</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><blockquote>
<p><code>Predicate&lt;T&gt;</code>  断定型接口，对给定的参数进行判断，返回一个布尔值</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Predicate</span> <span class="variable">predicate1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Integer o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o &gt; <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//lambda简化，结果是一样的</span></span><br><span class="line"><span class="type">Predicate</span> <span class="variable">predicate2</span> <span class="operator">=</span> (s) -&gt; Integer.parseInt(s.toString()) &gt; <span class="number">10</span>;</span><br><span class="line">System.out.println(predicate1.test(<span class="number">11</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><blockquote>
<p><code>Consumer&lt;T&gt;</code> 消费型接口，无返回值</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer1 = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">          System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//lambda简化，结果是一样的</span></span><br><span class="line">Consumer&lt;String&gt; consumer2 = s -&gt; System.out.println(s);</span><br><span class="line">consumer2.accept(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><blockquote>
<p><code>Supplier&lt;T&gt;</code> 生产型接口，有泛型返回值</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Supplier</span> <span class="variable">supplier1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//lambda简化，结果是一样的</span></span><br><span class="line"><span class="type">Supplier</span> <span class="variable">supplier2</span> <span class="operator">=</span> () -&gt; <span class="string">&quot;456&quot;</span>;</span><br><span class="line">System.out.println(supplier2.get());</span><br></pre></td></tr></table></figure></div>

<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><blockquote>
<p>Jvm垃圾回收器会自动回收不再使用的对象，使用引用计数法和可达性分析算法来判断对象是否是不再使用的对象，<mark style="background: #FFB86CA6;">其本质都是判断一个对象是否还被引用</mark>，如果一个对象一直被引用，但是从未使用，那么就会造成内存泄漏。</p>
</blockquote>
<h3 id="造成内存泄漏的几种情况"><a href="#造成内存泄漏的几种情况" class="headerlink" title="造成内存泄漏的几种情况"></a>造成内存泄漏的几种情况</h3><h4 id="静态集合类"><a href="#静态集合类" class="headerlink" title="静态集合类"></a>静态集合类</h4><p>静态集合类（List，Map等）的生命周期与Java程序一致，而集合中的元素是要等程序结束才释放的，如果我们往这些集合中存放了元素，但是从不使用或者只使用了一次，没有从集合中移除，那么这些元素就成了垃圾，但因为被集合引用，JVM无法回收，就造成了内存泄漏</p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>和静态集合导致内存泄漏原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象持有外部对象引用，那么这个外部对象也不会被回收，那么就会发生内存泄漏</p>
<h4 id="未关闭的资源类"><a href="#未关闭的资源类" class="headerlink" title="未关闭的资源类"></a>未关闭的资源类</h4><p>如数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p>
<h4 id="变量不合理的作用域"><a href="#变量不合理的作用域" class="headerlink" title="变量不合理的作用域"></a>变量不合理的作用域</h4><p>例如下面这个例子，setValue方法后，value就没用了，但此时对象 Test15 生命周期还没结束还持有 value</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test15</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test15</span> <span class="variable">test15</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test15</span>();</span><br><span class="line">        test15.setValue();</span><br><span class="line">        System.out.println(test15.value);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//其他操作，不会用到变量 value</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">()</span> &#123;</span><br><span class="line">        value = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="非静态内部类持有外部类的引用"><a href="#非静态内部类持有外部类的引用" class="headerlink" title="非静态内部类持有外部类的引用"></a>非静态内部类持有外部类的引用</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Inner</span><span class="params">()</span> &#123;</span><br><span class="line">	        <span class="comment">//内部类持有外部类引用</span></span><br><span class="line">            <span class="built_in">this</span>.name = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Inner <span class="title function_">initInner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().initInner();</span><br></pre></td></tr></table></figure></div>

<h2 id="return与finally"><a href="#return与finally" class="headerlink" title="return与finally"></a>return与finally</h2><blockquote>
<p>finally在return返回后，方法结束前执行</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test16</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test16</span> <span class="variable">test16</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test16</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 返回: 15</span></span><br><span class="line"><span class="comment">         * finally</span></span><br><span class="line"><span class="comment">         * 15</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(test16.test1());</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 返回: 15</span></span><br><span class="line"><span class="comment">         * finally return 25</span></span><br><span class="line"><span class="comment">         * 25</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(test16.test2());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a+=<span class="number">5</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;返回: &quot;</span> + a);</span><br><span class="line">            <span class="keyword">return</span> a; <span class="comment">//如果有 try finally. return比finally先执行</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a+=<span class="number">5</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;返回: &quot;</span> + a);</span><br><span class="line">            <span class="keyword">return</span> a; <span class="comment">//如果有 try finally. return比finally先执行</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally return 25&quot;</span>);</span><br><span class="line">            <span class="comment">// 如果finally有return那么将覆盖上方的return</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">25</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型与包装类</title>
    <url>/JavaSE/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>什么是包装类？ 包装类是针对八种基本数据类型相对应的引用类型, 有类的特点, 可以调用类里的方法</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<h3 id="包装类跟基本数据类型的转换"><a href="#包装类跟基本数据类型的转换" class="headerlink" title="包装类跟基本数据类型的转换"></a>包装类跟基本数据类型的转换</h3><ol>
<li>JDK5 之前的手动装箱与拆箱方式<ul>
<li>装箱: 基本数据类型到包装类型</li>
<li>拆箱: 包装类型到基本数据类型</li>
</ul>
</li>
<li>JDK5(含jdk5) 以后实现了自动装箱与拆箱</li>
<li>自动装箱底层调用了valueOf方法</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以int为例</span></span><br><span class="line"><span class="comment">//int 与 Integer 的装箱与拆箱</span></span><br><span class="line"><span class="comment">//手动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(a);</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">b2</span> <span class="operator">=</span> Integer.valueOf(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动拆箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> b1.intValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk5后</span></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//自动装箱 int -&gt; Integer</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">e1</span> <span class="operator">=</span> d; <span class="comment">//底层使用Integer.valueOf(d)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱 Integer -&gt; int</span></span><br><span class="line"><span class="type">int</span> <span class="variable">d1</span> <span class="operator">=</span> e1; <span class="comment">//底层使用的是e1.intValue();</span></span><br></pre></td></tr></table></figure></div>


<h3 id="包装类型与String相互转换"><a href="#包装类型与String相互转换" class="headerlink" title="包装类型与String相互转换"></a>包装类型与String相互转换</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以Integer转String为例</span></span><br><span class="line"><span class="comment">//Integer -&gt; String</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> i.toString();</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//String -&gt; Integer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.parseInt(s4);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(s4);</span><br></pre></td></tr></table></figure></div>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><ol>
<li>String 对象用于保存字符串, 也就是一组字符序列</li>
<li>字符串常量是用双引号括起来的字符序列, 如: <mark style="background: #BBFABBA6;">“123”</mark> <mark style="background: #BBFABBA6;">“hello”</mark> <mark style="background: #BBFABBA6;">“你好”</mark> 等</li>
<li>字符串的字符使用Unicode编码, 一个字符(不区分英文中文)占两字节</li>
<li>String是final类无法被其他继承, <mark style="background: #ABF7F7A6;">字符串是不可变的, 一个字符串对象一旦被分配,其内容就不可变</mark></li>
<li>String有属性 <mark style="background: #FFB86CA6;">private final char[] value;</mark> 用于存放字符串内容</li>
</ol>
<h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一: 先从常量池查看是否有 &quot;hello&quot; 的数据空间, 如果有直接指向, 没有则重新创建, 然后指向, s1 最终指向的是常量池的空间地址</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二: 在堆中创建空间维护value属性, 然后指向常量池 &quot;hello&quot;, 如果常量池没有&quot;hello&quot;,则重新创建. 如果有,则通过value指向&quot;hello&quot;, s2最终指向的是堆中空间地址</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/03/OLdxwUKVqBmetC2.png"
                      alt="string内存布局"
                ></p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串的不可变</span></span><br><span class="line"><span class="comment">//s3 赋值, 判断常量池是否有&quot;hello&quot;,没有创建并指向, 有的话直接指向</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//这里s3再赋值, 并不是修改常量池里的&quot;hello&quot;为&quot;world&quot;,而是判断是否有&quot;world&quot;,没有创建并指向, 有的话直接指向</span></span><br><span class="line">s3 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="comment">//每次赋值都会判断常量存在情况, 根据情况创建新的字符串对象与指向</span></span><br></pre></td></tr></table></figure></div>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p>问: 以下语句创建了几个字符串对象</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello &quot;</span> + <span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></figure></div>
<p>答: 创建了一个字符串对象, 使用 <code>+</code> 进行字符串拼接, 是Java所提供的一个语法糖, 其实现原理是使用<code>StringBuilder.append</code></p>
<p>问: 以下语句创建了几个字符串对象</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello &quot;</span>; <span class="comment">// 创建s1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>; <span class="comment">// 创建s2</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + s2;</span><br></pre></td></tr></table></figure></div>

<p>答: 创建了三个字符串对象</p>
<ol>
<li>创建StringBuilder sb &#x3D; new StringBuilder();</li>
<li>依次 sb.append();</li>
<li>最后s3 &#x3D; sb.toString() &#x2F;&#x2F;返回一个String 对象</li>
</ol>
<p>最后的s3其实是指向堆中的value,  value又指向常量池的”hello world”</p>
<blockquote>
<p>StringBuilder是一个可变的字符序列, 能够高效拼接字符串, 但线程不安全</p>
</blockquote>
<h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><ol>
<li>StringBuffer是可变字符串序列, 可以对字符串内容进行增删, 很多方法与String相同, 但长度可变</li>
<li>StringBuffer是一个容器, 保存的是字符串变量, 也拥有<code>char[] value</code>属性, 数据存放在<mark style="background: #D2B3FFA6;">堆</mark>中</li>
<li>StringBuffer是final的, 不可被继承</li>
<li>StringBuffer操作是线程安全的, 效率相比<code>StringBuilder</code>效率较低</li>
</ol>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><ol>
<li>一个可变的字符串序列, 提供与<code>StringBuffer</code>兼容的API, 但不保证同步. 线程不安全.</li>
<li>主要操作是 <code>append</code> 和 <code>insert</code> 方法. 可以重载这些方法. 以接受任意类型的数据</li>
<li>在单线程的情况下, 推荐优先使用<code>StringBuilder</code></li>
</ol>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>简单图解 </summary>
              <div class='content'>
              <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/03/Rylkt6j4G7PY8Fn.png"
                      alt="StringBuilder图解.png"
                ></p>
              </div>
            </details>
<h3 id="字符串小总结"><a href="#字符串小总结" class="headerlink" title="字符串小总结"></a>字符串小总结</h3><ol>
<li>如果字符串很少修改, 且在多次被引用, 使用String. 如: 配置信息</li>
<li>如果字符串存在大量修改操作<ul>
<li>在单线程情况下使用StringBuilder</li>
<li>在多线程情况下使用StringBuffer</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm笔记</title>
    <url>/JavaSE/JVM%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>JVM (Java Virtual Machine) Java 程序的<strong>运行环境</strong>（Java 二进制字节码的运行环境）</p>
</blockquote>
<h3 id="类加载器和双亲委托"><a href="#类加载器和双亲委托" class="headerlink" title="类加载器和双亲委托"></a>类加载器和双亲委托</h3><h4 id="什么是类加载？"><a href="#什么是类加载？" class="headerlink" title="什么是类加载？"></a>什么是类加载？</h4><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 <code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 <code>Class</code>对象， <code>Class</code>对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p><strong>Java提供了三个类加载器</strong></p>
<ol>
<li>BootstrapClassLoader（启动类加载器）：<mark style="background: #BBFABBA6;">用于加载Java核心库，如JRE&#x2F;lib中的 rt.jar resources.jar charsets.jar等</mark></li>
<li>Extention ClassLoader（拓展类加载器）：<mark style="background: #FFF3A3A6;">用于加载JRE&#x2F;ext中的jar包</mark></li>
<li>AppclassLoader（应用类加载器）：<mark style="background: #ADCCFFA6;">用于加载classpath中的class类，也就我们编写的Java类</mark></li>
</ol>
<h4 id="加载器之间的关系"><a href="#加载器之间的关系" class="headerlink" title="加载器之间的关系"></a>加载器之间的关系</h4><p>BootstrapClassLoader是Extention ClassLoader的父加载器。ExtentionClassLoader是AppclassLoader的父加载器。<mark style="background: #FFB86CA6;">需要注意的是，这里的父加载器并不是Java继承关系的父类，只是逻辑上的</mark></p>
<blockquote>
<p>1，ExtentionClassLoader对应的java类是ExtClassLoader，他的父类是java.net.URLClassLoader。<br>2，AppclassLoader对应的java类是AppClassLoader，他的父类也是java.net.URLClassLoader，没错，和ExtClassLoader一样。<br>3，BootstrapClassLoader是C++编写的，压根没有对应的java类，当然也成不了别人的父类。</p>
</blockquote>
<p>ClassLoader类有getParent()方法，可以得到父加载器，一个加载器的父加载器是在他初始化的时候指定的。<br>AppclassLoader用getParent()方法得到的是ExtClassLoader。<br>ExtClassLoader用getParent()方法得到的是null。(因为Boot是C++编写的所以获取不到，而不是没有)<br>如果我们自定义一个加载器，往往要继承ClassLoader类，此时默认的父加载器是AppClassLoader。</p>
<h4 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h4><ol>
<li>BootstrapClassLoader</li>
<li>ExtentionClassLoader</li>
<li>AppclassLoader</li>
</ol>
<h4 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h4><ul>
<li><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>
<li><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>
<li><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>
</ul>
<h4 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h4><ul>
<li>命令行启动应用时候由JVM初始化加载</li>
<li>通过Class.forName()方法动态加载</li>
<li>通过ClassLoader.loadClass()方法动态加载<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> ClassDemo.class.getClassLoader();  </span><br><span class="line"><span class="comment">//使用ClassLoader.loadClass加载类, 不会执行初始块  </span></span><br><span class="line">loader.loadClass(<span class="string">&quot;className&quot;</span>);  </span><br><span class="line"><span class="comment">//使用Class.forName()来加载类，默认会执行初始化块  </span></span><br><span class="line">Class.forName(<span class="string">&quot;className&quot;</span>);  </span><br><span class="line"><span class="comment">//使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块  </span></span><br><span class="line">Class.forName(<span class="string">&quot;className&quot;</span>, <span class="literal">false</span>, loader);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h5 id="Class-forName-和ClassLoader-loadClass-区别"><a href="#Class-forName-和ClassLoader-loadClass-区别" class="headerlink" title="Class.forName()和ClassLoader.loadClass()区别"></a>Class.forName()和ClassLoader.loadClass()区别</h5><ul>
<li><code>Class.forName()</code>：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li><code>ClassLoader.loadClass()</code>：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li><code>Class.forName(name,initialize,loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li>
</ul>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>当一个类加载器收到类加载的请求时，它首先不会自己去加载这个类。而是将请求交给父加载器去完成，把加载请求依次往上抛，因为<mark style="background: #FFF3A3A6;">所有类加载都应该在顶层的启动类加载器中完成</mark> 当父类加载器在它的搜索范围内找不到该类无法加载时，才会让子类自己去加载。<br>举例说明：我们可以创建一个类 <code>java.lang.String</code> 包名类名都与 Java的 <code>String</code> 类一致</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">	String value;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;  </span><br><span class="line">		<span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();   </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上面例子运行后会报找不到main方法的错误。原因是 <code>AppclassLoader</code> 加载 <code>String.class</code> 的请求会向上抛给  <code>ExtentionClassLoader</code> 。然后 ExtentionClassLoader 在自己的加载路径查找是否有这个类。很明显 <code>java.lang.String</code> 是 <code>rt.jar</code> 包下的。所以 ExtentionClassLoader也找不到该类，所以会把请求抛给BootstrapClassLoader 。而 BootstrapClassLoader 找到了该类，所以加载，但是官方的<code>java.lang.String</code> 下并没有 <code>main</code> 方法。所以就产生了错误。<br>而对于我们自己定义的类，因包名，类名和Java自带的类不一致，所以 BootstrapClassLoader 和 ExtentionClassLoader 没法在自己的搜索范围内找到，所以就会把请求还给 <code>AppclassLoader</code> 来加载</p>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><ul>
<li>JVM分为五个区域：虚拟机栈、本地方法栈、方法区、堆、程序计数器</li>
<li>JVM五个区中虚拟机栈、本地方法栈、程序计数器为线程私有，方法区和堆为线程共享区</li>
<li>JVM不同区域的占用内存大小不同，一般情况下堆最大，程序计数器较小</li>
</ul>
<p>如下图所示<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5jaG91cGFuZ3hpYS5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMTAvMTU3MTM2MzMwOTUzNC5qcGc?x-oss-process=image/format,png"
                     
                ></p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><blockquote>
<p>也叫做运行时数据区堆,内存最大，堆是被 <mark style="background: #FF5582A6;">线程共享</mark>，在JVM运行过程中创建的对象和产生的数据都被存储在堆中（如：类、方法、常量、变量）<br>堆也是Java垃圾回收的主要区域（重点对象），因此也称作“GC堆”（Garbage Collected Heap）<br>JVM规定，<mark style="background: #FFB86CA6;">堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。也就是说堆的内存是一块块拼凑起来的。</mark><br>要增加堆空间时，往上拼凑即可。当堆中没有内存完成实例分配，且堆无法再扩展时，将会抛出 <code>OutOfMemoryError</code> 异常</p>
</blockquote>
<p>因为GC的存在以及现代收集器基本都采用分代收集算法，所以堆又被细化了<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5jaG91cGFuZ3hpYS5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMTAvaGVhcC5qcGc?x-oss-process=image/format,png"
                     
                ></p>
<ul>
<li>堆的GC操纵采用分代收集算法</li>
<li>堆区分新生代、老年代、永久区（元空间）</li>
<li>新生代分为 Eden、From Survivor（s0）、ToSurvivor（s1）</li>
</ul>
<h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h5><blockquote>
<p>JVM新创建的对象（除了大对象外）会被放在新生代，默认占1&#x2F;3堆内存空间。由于JVM会频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。新生代又分为Eden区、SurvivorFrom区和SurvivorTo区<br>新生代的GC过程叫做MinorGC，采用复制算法实现</p>
</blockquote>
<ol>
<li>Eden区：Java新创建的对象首先会被存放在Eden区，如果新创建的对象属于大对象，则直接将其分配到老年代。大对象的定义和具体的JVM版本、堆大小和垃圾回收策略有关，一般为2KB-128KB，可通过 XX:PretenureSizeThreshold设置其大小。在Eden区的内存空间不足时会触发MinorGC，对新生代进行一次垃圾回收。</li>
<li>SurvivorFrom区：保留上一次MinorGC时的幸存者。</li>
<li>SurvivorTo区：将上一次MinorGC时的幸存者作为这一次MinorGC的扫描者。</li>
</ol>
<p>GC过程如下：</p>
<ol>
<li>把在Eden区和SurvivorFrom区中存活的对象复制到SurvivorTo区。如果某对象的年龄达到老年代的标准（对象晋升老年代的标准由 XX:MaxTenuringThreshold设置，默认为15）,则将其复制到老年代，同时把这些对象的年龄加1；如果SuriviorTo区的内存空间不够，则也直接将其复制到老年代；如果对象属于大对象（大小为2KB-128KB的对象属于大对象，例如通过 XX:PretenureSizeThreshold&#x3D;2097152 设置大对象为2MB，1024 × 1024 × 2Byte &#x3D; 2MB），则也直接将其复制到老年代。</li>
<li>清空Eden区和SurvivorFrom区中的对象。</li>
<li>将SurvivoTo区和SurvivorFrom区互换，原来的SurvivorTo区成为下一次GC时的SurvivorFrom区。</li>
</ol>
<h5 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h5><blockquote>
<p>老年代的GC过程叫做MajorGC。MajorGC采用标记清除算法，该算法首先会扫描所有对象并标记存活的对象，然后回收未被标记的对象，并释放空间</p>
</blockquote>
<p>老年代主要存放长生命周期的对象和大对象。老年代对象比较稳定，MajorGC不会被频繁触发。<mark style="background: #BBFABBA6;">在进行MajorGC前，JVM会进行一次MinorGC</mark>，在MinorGC过后仍然出现老年代且当老年代空间不足或无法找到足够大的连续内存空间分配给新创建的大对象时，会触发MajorGC进行垃圾回收，释放JVM的内存空间。<br>因为要先扫描老年代的所有对象再回收，所以MajorGC的耗时较长。MajorGC的标记清除算法容易产生内存碎片。在老年代没有内存空间可分配时，会抛出OutOfMemory异常。</p>
<h5 id="永久代（原空间）"><a href="#永久代（原空间）" class="headerlink" title="永久代（原空间）"></a>永久代（原空间）</h5><p>永久代指内存的永久保存区域，主要存放Class和Meta（元数据）的信息。Class在类加载时被放入永久。<br>永久代和老年代、新生代不同，GC不会在程序运行期间对永久代的内存进行清理，这也导致了永久代的内存<mark style="background: #FFF3A3A6;">会随着加载的Class文件的增加而增加</mark>，在加载Class文件过多时会抛出OutOfMemory异常</p>
<p>在Java 8 中永久代已经被元数据区（也叫做元空间）取代。作用类似，区别在于：元数据区并没有使用虚拟机内存，而是直接使用操作系统的本地内存。因此大小不受JVM内存的限制，和操作系统的内存有关。</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><blockquote>
<p>JVM栈 <mark style="background: #FF5582A6;">线程私有</mark>，生命周期与线程相同，栈的大小直接决定了方法调用的最大可达深度</p>
</blockquote>
<p><strong>栈帧(Stack Frame)</strong> ：是描述Java方法的执行过程的内存模型，它在当前栈帧（Strack Frame）中存储了局部变量表、操作数栈、动态链接、方法出口等信息。同时，栈帧用来存储部分运行时数据及其数据结构，处理动态链接（Dynamic Linking）方法的返回值和异常分派（Dispatch Exception）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5jaG91cGFuZ3hpYS5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMTAvc3RhY2suanBn?x-oss-process=image/format,png"
                     
                ></p>
<ul>
<li><strong>局部变量表(Local Variable Table)</strong>  是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。包括8种基本数据类型、对象引用（reference类型）、returnAddress类型（指向一条字节码指令的地址）、实例的方法（包括输入输出的变量）</li>
</ul>
<p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。</p>
<p><strong>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；</strong><br><strong>如果虚拟机栈动态扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</strong></p>
<p><strong>操作数栈(Operand Stack)</strong> 也称作操作栈，是一个后入先出栈(LIFO)。随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈&#x2F;入栈操作。</p>
<p><strong>动态链接</strong>：Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态链接(Dynamic Linking)。</p>
<p><strong>方法返回</strong>：无论方法是否正常完成，都需要返回到方法被调用的位置，程序才能继续进行。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ul>
<li>方法区与堆有很多共性：<mark style="background: #FF5582A6;">线程共享</mark>、内存不连续、可扩展、可垃圾回收，同样当无法再扩展时会抛出OutOfMemoryError异常。</li>
<li><mark style="background: #FFB86CA6;">方法区存储：静态变量、常量、已被虚拟机加载的类信息（构造方法，接口定义等）、运行时的常量池、即时编译器编译后的代码等数据。实例变量存在堆内存中与方法区无关</mark></li>
<li><mark style="background: #FFF3A3A6;">方法区的内存回收目标主要是针对常量池的回收和对类型的卸载</mark></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5jaG91cGFuZ3hpYS5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMTAvbWV0aG9kYXJlYS5qcGc?x-oss-process=image/format,png"
                     
                ></p>
<h4 id="本地方法区"><a href="#本地方法区" class="headerlink" title="本地方法区"></a>本地方法区</h4><p>本地方法区与JVM栈相似，<mark style="background: #FF5582A6;">线程私有</mark>。也会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 异常。区别在于，JVM栈为Java方法服务。而本地方法栈为 native 方法服务</p>
<blockquote>
<p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一</p>
</blockquote>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ul>
<li>程序计数器占用内存小，<mark style="background: #FF5582A6;">线程私有</mark>。是唯一没有 <code>OutOfMemoryError</code> 的区域</li>
<li>程序计数器的作用可以看做是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是<mark style="background: #FFB86CA6;">通过改变计数器的值来选取下一条字节码指令。其中，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器来完成</mark></li>
</ul>
<p><mark style="background: #D2B3FFA6;">Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的</mark>，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5jaG91cGFuZ3hpYS5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTkvMTAvcHJvZ3JhbS1jb3VudGVyLmpwZw?x-oss-process=image/format,png"
                     
                ></p>
<p>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存</p>
<blockquote>
<p>如果线程正在执行的方法是Java方法，那么计数器将记录正在执行的JVM字节码指令地址。如果正在执行的方法是Native方法，那么计数器的值将为空（Undefined）</p>
</blockquote>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul>
<li>线程私有区域的生命周期与线程相同  <mark style="background: #BBFABBA6;">随线程启动而创建，随线程结束而销毁</mark>  在JVM内部，每个线程都与操作系统的本地线程直接映射，因此线程私有内存区域的存在与否，和本地线程的启动和销毁对应。</li>
<li>线程共享区域 <mark style="background: #FFF3A3A6;">随虚拟机启动而创建，随虚拟机的关闭而销毁</mark></li>
</ul>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><blockquote>
<p>GC绝大多数情况是对<mark style="background: #BBFABBA6;">JVM堆中的数据进</mark>行垃圾回收。而栈，本地方法栈，程序计数器不会有垃圾回收。jvm调优 大多数情况下指堆和方法区的调优</p>
</blockquote>
<h4 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h4><p>前面说到GC主要对堆（Heap）数据进行垃圾回收。而堆中又细分成新生区，幸存区和老年区。这三个区中，GC主要回收的是新生区（Eden）<br>GC分为两种类型：</p>
<ul>
<li>轻GC：针对新生区</li>
<li>重GC：针对全局</li>
</ul>
<h4 id="引用与GC"><a href="#引用与GC" class="headerlink" title="引用与GC"></a>引用与GC</h4><table>
<thead>
<tr>
<th>类型</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>Java中的默认引用类型。例如Object obj &#x3D; new Object()，只要强引用存在，对象永远不会被回收</td>
</tr>
<tr>
<td>软引用</td>
<td>内存足够时，软引用不会被回收。只有当系统要发生内存溢出时，才会被回收。适合用于缓存场景</td>
</tr>
<tr>
<td>弱引用</td>
<td>只要发生垃圾回收，弱引用的对象就会被回收</td>
</tr>
<tr>
<td>虚引用</td>
<td>能在对象被GC时收到系统通知</td>
</tr>
</tbody></table>
<h4 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h4><h5 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h5><p>每个对象中添加引用计数器。每当对象被引用，引用计数器就会加 1；每当引用失效，计数器就会减 1。当对象的引用计数器的值为 0 时，就说明该对象不再被引用，可以被回收了。强调一点，虽然引用计数算法的实现简单，判断效率也很高，但它存在着对象之间相互循环引用的问题（所以在<mark style="background: #FFF3A3A6;">后来的JVM版本中已经不采用这种算法了</mark>）。</p>
<h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>GC Roots 是该算法的基础，GC Roots 是所有对象的根对象。这些对象作为正常对象的起始点，在垃圾回收时，会从这些 GC Roots 开始向下搜索，当一个对象到 GC Roots 没有任何引用链相连时，就证明此对象不再被引用。目前 HotSpot 虚拟机采用的就是这种算法。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/04/19/XFImRdpKAGJ5cQy.png"
                      alt="v2-3b4a7ccf3eacc288e7408ac8a6edca52_r.png"
                ></p>
<h6 id="可以作为-GC-Roots-的对象："><a href="#可以作为-GC-Roots-的对象：" class="headerlink" title="可以作为 GC Roots 的对象："></a>可以作为 GC Roots 的对象：</h6><ol>
<li>虚拟机栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 JNI（Native 方法）引用的对象</li>
<li>Java 虚拟机中内部的引用</li>
<li>synchronized 持有的对象</li>
</ol>
<blockquote>
<p>PS 还有其他算法，但还没整理完</p>
</blockquote>
<h3 id="堆内存调优"><a href="#堆内存调优" class="headerlink" title="堆内存调优"></a>堆内存调优</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">-Xms&lt;size&gt; 设置初始堆大小，默认系统内存的 1 / 64</span><br><span class="line">-Xmx&lt;size&gt; 设置最大堆大小，默认系统内存的 1 / 4</span><br><span class="line">-Xmn&lt;size&gt; 设置新生代大小</span><br><span class="line">-Xss&lt;size&gt; 设置线程堆栈大小，每个线程可使用的内存大小，若设置小值，可生产更多线程，但容易导致栈溢出。若设置大值，会影响到创建栈的数量，导致内存溢出</span><br><span class="line"></span><br><span class="line">-XX:NewRatio=&lt;ratio&gt; 设置新生代和老年代的比值，例如设置成3，表示年轻代与老年代比值为1：3</span><br><span class="line">-XX:SurvivorRatio=&lt;ratio&gt; 新生代中Eden区与两个Survivor区的比值。注意Survivor区有两个。例如设置成3，表示Eden:Survivor=3:2，一个Survivor区占整个新生代的1/5</span><br><span class="line">-XX:MaxTenuringThreshold 设置转入老年代的存活次数。如果是0，则直接跳过新生代进入老年代</span><br><span class="line">-XX:PermSize, -XX:MaxPermSize 分别设置永久代最小大小与最大大小（Java8以前）</span><br><span class="line">-XX:MetaspaceSize -XX:MaxMetaspaceSize 分别设置元空间最小大小与最大大小（Java8以后）</span><br><span class="line">-XX:LargePageSizeInBytes=&lt;size&gt; 设置用于Java堆的大页面尺寸</span><br><span class="line">-XX:MaxHeapFreeRatio=&lt;ratio&gt; GC后Java堆中空闲量占的最大比例</span><br><span class="line">-XX:MinHeapFreeRatio=&lt;ratio&gt; GC后Java堆中空闲量占的最小比例</span><br><span class="line">-XX:MaxNewSize=&lt;size&gt; 新生成对象能占用内存的最大值</span><br><span class="line">-XX:MaxPermSize=&lt;size&gt; 老年代对象能占用内存的最大值</span><br><span class="line"></span><br><span class="line">-XX:+UseSerialGC 设置串行收集器</span><br><span class="line">-XX:+UseParallelGC 设置并行收集器</span><br><span class="line">-XX:+UseParalledlOldGC 设置并行老年代收集器</span><br><span class="line">-XX:+UseConcMarkSweepGC 设置并发收集器</span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDetails    输出详细的GC处理日志</span><br><span class="line">-XX:+PrintGCTimeStamps 输出GC的时间戳信息</span><br><span class="line">-XX:+PrintGCDateStamps 输出GC时间戳信息（日期格式）</span><br><span class="line">-XX:+PrintheapAtGC     在GC处理前后打印堆内存信息</span><br><span class="line">-Xloggc:路径            设置日志信息保存路径</span><br></pre></td></tr></table></figure></div>

<h4 id="Jvm参数相关"><a href="#Jvm参数相关" class="headerlink" title="Jvm参数相关"></a>Jvm参数相关</h4><ul>
<li>布尔型参数选项：-XX:+ 打开，-XX:- 关闭。（比如-XX:+PrintGCDetails）</li>
<li>数字型参数选项：通过-XX:&#x3D;设定。数字可以是m&#x2F;M（兆字节），k&#x2F;K（千字节），g&#x2F;G（G字节）。比如：32K表示32768字节。</li>
<li>字符行参数选项：通过-XX:&#x3D;设定。通常用来指定一个文件、路径，或者一个命令列表。（比如-XX:HeapDumpPath&#x3D;.&#x2F;java_pid.hprof）</li>
</ul>
<h3 id="利用工具排查OOM"><a href="#利用工具排查OOM" class="headerlink" title="利用工具排查OOM"></a>利用工具排查OOM</h3><p>工具：MAT，JProfiler，内存快照工具</p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>并发笔记</title>
    <url>/JavaSE/%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p><strong>进程</strong>：是指⼀个内存中运⾏的应⽤程序，每个进程都有⼀个独⽴的内存空间，⼀个应⽤程序可以同时运⾏多个进程；进程也是程序的⼀次执⾏过程，是系统运⾏程序的基本单位；系统运⾏⼀个程序即是 ⼀个进程从创建、运⾏到消亡的过程。<br><strong>线程</strong>：线程是进程中的⼀个执⾏单元，负责当前进程中程序的执⾏，⼀个进程中⾄少有⼀个线程。⼀个进程中是可以有多个线程的，这个应⽤程序也可以称之为多线程程序。<br><strong>并发</strong>：指两个或多个事件在<strong>同⼀个时间段内</strong>发⽣（一个时间段内，轮流做一些事）<br><strong>并⾏</strong>：指两个或多个事件在<strong>同⼀时刻</strong>发⽣（一个时间段内，同时做某些事）<br><strong>同步</strong>：需要等待结果返回才能继续运行叫同步（单线程方法一行一行顺序执行）。在多线程中还有另外一个意思。让多线程步调一致<br><strong>异步</strong>：不需要等待结果返回就能继续运行叫异步（多线程并行执行）</p>
</blockquote>
<ul>
<li>JVM中的栈内存是给线程使用的，每个线程启动后，JVM会为其分配一块栈内存</li>
<li>Java默认有两个线程，main和gc</li>
</ul>
<h3 id="使用线程的几种方法"><a href="#使用线程的几种方法" class="headerlink" title="使用线程的几种方法"></a>使用线程的几种方法</h3><ol>
<li><p>继承 <code>Thread</code> 类, 重写 <code>run</code> 方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;23333&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>实现 <code>Runnable</code> 接口, 重写 <code>run</code> 方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">YouThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;114514&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">youThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">YouThread</span>()); </span><br><span class="line">youThread.start();</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>匿名子类的方式</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//业务代码</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Runnable匿名子类的方式</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//业务代码</span></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>使用线程池</p>
<blockquote>
<p>关于线程池更具体的笔记，查看 <a href="/JavaSE/%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/../%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/#%E7%BA%BF%E7%A8%8B%E6%B1%A0">线程池</a></p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">pool.execute(<span class="keyword">new</span> <span class="title class_">Runable</span>()&#123;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;&#125;);</span><br><span class="line"></span><br><span class="line">Executors.newCachedThreadPool().execute(<span class="keyword">new</span> <span class="title class_">Runable</span>()&#123;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;&#125;);</span><br><span class="line"></span><br><span class="line">Executors.newSingleThreadExecutor().execute(<span class="keyword">new</span> <span class="title class_">Runable</span>()&#123;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐下方这种</span></span><br><span class="line">ArrayBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>); <span class="comment">// 队列长度2</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">poolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, TimeUnit.SECONDS,  </span><br><span class="line">queue, r -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Callable接口实现，具体请查看下方 <a href="/JavaSE/%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/../%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/#Callable%E6%8E%A5%E5%8F%A3">Callable</a></p>
</li>
</ol>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><h5 id="Java代码层面下的线程状态分为下图中的几种"><a href="#Java代码层面下的线程状态分为下图中的几种" class="headerlink" title="Java代码层面下的线程状态分为下图中的几种"></a>Java代码层面下的线程状态分为下图中的几种</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/04/08/IPmn4zVktUj17JS.png"
                      alt="image.png"
                ></p>
<h3 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h3><ul>
<li>NEW 新建：刚创建出来，还未跟操作系统的线程关联，仅仅只是个Java对象</li>
<li>RUNNABLE 可运行：调用 <code>start</code> 方法后，会与系统真正的线程关联。并执行 <code>run</code> 方法的代码</li>
<li>TERMINATED 终结：当 <code>run</code> 方法执行完毕后，线程进入 <code>TERMINATED</code> 。表示线程生命周期结束。开始释放系统线程相关资源</li>
<li>BLOCKED 阻塞：获取锁失败后阻塞等待锁释放。锁释放后会再参与锁竞争。如果竞争成功就会转为 <code>RUNNABLE</code> 如果再次失败就再次阻塞</li>
<li>WATING 等待：线程获取锁成功后，有时会发现继续执行的条件不满足，这时可以选择让出锁进入等待状态。当条件满足后由其他线程唤醒。唤醒后需重新竞争锁</li>
<li>TIMED_WAITING 等待（有时限）：与WATING状态一样，区别是有等待时间，时间到自动唤醒或被唤醒。线程休眠(sleep)也会从 <code>RUNNABLE</code> 转到 <code>TIMED_WAITING</code></li>
</ul>
<h5 id="操作系统下的线程状态"><a href="#操作系统下的线程状态" class="headerlink" title="操作系统下的线程状态"></a>操作系统下的线程状态</h5><blockquote>
<p>操作系统层面下分为5种：新建 就绪 阻塞 运行 终结</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/04/08/PShe3OKIo4ZGEuc.png"
                      alt="image.png"
                ></p>
<ul>
<li>分到cpu时间：运行</li>
<li>可以分到cpu时间：就绪</li>
<li>分不到cpu时间：阻塞</li>
<li>Java种的 RUNNABLE 涵盖；额就绪，运行，阻塞IO</li>
</ul>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="wait-与-sleep"><a href="#wait-与-sleep" class="headerlink" title="wait 与 sleep"></a>wait 与 sleep</h4><ol>
<li>共同点：wait(), wait(long),sleep(lone) 效果都是让出cpu，进入阻塞状态</li>
<li>方法归属不同<ol>
<li>sleep属于Thread的静态方法</li>
<li>wait&#x2F;wait(long) 属于Object的成员方法，每个对象都有</li>
</ol>
</li>
<li>醒来时机不同<ol>
<li>执行sleep(long)和wait(long)的线程会在指定时间后自动醒来</li>
<li>wait() 和 wait(long) 还可以被 notify唤醒</li>
<li>都可以用打断 <code>interrupt</code> 的方式来唤醒</li>
</ol>
</li>
<li>锁特性不同<ol>
<li>wait需要调用的线程先获取到锁，sleep则不用获取锁</li>
<li>wait执行后会释放锁，sleep不会释放锁</li>
</ol>
</li>
</ol>
<h3 id="Lock与synchronized"><a href="#Lock与synchronized" class="headerlink" title="Lock与synchronized"></a>Lock与synchronized</h3><blockquote>
<p>这两个都是悲观锁。都具备互斥，同步，重入功能</p>
</blockquote>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><ul>
<li>synchronized是一个关键字，由c++实现，不可中断，非公平，获取锁失败会等待</li>
<li>使用synchronized时，退出同步代码块后，锁就会释放。而Lock需要手动释放</li>
<li>在竞争不激烈时， synchronized做了许多优化，如偏向锁，轻量级锁，性能不错</li>
</ul>
<h5 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h5><ol>
<li>作用于成员变量和非静态方法，锁住的是对象的实例，即this对象 如：<code>String a = new String(&quot;123&quot;)</code> 这里锁的是 <code>a</code> <mark style="background: #FFB86CA6;">指向的对象</mark></li>
<li>作用在静态方法，锁住的是Class模板</li>
<li>作用在代码块，同一时刻只能有一个线程执行该方法体或者代码块</li>
</ol>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><ul>
<li>Lock是一个接口，由JDK实现，可以判断是否获取到锁，获取锁失败不会等待</li>
<li>Lock提供了 synchronized 没有的功能。例如获取等待状态、公平锁、可超时、多条件变量</li>
<li>Lock有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li>
<li>Lock可以搭配 <code>Condition</code> 精确唤醒和等待</li>
<li>在竞争激烈时，Lock的性能会更好些</li>
</ul>
<h5 id="作用范围-1"><a href="#作用范围-1" class="headerlink" title="作用范围"></a>作用范围</h5><p>锁住的是 <code>lock()</code> 与 <code>unlock()</code> 中间的代码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">lock.lock(); <span class="comment">// 开始</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//锁住这里的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; <span class="comment">// finally解锁，防止死锁</span></span><br><span class="line">    lock.unlock(); <span class="comment">//结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Lock锁必须配对，调用了几次 lock方法加锁，就必须调用几次 unlock 解锁</p>
</blockquote>
<h3 id="生产者和消费者问题"><a href="#生产者和消费者问题" class="headerlink" title="生产者和消费者问题"></a>生产者和消费者问题</h3><h4 id="synchronized-wait-x2F-notifyAll方法"><a href="#synchronized-wait-x2F-notifyAll方法" class="headerlink" title="synchronized | wait&#x2F;notifyAll方法"></a>synchronized | wait&#x2F;notifyAll方法</h4><p>一个简的生产者消费者问题。使用synchronized来加锁，线程A+1 线程B -1</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">	    <span class="comment">//这里一般会是阻塞队列来判断</span></span><br><span class="line">        <span class="keyword">while</span> (value != <span class="number">0</span>) &#123; <span class="comment">//使用while防止虚假唤醒</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        value++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (value == <span class="number">0</span>) &#123; <span class="comment">//使用while防止虚假唤醒</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        value--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="JUC-await-x2F-signal-方法"><a href="#JUC-await-x2F-signal-方法" class="headerlink" title="JUC | await()&#x2F;signal()方法"></a>JUC | await()&#x2F;signal()方法</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">//创建锁</span></span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();<span class="comment">//创建监视器</span></span><br><span class="line">    <span class="comment">//当然一把锁可以创建多个监视器，通过监视器，我们可以精确控制唤醒与等待</span></span><br><span class="line">    <span class="comment">//Condition condition1 = lock.newCondition();</span></span><br><span class="line">    <span class="comment">//Condition condition2 = lock.newCondition();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            value++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            value--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="集合类不安全问题"><a href="#集合类不安全问题" class="headerlink" title="集合类不安全问题"></a>集合类不安全问题</h3><blockquote>
<p>线程不安全的集合有 ArrayList，HashSet，HashMap 线程安全的集合有 CopyOnWriteArrayList，CopyOnWriteArraySet，ConcurrentHashMap 作用是一样的，只是前者线程不安全，后者安全</p>
<p>早期Java提供了Vector线程安全的集合，但效率较低。且扩容是原来的一倍。需要连续的内存空间等问题现在Java已经不推荐使用了。</p>
</blockquote>
<h4 id="ConCurrentModificationException-异常"><a href="#ConCurrentModificationException-异常" class="headerlink" title="ConCurrentModificationException 异常"></a>ConCurrentModificationException 异常</h4><p>当多个线程往一个集合中添加内容时会报 <code>ConCurrentModificationException</code> 异常</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addList</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">6</span>));</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;,String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li>使用 <code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code> 创建一个线程安全的List</li>
<li>使用 <code>CopyOnWriteArrayList</code> 代替 <code>ArrayList</code></li>
<li>使用 <code>CopyOnWriteArraySet</code> 代替 <code>HashSet</code></li>
<li>使用 <code>ConcurrentHashMap</code> 代替 <code>HashMap</code></li>
</ol>
<p>上述的线程安全集合容器底层的add或put方法使用了 <code>ReentrantLock</code> 来保证线程安全</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">	     <span class="comment">//获取当前对象数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">//创建一个新数组，并把旧数组的内容复制到新数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//往新数组里插入新值</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//将原容器指向新容器</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>这些集合容器都是有线程锁的，所以是线程安全的</li>
<li>CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[ ]添加，而是先将当前容器Object[ ]进行Copy，复制出一个新的容器Object[] newElements，然后往新的容器Object[ ] newElements里添加元素，添加完元素之后，再将原容器的引用指向新的容器 setArray(newElements)。</li>
<li>好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</li>
</ul>
<h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><blockquote>
<p>Callable 接口类似于 Runnable，都是为了其实例可能由另一个线程执行而设计的。但是Runnable不返回结果，也不抛出被检查到的异常</p>
</blockquote>
<ul>
<li>Callable可以有返回值</li>
<li>Callable可以抛异常</li>
<li>方法不同 run() &#x2F; call()</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>Callable无法像Runnable那样可以直接被Thread使用。需要添加一个适配类 <code>FutureTask</code></p>
<blockquote>
<p><mark style="background: #FFB86CA6;">需要注意的是一个 FutureTask 只能绑定一个线程</mark></p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建适配类 FutureTask, 当然也支持lambda表达式</span></span><br><span class="line">        <span class="comment">// FutureTask task = new FutureTask&lt;&gt;(()-&gt;&#123;</span></span><br><span class="line">        <span class="comment">//    业务代码...</span></span><br><span class="line">        <span class="comment">//    return &quot;线程返回值&quot;;</span></span><br><span class="line">        <span class="comment">//&#125;);</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(task).start(); <span class="comment">//结果会被缓存</span></span><br><span class="line">        <span class="comment">//获取返回值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> task.get(); <span class="comment">//可能产生阻塞，可能需要等待结果返回</span></span><br><span class="line">        System.out.println(o); <span class="comment">//输出 -&gt; 线程返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程返回值&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="常用辅助类"><a href="#常用辅助类" class="headerlink" title="常用辅助类"></a>常用辅助类</h3><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><blockquote>
<p>CountDownLatch是JUC包下的一个<mark style="background: #FFF3A3A6;">线程同步工具类</mark> 允许一个或多个线程等待，直到其他线程操作完成，等待线程才会继续往下执行。也可以叫做减法计数器</p>
</blockquote>
<p> <code>CountDownLatch</code> 是调用 <code>await()</code> 方法的线程等待 调用 <code>countDown()</code> 方法的线程，就像主管等待所有员工干完活一样</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">     <span class="comment">//倒计时 -1</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程一执行完毕&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">     <span class="comment">//倒计时 -1</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程二执行完毕&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//倒计时 -1</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程三执行完毕&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//倒计时 -1</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程四执行完毕&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="comment">//倒计时器等待计数器归0, 然后在向下执行</span></span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;所有线程执行完毕, 这句才会输出&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>countDownLatch.countDown()：计数器 - 1</li>
<li>countDownLatch.await()：等待计数器归0后，在向下执行</li>
</ul>
<p>CountDownLatch是基于AQS（AbstractQueuedSynchronizer）实现的。当我们在构建CountDownLatch对象时，传入的值就会赋值给 AQS 的关键变量state，执行countDown方法时，利用CAS 将state 减一，执行await方法时，判断state是否为0，不为0则加入到队列中，将该线程阻塞掉（除头节点外）。头节点会一直自旋等待state为0，当state为0时，头节点会把队列中剩余的阻塞节点一起唤醒</p>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><blockquote>
<p>CyclicBarrier是JUC包下的一个<mark style="background: #FFF3A3A6;">线程同步工具类</mark> 。当线程到达某状态后，暂停下来等待其他线程，等到所有线程均到达以后，才继续执行。也可以叫做加法计数器</p>
</blockquote>
<p>CyclicBarrier是调用 <code>await()</code> 方法的任务线程 等待其他 调用<code>await()</code> 方法的任务线程，就像每个员工干完自己手里的活后等待其他员工干完。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">4</span>, () -&gt; &#123; <span class="comment">// 这是一个Runnable</span></span><br><span class="line">    System.out.println(<span class="string">&quot;计数器到4后执行这里的代码&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行: &quot;</span> + temp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">	        <span class="comment">//一些业务代码</span></span><br><span class="line">            cyclicBarrier.await(); 。<span class="comment">// 当线程执行完某些业务代码后停下来等待其他线程也执行到这</span></span><br><span class="line">            <span class="comment">//其他的业务代码</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><blockquote>
<p>信号量，<mark style="background: #ADCCFFA6;">用来限制能同时访问共享资源的线程上限</mark> </p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化信号量</span></span><br><span class="line"><span class="comment">//public Semaphore(int permits)：permits 表示许可线程的数量</span></span><br><span class="line"><span class="comment">//public Semaphore(int permits, boolean fair)：fair 表示公平性，如果设为 true，表示是公平，那么等待最久的线程先执行</span></span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">	        <span class="comment">//获取一个许可证，如果获取不到则阻塞等待</span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            System.out.println(finalI + <span class="string">&quot; &gt; 开始执行业务代码&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(finalI + <span class="string">&quot; &gt; 业务代码执行完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	        <span class="comment">//释放许可证</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>acquire()：获取一个许可证，对应线程许可证会 -1。获取不到会阻塞等待</li>
<li>release()：释放一个许可证，对应线程许可证会 +1。唤醒等待线程</li>
</ul>
<h3 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock 读写锁"></a>ReadWriteLock 读写锁</h3><blockquote>
<p>读写锁是一把锁分为两部分：读锁和写锁。因为<mark style="background: #ADCCFFA6;">读操作是共享的所以线程安全</mark>，而<mark style="background: #ADCCFFA6;">写操作是互斥的所以线程不安全</mark>。在同一时刻，读写锁允许多个线程同时获得读锁，但只允许一个线程获取写锁，且一旦有一个线程获取到写锁，那其它线程就无法获取读和写锁。写的时候也可以读，但度的时候不能写。可以概括为 <mark style="background: #FFF3A3A6;">读读并发</mark>、<mark style="background: #BBFABBA6;">读写互斥</mark>、<mark style="background: #FFF3A3A6;">写写互斥</mark> <mark style="background: #BBFABBA6;">适合读多写少的业务场景</mark></p>
</blockquote>
<ul>
<li>为什么需要读写锁？<ul>
<li>Synchronized 和 ReentrantLock 都是独占锁，即在同一时刻只有一个线程获取到锁。但在大多数情况下，读操作往往大于写操作。在这种情况下如果使用独占锁，效率将会低下。</li>
</ul>
</li>
<li>读写锁的特点<ul>
<li>公平性：读写锁支持非公平和公平的锁获取方式，非公平锁的吞吐量优于公平锁的吞吐量，默认构造的是非公平锁</li>
<li>可重入：在线程获取读锁之后能够再次获取读锁，但是不能获取写锁，而线程在获取写锁之后能够再次获取写锁，同时也能获取读锁</li>
<li>锁降级：线程获取写锁之后获取读锁，再释放写锁，这样实现了写锁变为读锁，也叫锁降级</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyDataLock</span> <span class="variable">myDataLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDataLock</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myDataLock.set(String.valueOf(finalI), <span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myDataLock.get(String.valueOf(finalI));</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot; &gt; 正在写入&quot;</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(key + <span class="string">&quot; &gt; 写入完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot; &gt; 正在读取&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot; &gt; 读取完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">0</span> &gt; 正在写入</span><br><span class="line"><span class="number">0</span> &gt; 写入完成 <span class="comment">// 每一次写入完成后才会换下个线程</span></span><br><span class="line"><span class="number">1</span> &gt; 正在写入</span><br><span class="line"><span class="number">1</span> &gt; 写入完成</span><br><span class="line"><span class="number">4</span> &gt; 正在写入</span><br><span class="line"><span class="number">4</span> &gt; 写入完成</span><br><span class="line"><span class="number">2</span> &gt; 正在写入</span><br><span class="line"><span class="number">2</span> &gt; 写入完成</span><br><span class="line"><span class="number">3</span> &gt; 正在写入</span><br><span class="line"><span class="number">3</span> &gt; 写入完成</span><br><span class="line"><span class="number">1</span> &gt; 正在读取</span><br><span class="line"><span class="number">1</span> &gt; 读取完成</span><br><span class="line"><span class="number">2</span> &gt; 正在读取</span><br><span class="line"><span class="number">2</span> &gt; 读取完成</span><br><span class="line"><span class="number">3</span> &gt; 正在读取 <span class="comment">// 线程3读取</span></span><br><span class="line"><span class="number">0</span> &gt; 正在读取 <span class="comment">// 被线程0插队</span></span><br><span class="line"><span class="number">0</span> &gt; 读取完成 <span class="comment">// 后来的线程0读取完成早于先来的线程3</span></span><br><span class="line"><span class="number">3</span> &gt; 读取完成</span><br><span class="line"><span class="number">4</span> &gt; 正在读取</span><br><span class="line"><span class="number">4</span> &gt; 读取完成</span><br></pre></td></tr></table></figure></div>

<p>通过简单的例子可以看到。每一次的写入操作完成后才会轮到下一个线程写入，而读取时，会被其他线程插队，先读取到</p>
<h3 id="BlockingQueue-阻塞队列"><a href="#BlockingQueue-阻塞队列" class="headerlink" title="BlockingQueue 阻塞队列"></a>BlockingQueue 阻塞队列</h3><blockquote>
<p>一个支持两个附加操作的队列，这两个附加操作是<br>当写入时队列满了，写入操作会等待队列空出位置再继续写入<br>当读取时队列空了，读取操作会等待队列写入数据后再继续读取<br>一般应用在生产者与消费者场景</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/04/13/n4dCaipItyRQ5sY.png"
                      alt="image.png"
                ></p>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><h5 id="add"><a href="#add" class="headerlink" title="add"></a>add</h5><p>往队列里添加元素，如果失败会抛出异常</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BlockingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line">    queue.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    queue.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    queue.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    <span class="comment">// java.lang.IllegalStateException: Queue full</span></span><br><span class="line">    queue.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><p>检索并删除此队列的头部</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列没有元素</span></span><br><span class="line"><span class="type">BlockingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//java.util.NoSuchElementException</span></span><br><span class="line">queue.remove(); <span class="comment">//移除失败，会抛出异常</span></span><br></pre></td></tr></table></figure></div>

<h5 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h5><p>在不违反容量限制的情况下立即将指定的元素插入到此队列中，成功返回true，失败返回false</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BlockingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">offer</span> <span class="operator">=</span> queue.offer(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当队列没有空间可插入元素时，将阻塞等待队列可用</span></span><br><span class="line"><span class="comment">//一秒后队列还不可用的话就结束等待</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">offer</span> <span class="operator">=</span> queue.offer(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></div>

<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>获取并删除此队列的头部，如果队列是空的，则返回null</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BlockingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//获取并删除此队列的头部</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll(); <span class="comment">//将元素弹出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当队列没有元素可弹出时，将阻塞等待元素可用</span></span><br><span class="line"><span class="comment">//一秒后队列里还没有可弹出元素后就结束等待</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll(<span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></div>

<h5 id="element"><a href="#element" class="headerlink" title="element"></a>element</h5><p>获取队列首个元素，但不删除。若队列为空则抛出异常</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BlockingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// java.util.NoSuchElementException</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">element</span> <span class="operator">=</span> queue.element();</span><br></pre></td></tr></table></figure></div>

<h5 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h5><p>获取队列首个元素，但不删除。若队列为空则返回null</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BlockingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">peek</span> <span class="operator">=</span> queue.peek();</span><br></pre></td></tr></table></figure></div>

<h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><p>往队列添加元素，若队列满了，则一直阻塞等待队列空出位置</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BlockingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line">queue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">queue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">queue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="comment">//到这时，队列没位置了，所以会阻塞等待</span></span><br><span class="line">queue.put(<span class="string">&quot;4&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h5 id="take"><a href="#take" class="headerlink" title="take"></a>take</h5><p>获取并删除此队列的头部，若队列为空，则一直等待队列元素可用</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BlockingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">take</span> <span class="operator">=</span> queue.take();</span><br></pre></td></tr></table></figure></div>

<h3 id="SynchronousQueue-同步队列"><a href="#SynchronousQueue-同步队列" class="headerlink" title="SynchronousQueue 同步队列"></a>SynchronousQueue 同步队列</h3><p>没有容量，最多只能放一个元素，存放一个元素后必须等待这个元素被取出才能存放下一个元素</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="type">SynchronousQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;A &gt; PUT 1&quot;</span>);</span><br><span class="line">            queue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">             System.out.println(<span class="string">&quot;A &gt; PUT 2&quot;</span>);</span><br><span class="line">            queue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;A &gt; PUT 3&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;B &gt; TAKE&quot;</span> + queue.take());</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;B &gt; TAKE&quot;</span> + queue.take());</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;B &gt; TAKE&quot;</span> + queue.take());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">A &gt; PUT <span class="number">1</span></span><br><span class="line">B &gt; TAKE1</span><br><span class="line">A &gt; PUT <span class="number">2</span></span><br><span class="line">B &gt; TAKE2</span><br><span class="line">A &gt; PUT <span class="number">3</span></span><br><span class="line">B &gt; TAKE3</span><br></pre></td></tr></table></figure></div>
<p>上面例子可以看到，线程A存放元素后，必修等线程B把元素取出，线程A才能存放下一个元素</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><blockquote>
<p>线程池是一个线程集合，需要执行新的任务时重用线程池里线程而不是新建线程。<br>特点是可以根据系统的需求和硬件环境灵活的控制线程的数量，且可以对所有线程进行统一的管理和控制，从而提高系统的运行效率，降低系统的运行压力</p>
</blockquote>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li>降低资源消耗：线程和任务分离，提高线程重用性</li>
<li>控制线程并发数量，降低服务器压力，统一管理所有线程</li>
<li>提高系统响应速度。假如创建线程用的时间为T1，执行任务的时间为T2，销毁线程的时间为T3，那么使用线程池就免去了T1和T3的时间。</li>
</ul>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><h5 id="使用-Executors-工具类创建线程池"><a href="#使用-Executors-工具类创建线程池" class="headerlink" title="使用 Executors 工具类创建线程池"></a>使用 Executors 工具类创建线程池</h5><p><mark style="background: #FFB86CA6;">以下三种方式不建议使用</mark>，</p>
<ul>
<li><code>newSingleThreadExecutor</code> 和 <code>newFixedThreadPool</code> 使用了一个无限大小的队列存放任务。任务可以一直提交过来，会导致OOM</li>
<li><code>newCachedThreadPool</code> 只会复用空闲线程，如果任务较多，且无空闲线程时就会创建新线程，如果任务无限多，线程也会无限多，会导致OOM<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不建议使用以下三种方式</span></span><br><span class="line"><span class="comment">//单个线程</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService1</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//固定个数个线程</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//线程数量可伸缩，若线程超过60秒没用将会删除</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService3</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//无返回值</span></span><br><span class="line">    executorService1.execute(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有返回值</span></span><br><span class="line">     Future&lt;?&gt; submit = executorService1.submit(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;一个线程返回值&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//任务返回值</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> submit.get();</span><br><span class="line"> &#125; <span class="keyword">catch</span> (ExecutionException | InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    executorService1.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h5 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h5><ul>
<li>核心线程：线程执行完后保留在线程池中（可为0）</li>
<li>救急线程：线程执行完毕后不保留在线程池中。<mark style="background: #BBFABBA6;">当核心线程和任务队列都满载时，就会创建救急线程处理任务</mark></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/04/08/cYJVz89S3PQuOTM.png"
                      alt="image.png"
                ></p>
<h6 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h6><ol>
<li>corePoolSize 核心线程数目，即最多保留的线程数</li>
<li>maximumPoolSize 最大线程数目，核心线程 + 救急线程</li>
<li>keepAliveTime 生存时间，针对救急线程，当<mark style="background: #D2B3FFA6;">救急线程空闲时间达到生存时间时就会去掉对应救急线程</mark></li>
<li>unit 时间单位，针对救急线程</li>
<li>workQueue 阻塞队列，<mark style="background: #ABF7F7A6;">起任务缓冲作用。当核心线程满载时，新任务会暂存在此队列</mark>中</li>
<li>threadFactory 线程工厂，可以为线程创建时起名</li>
<li>handler 拒绝策略，<mark style="background: #FFF3A3A6;">当核心线程，救急线程，任务队列都满载后。将触发拒绝策略</mark></li>
</ol>
<h6 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h6><ul>
<li>AbortPolicy（默认）：丢弃任务并抛出 RejectedExecutionException 异常。<ul>
<li>这是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。</li>
</ul>
</li>
<li>CallerRunsPolicy：由调用线程处理该任务。<ul>
<li>如果任务被拒绝了，则由调用线程（提交任务的线程）直接执行此任务</li>
</ul>
</li>
<li>DiscardPolicy：丢弃任务，但是不抛出异常。可以配合这种模式进行自定义的处理方式。<ul>
<li> 使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。例如，某些视频网站统计视频的播放量就是采用的这种拒绝策略。</li>
</ul>
</li>
<li>DiscardOldestPolicy：丢弃队列最早的未处理任务，然后重新尝试执行任务。<ul>
<li>此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量</li>
</ul>
</li>
</ul>
<h6 id="自定义线程创建示例"><a href="#自定义线程创建示例" class="headerlink" title="自定义线程创建示例"></a>自定义线程创建示例</h6><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">        <span class="number">4</span>, <span class="comment">// CorePoolSize</span></span><br><span class="line">        <span class="number">10</span>, <span class="comment">// MaximumPoolSize</span></span><br><span class="line">        <span class="number">0</span>, <span class="comment">// KeepAliveTime</span></span><br><span class="line">        TimeUnit.SECONDS, <span class="comment">//Unit</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">10</span>), <span class="comment">// WorkQueue, 任务队列, 最多等待10个任务</span></span><br><span class="line">        Executors.defaultThreadFactory(), <span class="comment">// ThreadFactory 一般默认</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="comment">// Handler 拒绝策略</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h6 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h6><ul>
<li>最大线程数的定义<ul>
<li>CPU密集型：代码运行的服务器配置是几核，那么最大线程数就是几，使用 <code>Runtime.getRuntime().availableProcessors()</code> 获取操作系统的CPU数量</li>
<li>IO密集型：判断程序中需要操作IO的线程有几个，只要最大线程数大于这个值即可</li>
</ul>
</li>
</ul>
<h3 id="ForkJoin-分支合并"><a href="#ForkJoin-分支合并" class="headerlink" title="ForkJoin 分支合并"></a>ForkJoin 分支合并</h3><blockquote>
<p>ForkJoin是 Java7 提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架</p>
</blockquote>
<p>我们需要定义一个计算类，这里以求和运算做例子。定义一个计算类并继承 <code>RecursiveTask</code> 实现 <code>compute</code> 方法，当传入值之差小于 10_0000 时不做计算拆分，否则将折中拆开计算</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalcTest</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CalcTest</span><span class="params">(Long start, Long end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((end - start) &lt; <span class="number">10_0000</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;&gt; 开始计算: start:&quot;</span> + start + <span class="string">&quot; - end:&quot;</span> + end);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">CalcTest</span> <span class="variable">calc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalcTest</span>(start, middle);</span><br><span class="line">            calc1.fork();</span><br><span class="line">            <span class="type">CalcTest</span> <span class="variable">calc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalcTest</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">            calc2.fork();</span><br><span class="line">            <span class="keyword">return</span> calc1.join() + calc2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法</span></span><br><span class="line"><span class="type">CalcTest</span> <span class="variable">calcTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalcTest</span>(<span class="number">1L</span>, <span class="number">10_0000_0000L</span>);</span><br><span class="line"><span class="comment">//创建ForkJoinPool 线程池</span></span><br><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line"><span class="comment">//提交计算任务</span></span><br><span class="line">ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(calcTest);</span><br><span class="line"><span class="comment">//获取计算结果</span></span><br><span class="line">submit.get();</span><br></pre></td></tr></table></figure></div>
<p>尴尬的是，本人电脑计算这个求和运算，传统for循环累加和ForkJoin的运行时间只相差10毫秒</p>
<h4 id="Stream的并行流"><a href="#Stream的并行流" class="headerlink" title="Stream的并行流"></a>Stream的并行流</h4><p>当然我们也可以使用Stream的并行流来计算，<code>IntStream</code> <code>LongStream</code> <code>DoubleStream</code>  这里以计算Long类型的数为例。下面这行代码实现了并行求和，且运行时间仅用了 <code>89毫秒</code>，</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">reduce</span> <span class="operator">=</span> LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">10_0000_0000</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br></pre></td></tr></table></figure></div>
<ul>
<li>parallel：返回自身的并行流</li>
<li>reduce：根据计算值得到一个最终结果</li>
</ul>
<h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无返回值</span></span><br><span class="line">CompletableFuture&lt;Void&gt; comp = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;异步线程进入&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;异步线程结束&quot;</span>);</span><br><span class="line">&#125;, executor);<span class="comment">//executor 线程池</span></span><br><span class="line"><span class="comment">//有返回值</span></span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; comp = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;异步线程进入&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;异步线程结束&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">233</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> comp</span><br><span class="line">		<span class="comment">//当异步任务成功后</span></span><br><span class="line">        .whenComplete((v, e) -&gt; &#123; <span class="comment">//v 返回值 | e 异常信息</span></span><br><span class="line">            System.out.println(v);</span><br><span class="line">            System.out.println(<span class="string">&quot;exception1: &quot;</span> + e);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//当异步任务失败后</span></span><br><span class="line">        .exceptionally(e -&gt; &#123;</span><br><span class="line">		    <span class="comment">//e 是异常信息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;exception2: &quot;</span> + e);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//执行失败后返回</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .get(); <span class="comment">// 此次任务的返回值</span></span><br><span class="line">System.out.println(integer); <span class="comment">// 没有报错是 233 | 报错是1</span></span><br></pre></td></tr></table></figure></div>

<p>个人觉得有点像 JS 的 <code>Promise</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">service</span>()</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;)</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure></div>

<h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><blockquote>
<p>Java内存模型，一种概念，并不真实存在。用来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。关键技术点围绕多线程的<mark style="background: #FFB86CA6;">原子性</mark>，<mark style="background: #ABF7F7A6;">可见性</mark>，<mark style="background: #FFF3A3A6;">有序性</mark> 展开</p>
</blockquote>
<p>JMM规定所有的变量都存储在主内存中。每条线程都有自己的工作内存，存放该线程的工作中使用的变量副本，线程对变量的操作（读，写）都必须在自己的工作内存中进行，不能直接操作主内存中的数据。每个线程只能访问自己的工作内存，不能访问其他线程的工作内存。线程之间的变量传递通过主内存来进行。</p>
<p>JMM中定义了8种工作内存与主内存之间的原子操作<br><code>read(读取) &gt; load(加载) &gt; use(使用)&gt; assign(赋值) &gt; store(存储) &gt; write(写入) &gt; lock(锁定) &gt; unlock(解锁)</code></p>
<ul>
<li>read:作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存</li>
<li>load:作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载</li>
<li>use:作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作</li>
<li>assign:作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作</li>
<li>store:作用于工作内存，将赋值完毕的工作变量的值写回给主内存</li>
<li>write:作用于主内存，将store传输过来的变量值赋值给主内存中的变量</li>
<li>lock:作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，就只是锁了写变量的过程。</li>
<li>unlock:作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用</li>
</ul>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><blockquote>
<p>jdk的关键字，保证可见性，不保证原子性，对内存随机访问操作的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作，避免指令重排</p>
</blockquote>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>保证可见性：用volatile声明一个变量。当一个线程修改这个变量的数据后，其他线程可以及时知道</li>
<li>禁止指令重排序优化：在复制操作时不能保证变量赋值操作的顺序与代码中的执行顺序一致，而volatile防止指令重排</li>
</ul>
<h5 id="例子解析"><a href="#例子解析" class="headerlink" title="例子解析"></a>例子解析</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没有 volatile 的情况</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Test12</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 双检索懒汉式单例</span></span><br><span class="line"><span class="comment">  * 假设它在高并发下被使用</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Test12 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第一重判断</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Test12.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第二重判断</span></span><br><span class="line">                <span class="comment">// new对象时是开辟内存空间，初始化对象，然后指向</span></span><br><span class="line">                <span class="comment">//但为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。</span></span><br><span class="line">                <span class="comment">//重排序后执行有可能变成开辟空间，然后指向，再初始化对象</span></span><br><span class="line">                <span class="comment">//这样做在单线程下是没有问题的，但是如果此时有另外一个线程进来，它在第一重判断，判断到instance已经有指向的对象了。就直接返回。但此时的instance还未初始化</span></span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Test12</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>以上面代码为例子，new一个对象的过程大概是开辟内存空间，初始化对象，然后指向。但为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。重排序后执行有可能变成开辟空间，然后指向，再初始化对象。这样做在单线程下是没有问题的，但是如果此时有另外一个线程进来，它在第一重判断，判断到instance已经有指向的对象了。就直接返回。但此时的instance是个半成品有空指针异常</li>
<li>使用 volatile</li>
</ul>
<h3 id="CAS-比较并交换"><a href="#CAS-比较并交换" class="headerlink" title="CAS 比较并交换"></a>CAS 比较并交换</h3><blockquote>
<p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。</p>
<p>Java的CAS是sun.misc.UnSaffe类中的各个方法。<mark style="background: #FFF3A3A6;">调用UnSafe类中的CAS方法，JVM会帮我们实现CAS汇编指令，完全依赖于硬件功能，通过它实现了原子操作</mark>，由于CAS是一种系统原语，原语属于操作系统范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许中断，也即是说CAS是一条原子指令，不会造成数据不一致的问题。</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//10 是期望原值 &gt; A | 12是新值 &gt; B</span></span><br><span class="line">System.out.println(integer.compareAndSet(<span class="number">10</span>, <span class="number">12</span>)); <span class="comment">//true</span></span><br><span class="line">System.out.println(integer.get()); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line">System.out.println(integer.compareAndSet(<span class="number">11</span>, <span class="number">12</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(integer.get()); <span class="comment">//10</span></span><br></pre></td></tr></table></figure></div>
<h4 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h4><ul>
<li>循环时间长开销很大：Java的CAS底层是自旋锁，在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</li>
<li>只能保证一个共享变量的原子性：当对一个共享变量执行操作时，我们可以使用CAS的方式来保证原子操作，但是对多个共享变量操作时，CAS就无法保证操作的原子性。</li>
<li>ABA问题：一个线程把数据A变成了B，然后又重新变成了A，此时另一个线程读取该数据的时候，发现A没有变化，就误认为是原来的那个A，但是此时A的一些属性或状态已经发生过变化。</li>
</ul>
<h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CASData</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CASData</span>(<span class="string">&quot;A1&quot;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="type">CASData</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CASData</span>(<span class="string">&quot;B1&quot;</span>, <span class="number">15</span>);</span><br><span class="line"><span class="type">CASData</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CASData</span>(<span class="string">&quot;C1&quot;</span>, <span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">AtomicReference&lt;CASData&gt; i1 = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(d1);</span><br><span class="line"><span class="comment">//线程A把i1的值变成d2，然后修改d1的值后又把i1变回d1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    i1.compareAndSet(d1,d2);</span><br><span class="line">    </span><br><span class="line">    d1.setName(<span class="string">&quot;B2&quot;</span>);</span><br><span class="line">    d1.setValue(<span class="number">13</span>);</span><br><span class="line">    i1.compareAndSet(d2,d1);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="comment">//线程B不知道线程A的操作，线程B还以为d1 还是原来的那个d1 -&gt; [A1,12],但实际上d1已经变成了 [B2,13]</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i1.compareAndSet(d1,d3));</span><br><span class="line">    System.out.println(i1.get());</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></div>

<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>增加一个版本号，当内存位置V的值每次被修改后，版本号都加1</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CASData</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CASData</span>(<span class="string">&quot;A1&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">CASData</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CASData</span>(<span class="string">&quot;B1&quot;</span>, <span class="number">15</span>);</span><br><span class="line">        <span class="type">CASData</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CASData</span>(<span class="string">&quot;C1&quot;</span>, <span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">        AtomicStampedReference&lt;CASData&gt; i1 = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(d1, <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//线程A</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(i1.compareAndSet(d1, d2, i1.getStamp(), i1.getStamp() + <span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;A1 &gt; &quot;</span> + i1.getStamp());</span><br><span class="line">            d1.setName(<span class="string">&quot;B2&quot;</span>);</span><br><span class="line">            d1.setValue(<span class="number">13</span>);</span><br><span class="line">            System.out.println(i1.compareAndSet(d2, d1, i1.getStamp(), i1.getStamp() + <span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;B1 &gt; &quot;</span> + i1.getStamp());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">//线程B</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> i1.getStamp(); <span class="comment">// 版本号获取到1</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i1.compareAndSet(d1, d3, stamp, i1.getStamp() + <span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;C1 &gt; &quot;</span> + i1.getStamp());</span><br><span class="line">            System.out.println(<span class="string">&quot;d1 &gt; &quot;</span> + i1.getReference());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//线程A进行ABA修改</span></span><br><span class="line"><span class="literal">true</span>   <span class="comment">//d1 -&gt; d2 成功</span></span><br><span class="line">A1 &gt; <span class="number">2</span> <span class="comment">//版本号 + 1</span></span><br><span class="line"><span class="literal">true</span>   <span class="comment">//d2 -&gt; d1 成功</span></span><br><span class="line">B1 &gt; <span class="number">3</span> <span class="comment">//版本号 + 1</span></span><br><span class="line"><span class="comment">//线程B修改失败，因为版本号不一致</span></span><br><span class="line"><span class="literal">false</span>  <span class="comment">//d1 -&gt; d3 失败</span></span><br><span class="line">C1 &gt; <span class="number">3</span> <span class="comment">//此时线程B持有的版本号是1</span></span><br><span class="line">d1 &gt; CASData&#123;name=<span class="string">&#x27;B2&#x27;</span>, value=<span class="number">13</span>&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用 <code>AtomicStampedReference</code> 维护的 <code>stamp</code> 属性来进行版本号更新操作。每一次修改值后 <code>stamp</code> 都 + 1</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote>
<p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
</blockquote>
<h4 id="死锁产生的四个必要条件："><a href="#死锁产生的四个必要条件：" class="headerlink" title="死锁产生的四个必要条件："></a>死锁产生的四个必要条件：</h4><ol>
<li>互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用</li>
<li>不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。</li>
<li>请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。</li>
<li>循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路<br>以上4个条件成立便会产生死锁，而打破上述条件其中一个就可让死锁消失。</li>
</ol>
<p>以下是死锁产生的案例，A和B两个线程都要锁住一个以上对象</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Test13.lock1) &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Test13.lock2) &#123;</span><br><span class="line">                TimeUnit.MINUTES.sleep(<span class="number">60</span>); <span class="comment">//测试，资源占用后不释放</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Test13.lock2) &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Test13.lock1) &#123;</span><br><span class="line">                TimeUnit.MINUTES.sleep(<span class="number">60</span>); <span class="comment">//测试，资源占用后不释放</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="死锁排查"><a href="#死锁排查" class="headerlink" title="死锁排查"></a>死锁排查</h4><p>使用 <code>jps</code> 命令查看Java进程id，然后使用 <code>jstack 进程id</code> 可以查看Java的堆栈信息，如下<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/04/14/TfPtvSrs1WleBVI.png"
                      alt="image.png"
                ><br>可以看到，堆栈信息提示找到了一个死锁，如果是在IDEA里使用该命令，我们还可以直接跳转到对应的代码。</p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>thread</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>日期类</title>
    <url>/JavaSE/%E6%97%A5%E6%9C%9F%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="第一代"><a href="#第一代" class="headerlink" title="第一代"></a>第一代</h2><p><code>Date</code>: 精确到毫秒, 代表特定的瞬间</p>
<p><code>SimpleDateFormat</code>: 格式化和解析日期</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//当前系统时间  </span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">86400</span>); <span class="comment">//获取指定毫秒的时间  </span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>); <span class="comment">//时间格式化 2000-01-01</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sdf.format(d1); <span class="comment">//2000-01-01  </span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d3</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2001-01-01&quot;</span>); <span class="comment">//字符串解析成Date</span></span><br></pre></td></tr></table></figure></div>

<h2 id="第二代"><a href="#第二代" class="headerlink" title="第二代"></a>第二代</h2><p><code>Calendar</code>: 日历类, 是一个抽象类, 为特定瞬间与一组诸如  <code>YEAR</code> <code>MONTH</code> <code>DAT_OF_MONTH</code> <code>HOUR</code> 等日期字段之间的转换提供了一些方法. 并为操作日历提供方法, 如获取下星期日期</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//私有构造器, 使用 getInstance() 获取对象</span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();  </span><br><span class="line"><span class="comment">//获取年  </span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> calendar.get(Calendar.YEAR);  </span><br><span class="line"><span class="comment">//获取月份, 返回月份时从0开始, 所以月份需要 +1 才能获取真是月份.  </span></span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> calendar.get(Calendar.MONTH) + <span class="number">1</span>;  </span><br><span class="line"><span class="comment">//获取天数  </span></span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);  </span><br><span class="line"><span class="comment">//并没有格式化工具, 需要自己格式化  </span></span><br><span class="line">System.out.println(<span class="string">&quot;Year: &quot;</span> + i + <span class="string">&quot;, month: &quot;</span> + i1 + <span class="string">&quot;, day: &quot;</span> + i2);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>前两代缺点</p>
<ol>
<li>可变性, 日期时间这样的类应该是不可变的</li>
<li>偏移性, Data中年份是从1900开始的, 月份从0开始</li>
<li>格式化: 格式化只对 <code>Date</code> 有效 <code>Calendar</code> 需手动拼接</li>
</ol>
</blockquote>
<h2 id="第三代"><a href="#第三代" class="headerlink" title="第三代"></a>第三代</h2><blockquote>
<p>前两代日期类的不足<br>JDK1.0包含了一个 <code>java.util.Date</code> 但是它的大多数方法在JDK1.1引入<code>Calendar</code> 后就被舍弃了<br>但是 <code>Calendar</code> 也存在一些问题. 比如<mark style="background: #ABF7F7A6;">可变性</mark> <mark style="background: #BBFABBA6;">偏移性</mark> <mark style="background: #FF5582A6;">格式化</mark> 等此外，前两代是线程不安全, 无法处理闰秒等</p>
</blockquote>
<h3 id="JDK8后加入的日期类"><a href="#JDK8后加入的日期类" class="headerlink" title="JDK8后加入的日期类"></a>JDK8后加入的日期类</h3><p><code>LocalData</code>  日期&#x2F;年月日</p>
<p><code>LocalTime</code>  时间&#x2F;时分秒</p>
<p><code>LocalDateTime</code> 日期时间&#x2F;年月日时分秒</p>
<p><code>Instant</code>  时间戳类似 <code>Date</code> 提供了一系列和 <code>Date</code> 转换的方法</p>
<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now(); <span class="comment">//返回当前日期时间对象  </span></span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> localDateTime.getYear();<span class="comment">//获取年  </span></span><br><span class="line"><span class="type">Month</span> <span class="variable">month</span> <span class="operator">=</span> localDateTime.getMonth();<span class="comment">//月份枚举    </span></span><br><span class="line"><span class="type">int</span> <span class="variable">monthValue</span> <span class="operator">=</span> localDateTime.getMonthValue();<span class="comment">//月份实际值, 如1月返回1    </span></span><br><span class="line"><span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> localDateTime.getDayOfMonth();<span class="comment">//这个月的第几天</span></span><br></pre></td></tr></table></figure></div>

<h4 id="格式化与解析"><a href="#格式化与解析" class="headerlink" title="格式化与解析"></a>格式化与解析</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式化  </span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);  </span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> localDateTime.format(dateTimeFormatter);  </span><br><span class="line">System.out.println(format);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析  </span></span><br><span class="line"><span class="comment">//我这边只写了年月日, 所以使用LocalDate. 若只有小时, 分钟使用LocalTime  </span></span><br><span class="line"><span class="comment">//年月日时分秒都有的话使用LocalDateTime  </span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">parse</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2022-01-01&quot;</span>, dateTimeFormatter);</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/JavaSE/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>未更新完</p>
</blockquote>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>在程序运行中, 通过某些方法, 使某个类只能存在一个实例</p>
<h3 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h3><ol>
<li>让构造器私有化, 防止直接 <code>new</code> 的形式构造对象</li>
<li>在类的内部创建对象</li>
<li>对外公开一个静态方法 getInstance</li>
</ol>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> * 在程序启动或单例模式类被加载的时候,单例模式的实例就会被创建。</span></span><br><span class="line"><span class="comment">**/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line">	<span class="comment">//类被加载时就创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleInstance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleInstance</span>();</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">    </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><h5 id="一般方式"><a href="#一般方式" class="headerlink" title="一般方式"></a>一般方式</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 懒汉式  </span></span><br><span class="line"><span class="comment"> * 当第一次访问单例模式的类时才会创建实例  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleInstance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleInstance</span><span class="params">()</span> &#123;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//第一次访问该方法再创建实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (instance) &#123;<span class="comment">//保证线程安全</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">SingleInstance</span>();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="双检锁DCL懒汉式"><a href="#双检锁DCL懒汉式" class="headerlink" title="双检锁DCL懒汉式"></a>双检锁DCL懒汉式</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DCL 需添加 volatile 关键字 保证变量的 可见性，有序性。防止因指令重排序导致获取半成品对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">SingleInstance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">	<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  <span class="comment">// 加锁前先判断对象是否存在</span></span><br><span class="line">		<span class="keyword">synchronized</span> (SingleInstance.class) &#123;</span><br><span class="line">				<span class="comment">// 线程竞争锁时，拿不到锁的线程会等待到锁释放</span></span><br><span class="line">			    <span class="comment">//一旦拿到锁后就会再创建一个单例对象。所以需要再次判断单例对象是否为空</span></span><br><span class="line">			    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; </span><br><span class="line">	                instance = <span class="keyword">new</span> <span class="title class_">SingleInstance</span>();</span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> instance;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="内部类懒汉式"><a href="#内部类懒汉式" class="headerlink" title="内部类懒汉式"></a>内部类懒汉式</h5><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;   </span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">SingleInstance</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;  </span><br><span class="line">		<span class="keyword">static</span> <span class="type">SingleInstance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleInstance</span>();  </span><br><span class="line">	&#125;    </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">		<span class="keyword">return</span> Holder.instance;  </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="枚举类单例"><a href="#枚举类单例" class="headerlink" title="枚举类单例"></a>枚举类单例</h4><p>Java的枚举类默认是单例模式</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个枚举类，有两个元素, 编译时，编辑器会将Sex转为class，并继承 Enum</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Sex</span> &#123;  </span><br><span class="line">	MALE, FEMALE</span><br><span class="line">	<span class="comment">//上面的两个元素会变成静态final变量</span></span><br><span class="line">	<span class="comment">// public static final Sex MALE;</span></span><br><span class="line">	<span class="comment">// public static final Sex FEMALE;</span></span><br><span class="line">	<span class="comment">//然后会在静态代码块里初始化这两个变量</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		MALE = <span class="keyword">new</span> <span class="title class_">Sex</span>();</span><br><span class="line">		FEMALE = <span class="keyword">new</span> <span class="title class_">Sex</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//当然私有构造方法，编译器也会帮过我们加上的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们可以根据枚举特性创建一个 饿汉式枚举单例。如下</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Single2</span> &#123;  </span><br><span class="line">	INSTANCE;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Single2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">		<span class="keyword">return</span> INSTANCE;  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//其他方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">Single2.INSTANCE.xxx();</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><mark style="background: #FFF3A3A6;">好处不怕反序列化和反射的形式破坏单例</mark></p>
</blockquote>
<h3 id="破坏单例"><a href="#破坏单例" class="headerlink" title="破坏单例"></a>破坏单例</h3><h4 id="反射形式"><a href="#反射形式" class="headerlink" title="反射形式"></a>反射形式</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reflection</span><span class="params">(Class&lt;?&gt; clazz)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">	<span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();  </span><br><span class="line">	constructor.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">	<span class="comment">//通过反射创建第二个单例对象，实现破坏单例  </span></span><br><span class="line">	constructor.newInstance();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h5><p>在私有构造方法里添加单例对象是否存在的判断</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">SingleInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">	<span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;单例对象已存在&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<h4 id="反序列化破坏单例"><a href="#反序列化破坏单例" class="headerlink" title="反序列化破坏单例"></a>反序列化破坏单例</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">serial</span><span class="params">(Object instance)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;  </span><br><span class="line">	<span class="type">ByteArrayOutputStream</span> <span class="variable">bao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();  </span><br><span class="line">	<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bao);  </span><br><span class="line">	oos.writeObject(instance); <span class="comment">//将对象变成字节流</span></span><br><span class="line">	<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bao.toByteArray()));</span><br><span class="line">	<span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ois.readObject(); <span class="comment">// 通过反序列化创建第二个单例对象  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="预防-1"><a href="#预防-1" class="headerlink" title="预防"></a>预防</h5><p>重写 <code>readResolve</code> 方法，将我们的单例对象返回。在反序列化时，会直接返回这个对象，不会再创建一个</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;  </span><br><span class="line">	<span class="keyword">return</span> instance;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="UnSafe破坏单例"><a href="#UnSafe破坏单例" class="headerlink" title="UnSafe破坏单例"></a>UnSafe破坏单例</h4><p>使用Unsafe类创建对象，这个目前没法预防。</p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ol>
<li>饿汉式与懒汉式的主要区别在于创建对象的时机不同, 饿汉式是在类加载的时候创建对象, 而懒汉式是在使用时才创建</li>
<li>饿汉式不存在线程安全问题, 懒汉式存在线程安全问题, 需要上锁</li>
<li>饿汉式存在资源浪费的可能, 懒汉式则没有这个问题</li>
<li>JavaSE标准类中<ol>
<li>java.lang.Runtime就是经典的单例模式</li>
<li>System中的Console 是一个双检锁懒汉单例</li>
<li>Collections类中以Empty开头的大多数内部类都是单例</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-过滤器</title>
    <url>/JavaWeb/JavaWeb-Filter%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>Filter过滤器,是JavaWeb三大组件之一(Servlet, Filter, Listener)</li>
<li>过滤器可以把资源拦截下来,从而实现一些需求</li>
<li>过滤器一般完成一些通用操作,如访问权限控制, 统一编码处理, 铭感字符处理等</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>定义类,实现Filter接口，重写所有方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        Filter.<span class="built_in">super</span>.init(filterConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        Filter.<span class="built_in">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>配置Filter拦截路径, 使用@WebFilter注解</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span> <span class="comment">//表示拦截所有访问</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>放行</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">//放行前逻辑</span></span><br><span class="line">    <span class="comment">//对request进行处理</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//放行请求</span></span><br><span class="line">    chain.doFilter(request,response);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//放行后逻辑</span></span><br><span class="line">    <span class="comment">//对response进行处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="过滤器执行过程"><a href="#过滤器执行过程" class="headerlink" title="过滤器执行过程"></a>过滤器执行过程</h3><p><strong>过滤器拦截 -&gt; 执行放行前逻辑 -&gt; 放行 -&gt; 访问资源 -&gt; 回到过滤器 -&gt; 执行放行后逻辑</strong></p>
<h2 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h2><h3 id="拦截路径配置"><a href="#拦截路径配置" class="headerlink" title="拦截路径配置"></a>拦截路径配置</h3><ol>
<li>拦截具体资源: &#x2F;index.html 只有访问&#x2F;index.html才会拦截</li>
<li>目录拦截: &#x2F;user&#x2F;* 访问&#x2F;user目录下的所有资源都会被拦截</li>
<li>后缀名拦截: *.html 访问后缀为html都会被拦截</li>
<li>拦截所有: &#x2F;* 所有访问都会被拦截</li>
</ol>
<h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><p>可以配置多个过滤器, 串成一个过滤器链</p>
<p>执行顺序: 多个过滤器以过滤器类名自然排序, 例如: AFilter1 BFilter3 Filter2</p>
<p>放行逻辑执行顺序: <strong>如下图所示,请求先从左到右执行放行前逻辑直到访问资源, 再从右到左访问放行后逻辑</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/06/hmliEUCpJzsDn6F.png"
                      alt="filter-note-1.png"
                ></p>
]]></content>
      <categories>
        <category>note</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-HTTP</title>
    <url>/JavaWeb/JavaWeb-HTTP/</url>
    <content><![CDATA[<h2 id="请求的数据格式"><a href="#请求的数据格式" class="headerlink" title="请求的数据格式"></a>请求的数据格式</h2><p>数据分为三部分</p>
<ul>
<li>请求行: 请求数据第一行, GET&#x2F;POST 表示请求方式 &#x2F; 表示请求路径 HTTP&#x2F;1.1表示协议版本</li>
<li>请求头: 键值对数据</li>
<li>请求体: POST请求的最后一部分, 存放请求参数</li>
</ul>
<p>例子:</p>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">浏览器能够接受的资源类型</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">浏览器可以支持的压缩类型</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate, br</span><br><span class="line">浏览器偏好语言</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=0</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Cookie</span>:</span><br><span class="line">请求主机名</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.baidu.com </span><br><span class="line"><span class="attribute">Sec-Fetch-Dest</span><span class="punctuation">: </span>document</span><br><span class="line"><span class="attribute">Sec-Fetch-Mode</span><span class="punctuation">: </span>navigate</span><br><span class="line"><span class="attribute">Sec-Fetch-Site</span><span class="punctuation">: </span>none</span><br><span class="line"><span class="attribute">Sec-Fetch-User</span><span class="punctuation">: </span>?1</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line">浏览器版本</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36</span><br><span class="line"><span class="attribute">sec-ch-ua</span><span class="punctuation">: </span>&quot;Chromium&quot;;v=&quot;106&quot;, &quot;Google Chrome&quot;;v=&quot;106&quot;, &quot;Not;A=Brand&quot;;v=&quot;99&quot;</span><br><span class="line"><span class="attribute">sec-ch-ua-mobile</span><span class="punctuation">: </span>?0</span><br><span class="line"><span class="attribute">sec-ch-ua-platform</span><span class="punctuation">: </span>&quot;Windows&quot;</span><br></pre></td></tr></table></figure></div>

<p><strong>GET请求参数在请求行中.没有请求体</strong></p>
<p><strong>POST请求参数在请求体中</strong></p>
<p><strong>GET请求有参数大小限制.POST没有</strong></p>
<h2 id="响应的数据格式"><a href="#响应的数据格式" class="headerlink" title="响应的数据格式"></a>响应的数据格式</h2><p>数据分为三部分</p>
<ul>
<li>响应行: 响应数据第一行, HTTP&#x2F;1.1表示协议版本 200 代表响应代码 OK 表示状态描述</li>
<li>响应头: 键值对数据</li>
<li>响应体: 最后一部分, 存放响应数据</li>
</ul>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Bdpagetype</span><span class="punctuation">: </span>2</span><br><span class="line"><span class="attribute">Bdqid</span><span class="punctuation">: </span>0xeaa6d46b0000e982</span><br><span class="line">客户端如何缓存, 设置 max-age=300 表示最多缓存300秒</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>private</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line">响应的压缩算法</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br><span class="line">响应内容的类型</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html;charset=utf-8</span><br><span class="line">响应内容长度(字节数)</span><br><span class="line"><span class="attribute">Content-Lenght</span><span class="punctuation">: </span>100</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>BWS/1.1</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>BDSVRTM=318; path=/</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>BD_HOME=1; path=/</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>H_PS_PSSID=37375_36551_37359_36884_37402_37396_37406_36786_37499_26350_37448_37370_37449; path=/; domain=.baidu.com</span><br><span class="line"><span class="attribute">Strict-Transport-Security</span><span class="punctuation">: </span>max-age=172800</span><br><span class="line"><span class="attribute">Traceid</span><span class="punctuation">: </span>1665032548061897473016908435407035754882</span><br><span class="line"><span class="attribute">X-Frame-Options</span><span class="punctuation">: </span>sameorigin</span><br><span class="line"><span class="attribute">X-Ua-Compatible</span><span class="punctuation">: </span>IE=Edge,chrome=1</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>note</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>集合容器</title>
    <url>/JavaSE/%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="集合与数组"><a href="#集合与数组" class="headerlink" title="集合与数组"></a>集合与数组</h2><h4 id="数组的不足"><a href="#数组的不足" class="headerlink" title="数组的不足"></a>数组的不足</h4><ol>
<li>数组长度开始必须指定, 且一旦被指定, 就无法更改</li>
<li>数组保存的数据必须类型一致</li>
<li>数组增删元素比较麻烦, 灵活性不够<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容</span></span><br><span class="line">Integer[] arr2 = <span class="keyword">new</span> <span class="title class_">Integer</span>[arr.length + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//拷贝arr数据到arr2</span></span><br><span class="line">copy....</span><br><span class="line"><span class="comment">//添加数据</span></span><br><span class="line">arr2[arr2.length - <span class="number">1</span>] = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ol>
<li>可以动态保存任意多个对象</li>
<li>提供了一些列操作集合对象的方法; <mark style="background: #FFB86CA6;">add</mark> <mark style="background: #FFB8EBA6;">remove</mark> <mark style="background: #ADCCFFA6;">set</mark> <mark style="background: #ABF7F7A6;">get</mark></li>
</ol>
<h2 id="集合的框架体系"><a href="#集合的框架体系" class="headerlink" title="集合的框架体系"></a>集合的框架体系</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/04/jrbXx69PWdJto7e.png"
                      alt="集合框架.png"
                ></p>
<h4 id="Iterable-迭代器"><a href="#Iterable-迭代器" class="headerlink" title="Iterable 迭代器"></a>Iterable 迭代器</h4><ol>
<li><code>Iterable</code> 对象称为迭代器, 主要用于遍历 <code>Collection</code> 集合中的元素</li>
<li>所有实现了 <code>Collection</code> 接口的集合都有一个 <code>iterator()</code> 方法, 返回一个实现了 <code>Iterable</code> 接口的对象</li>
<li><code>Iterable</code> 仅用于集合遍历, 本身并不存放对象</li>
</ol>
<p>简单的使用</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> collection.iterator();  </span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123; <span class="comment">//判断是都有下一个元素  </span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next(); <span class="comment">//游标下移并取出元素  </span></span><br><span class="line">    System.out.println(next);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环退出, iterator指向最后一个元素</span></span><br><span class="line"><span class="comment">//如果再次next() 则会报错. 若需再次遍历, 需要重置iterator(), 再次collection.iterator();  </span></span><br></pre></td></tr></table></figure></div>

<h4 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h4><blockquote>
<p>简化版的迭代器遍历</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//底层依然是迭代器</span></span><br><span class="line"><span class="keyword">for</span>(Object obj : collection) &#123;</span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>List集合中的元素是有序可重复的</li>
<li>List集合中的每个元素都有对应的顺序索引, 支持索引取出</li>
<li>常用的实现类: <code>ArrayList</code>  <code>Vector</code> <code>LinkedList</code></li>
</ol>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ol>
<li>ArrayList 可以加入 <code>null</code></li>
<li>ArrayList 是由数组来实现数据存储的</li>
<li>ArrayList基本同等与 <code>Vector</code> 但ArrayList是线程不安全的</li>
<li>基于数组，需要连续内存</li>
<li>随机访问快</li>
<li>尾部插入，删除性能还行，其他部分插入删除都会移动数据，性能较低</li>
<li>可以利用cpu缓存</li>
</ol>
<h5 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h5><ul>
<li>ArrayList中维护了一个 <code>Object</code> 类型的<mark style="background: #BBFABBA6;">数组</mark> <code>elementData</code></li>
<li>当创建对象时, 如果是使用的无参构造器, 则初始化 <code>elementData</code> 容量为 <mark style="background: #ABF7F7A6;">0</mark> </li>
<li>添加元素时, 判断是否需要扩容 如果需要则调用 <code>grow</code> 扩容为 <mark style="background: #FFB86CA6;">10</mark> 否则就添加元素</li>
<li>如果使用的是无参构造器, 且第一次添加需要扩容的话, 就库容 <code>elementData</code> 为 10. 如需再次扩容, 就扩容为<mark style="background: #ADCCFFA6;">1.5倍</mark></li>
<li>如果使用了指定容量的构造器, 则初始化 <code>elementDta</code> 的大小为 <code>capacity</code> 如需扩容. 则直接扩容为 <mark style="background: #ADCCFFA6;">1.5倍</mark></li>
</ul>
<blockquote>
<p>在扩容时，并不是现容量乘以1.5而是 现容量 &gt;&gt;&gt; 1 再加上现容量得到的1.5倍,防止出现小数<br>例如 现容量 15，那扩容后将是 (15 &gt;&gt;&gt; 1) + 15 &#x3D; 22。<br><mark style="background: #BBFABBA6;">需要注意的是最终的元素个数如果大于计算得到的扩容值，那么最后实际扩容的大小将是元素个数</mark><br>例如：向一个容量为10的集合里再 <mark style="background: #FFF3A3A6;">addAll(1,2,3)</mark> 三个元素，那么此集合将扩容至15。若<mark style="background: #FFF3A3A6;">addAll(1,2,3,4,5,6)</mark> 六个元素，那么此集合将扩容至16</p>
</blockquote>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul>
<li>基于双向链表，无需连续内存</li>
<li>随即访问慢（要沿着链表遍历）</li>
<li>头尾插入删除性能高</li>
<li>占用内存多</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><blockquote>
<p>HashSet 的本质是 HashMap</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//底层维护了一个map属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在进行add操作时，底层实际上是对 <code>map</code> 进行了put操作。将我们要存储的值作为map的key放入map</li>
<li><mark style="background: #FFB86CA6;">map的key是无法重复的，重复的key会被覆盖掉</mark><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//add的传值是map的key，而PRESENT是一个不变的Object常量空对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><ul>
<li>1.7：数组+链表</li>
<li>1.8：数组+ (链表 | 红黑树)，当链表元素较多时会转成红黑树，当元素删除一定元素后转成链表</li>
<li>HashMap 总体是数组+链表的存储结构， 从JDK1.8开始，<mark style="background: #BBFABBA6;">当数组的长度大于64，且链表的长度大于8的时候，会把链表转为红黑树</mark>，<mark style="background: #ADCCFFA6;">若数组长度不够64，但链表长度大于8，会对数组扩容以此来减小链表长度</mark> </li>
<li>数组的默认长度是16。数组中的每一个元素为一个node，也就是链表的一个节点，node的数据包含: key的hashcode, key, value,指向下一个node节点的指针。</li>
</ul>
<blockquote>
<p>每次扩容都会拿hash与扩容后的数组长度重新计算数组下标， 有些元素就会得到不同结果，从而达到减小链表长度的作用</p>
</blockquote>
<h4 id="PUT操作"><a href="#PUT操作" class="headerlink" title="PUT操作"></a>PUT操作</h4><ol>
<li>map.put(key, value)，首先计算key的hash，得到一个int值。</li>
<li>如果Node数组为空则初始化Node数组。这里注意，Node数组的长度length始终应该是2的n次方，比如默认的16, 还有32,64等</li>
<li>用 hash % length  取模运算得到数组下标</li>
<li>如果Node[hash % length]处为空，用传入的的key, value创建Node对象，直接放入该下标；如果该下标处不为空，且对象为TreeNode类型，证明此下标处的元素们是按照红黑树的结构存储的，将传入的key，value作为新的红黑树的节点插入到红黑树；否则，此处为链表，用next找到链表的末尾，将新的元素插入。如果在遍历链表的过程中发现链表的长度超过了8，此时如果数组长度&lt;64则进行扩容，否则转红黑树</li>
<li>添加完元素后检查容量是否超过或阈值，超过了就扩容（阈值为当前容量的75%）</li>
</ol>
<blockquote>
<p>上面提到数组的长度length始终是2^n, 在这个前提下，hash &amp; (length-1) 与hash % length是等价的。 而位与运算更快。</p>
</blockquote>
<h5 id="1-7与1-8的区别"><a href="#1-7与1-8的区别" class="headerlink" title="1.7与1.8的区别"></a>1.7与1.8的区别</h5><ul>
<li>插入时的不同<ul>
<li>1.7里是头插法，每次新加的元素放在链表头部</li>
<li>1.8里是尾插法，每次新加的元素放在链表尾部</li>
</ul>
</li>
<li>扩容时的不同<ul>
<li>1.7 是大于等于阈值且没有空位时才扩容</li>
<li>1.8 时大于阈值就扩容</li>
</ul>
</li>
<li>1.8在扩容计算Node索引时会优化</li>
</ul>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="为什么要使用红黑树"><a href="#为什么要使用红黑树" class="headerlink" title="为什么要使用红黑树"></a>为什么要使用红黑树</h5><p>答：当链表元素很长时我们获取元素需要从头开始检索，如果元素在底端就需要检索多次。性能是比较低的。而使用红黑树可以减少检索次数。</p>
<h5 id="为什么不一上来就树化"><a href="#为什么不一上来就树化" class="headerlink" title="为什么不一上来就树化"></a>为什么不一上来就树化</h5><p>答：当我们一个链表上的元素只有一个或少数几个时，其性能要比红黑树好的，只有链表长度较长时性能才较高。</p>
<h5 id="什么时候会树化"><a href="#什么时候会树化" class="headerlink" title="什么时候会树化"></a>什么时候会树化</h5><p>答：当数组的长度大于64，且链表的长度大于8的时候，会把链表转为红黑树。若数组长度不够64，但链表长度大于8，会对数组扩容以此来减小链表长度</p>
<h5 id="树化阈值为何是8"><a href="#树化阈值为何是8" class="headerlink" title="树化阈值为何是8"></a>树化阈值为何是8</h5><ul>
<li>红黑树是用来避免Dos攻击（别人恶意提交很多hash一样的数据），防止链表超长时出现性能下降。一般情况下链表长度不会超过8。</li>
<li>hash值如果足够随机，则hash表内按泊松分布，在负载因子0.75情况下，长度超过8的链表出现概率为0.000000006，选择8是为了让树华概率足够低</li>
</ul>
<h5 id="什么时候树会退化成表"><a href="#什么时候树会退化成表" class="headerlink" title="什么时候树会退化成表"></a>什么时候树会退化成表</h5><ol>
<li>在扩容是拆分树时，如果树元素个数小于等于6就会退化成链表。 </li>
<li>在移除树节点前检查，若root, root.left  root.right root.left.left有一个为null，也会退化为链表</li>
</ol>
<h5 id="索引怎么计算"><a href="#索引怎么计算" class="headerlink" title="索引怎么计算"></a>索引怎么计算</h5><p>每一个对象都提供了hashcode方法获取原始hash值，而原始hash值还需要使用hashmap中的hash方法获取二次hash值。然后用二次hash结果跟数组长度进行取模运算，最后的结果就是对象的索引</p>
<h5 id="为什么有hashcode了还要提供hash方法"><a href="#为什么有hashcode了还要提供hash方法" class="headerlink" title="为什么有hashcode了还要提供hash方法"></a>为什么有hashcode了还要提供hash方法</h5><p>hash方法会将hashcode右移16位，让hash分布更为均匀，防止链表超长</p>
<h5 id="数组容量为何是2的n次幂"><a href="#数组容量为何是2的n次幂" class="headerlink" title="数组容量为何是2的n次幂"></a>数组容量为何是2的n次幂</h5><ul>
<li>在求索引值时，如果<mark style="background: #ABF7F7A6;">数组长度是2的n次幂</mark>则可以使用 按位与 来计算数组下标，[hash &amp; (capacity - 1)] 这种方法效率更高，扩容时 hash % oldCapacity &#x3D; 0 的元素留在原处。否则新位置 &#x3D; 旧位置 +  oldCapacity。</li>
</ul>
<h5 id="负载因子为何默认是0-75"><a href="#负载因子为何默认是0-75" class="headerlink" title="负载因子为何默认是0.75"></a>负载因子为何默认是0.75</h5><ol>
<li>在空间占用与查询时间之间取得较好的平衡</li>
<li>大于这个值，比较节省空间，但是链表会较长</li>
<li>小于这个值，空间占用较大，扩容较频繁。但链表会较短</li>
</ol>
<h5 id="多线程下操作HashMap会有什么问题"><a href="#多线程下操作HashMap会有什么问题" class="headerlink" title="多线程下操作HashMap会有什么问题"></a>多线程下操作HashMap会有什么问题</h5><ol>
<li>扩容死链：在jdk1.7中如果多个线程同时去扩容一个HashMap，就会造成一个链表里的元素互相指向头尾没了，如：A的下个元素指向B，B的元素指向A。<ol>
<li>原因是，在扩容时会有两个线程临时变量 e 和 next，其中e指向当前元素，next指向下个元素。然后进行遍历，将元素取出一个一个地通过头插法放入新数组。</li>
<li>在并发过程中会出现，线程T1刚获赋予e和next值，还未开始遍历，系统换到了线程T2执行。T2也有e和next。T2按照扩容方法进行扩容后换到T1执行。但此时扩容后的链表元素位置与扩容前是相反的（头插法，将底部元素插入头部）而T1的e和next还是扩容前的值进而形成错误指向。</li>
</ol>
</li>
<li>数据丢失：例如 <mark style="background: #BBFABBA6;">多个线程同时操作HashMap时</mark>。线程A跟线程B同时判断tab[1]的节点为空，可以写入新节点。但因为是并发操作，所以很有可能出现<mark style="background: #ADCCFFA6;">下一个线程覆盖掉上一个线程put的值</mark>。从而造成上一个线程的数据丢失问题。</li>
</ol>
<h5 id="key是否为null-作为key的对象有什么要求？"><a href="#key是否为null-作为key的对象有什么要求？" class="headerlink" title="key是否为null ? 作为key的对象有什么要求？"></a>key是否为null ? 作为key的对象有什么要求？</h5><ol>
<li>hashmap的key可以为null，但其他map就不一定了</li>
<li>作为key的对象必须重写hashcode与equals，并且<mark style="background: #ADCCFFA6;">key的内容不能修改即key不可变</mark></li>
<li><mark style="background: #BBFABBA6;">重写hashcode是为了让key有更好的分布性。重写equals的作用是当两个对象的hashcode值一样时，通过equals来判断是都是同个对象</mark></li>
</ol>
<blockquote>
<p>两个对象hashcode相同，不一定equals一样。但两个对象equals一样，那么hashcode就相同</p>
</blockquote>
<h5 id="对象的hashcode是如何设计的？-为啥每次乘-31？"><a href="#对象的hashcode是如何设计的？-为啥每次乘-31？" class="headerlink" title="对象的hashcode是如何设计的？ 为啥每次乘 31？"></a>对象的hashcode是如何设计的？ 为啥每次乘 31？</h5><ol>
<li>hashcode的设计目标是让每个对象的hashcode足够独特，达到均匀的散列效果</li>
<li>31代入散列公式可以有较好的散列特性，并且31 * h 可以被优化为<ol>
<li>32 * h - h</li>
<li>2^5 * h - h</li>
<li>h &lt;&lt; 5 - h</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-Servlet</title>
    <url>/JavaWeb/JavaWeb-Tomcat/</url>
    <content><![CDATA[<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>创建web项目,导入servlet坐标</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Tomcat 10 使用这个--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>简单使用例</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.eoezora.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/test&quot;)</span> <span class="comment">// 访问路径是 /test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;post&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="urlPattern配置"><a href="#urlPattern配置" class="headerlink" title="urlPattern配置"></a>urlPattern配置</h2><p>Servlet想要被访问,就必须设置其访问路径 <strong>(urlPattern)</strong></p>
<p>一个Servlet可以配置多个urlPattern, 例如 <strong>@WebServlet(urlPattern &#x3D; {“&#x2F;test1”, “&#x2F;test2”, “&#x2F;test3”})</strong></p>
<p>urlPattern配置规则</p>
<p>优先级: 精确路径匹配 &gt; 目录路径匹配 &gt; 扩展名匹配 &gt; &#x2F; &#x2F;*</p>
<h3 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/user/info&quot;)</span> <span class="comment">//访问路径为 -&gt; http://localhost:8080/webapp/user/info</span></span><br></pre></td></tr></table></figure></div>

<h3 id="目录匹配"><a href="#目录匹配" class="headerlink" title="目录匹配"></a>目录匹配</h3><p>以下面例子来说,只要在&#x2F;user目录下的请求都能访问该Servlet</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/user/*&quot;)</span> <span class="comment">//访问路径为 -&gt; http://localhost:8080/webapp/user/aaa | http://localhost:8080/webapp/user/bbb</span></span><br></pre></td></tr></table></figure></div>

<h3 id="拓展名匹配"><a href="#拓展名匹配" class="headerlink" title="拓展名匹配"></a>拓展名匹配</h3><p>访问该拓展名的文件资源</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;*.do&quot;)</span> <span class="comment">//访问路径为 -&gt; http://localhost:8080/webapp/aaa.do</span></span><br></pre></td></tr></table></figure></div>

<h3 id="任意匹配"><a href="#任意匹配" class="headerlink" title="任意匹配"></a>任意匹配</h3><p>不管访问地址是啥，都能访问这个Servlet</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/&quot;)</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/*&quot;)</span> </span><br><span class="line"><span class="comment">//访问路径为 -&gt; http://localhost:8080/webapp/abc 可以用任意路径访问这个Servlet</span></span><br><span class="line"><span class="comment">//当我们在项目中设置了 &quot;/&quot; 和 &quot;/*&quot; 后会覆盖掉tomcat默认的DefaultServlet.当其他的urlPattern都匹配不上时会访问这个Servlet</span></span><br></pre></td></tr></table></figure></div>

<h2 id="xml配置Servlet"><a href="#xml配置Servlet" class="headerlink" title="xml配置Servlet"></a>xml配置Servlet</h2><p>需要在web.xml中配置, 例子如下, Servlet类与注解方式一样，只是不需要写注解@WebServlet</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- servlet名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- servlet类的路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.eoezora.controller.TestController<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- servlet名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- servlet访问路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/test<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>note</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-会话跟踪技术</title>
    <url>/JavaWeb/JavaWeb-%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><ul>
<li>会话:客户端跟服务端的连接,会话建立后直到一方断开连接才会结束.在一次会话中可以包含多次请求和响应</li>
<li>会话跟踪:服务端会识别多个请求是否来自同一个客户端,以便在同次会话的多次请求间共享数据</li>
<li>HTTP协议是<strong>无状态</strong>的,每次客户端向服务端请求时。服务端都会将该请求视为<strong>新的请求</strong>,因此我们需要会话跟踪技术来实现会话内数据共享</li>
<li>实现方式: <ul>
<li>客户端会话跟踪技术: Cookie</li>
<li>服务端跟会话踪技术: Session</li>
</ul>
</li>
</ul>
<h2 id="Cokkie"><a href="#Cokkie" class="headerlink" title="Cokkie"></a>Cokkie</h2><p>客户端会话技术,将数据保存在客户端,以后每次请求都携带Cookie数据进行访问</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//创建Cookie对象</span></span><br><span class="line">    <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="comment">//发送cookie到客户端</span></span><br><span class="line">    response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取客户端所有cookie</span></span><br><span class="line">    Cookie[] cookies = request.getCookies();</span><br><span class="line">    <span class="comment">//通过遍历获取每个cookie</span></span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie1 : cookies) &#123;</span><br><span class="line">        System.out.println(cookie1.getName() + <span class="string">&quot; - &quot;</span> + cookie1.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="存活时间"><a href="#存活时间" class="headerlink" title="存活时间"></a>存活时间</h3><p>默认情况下, 当浏览器关闭后,内存释放,Cookie会被销毁</p>
<p>使用方法 cookie.setMaxAge(秒) 设置cookie存活时间</p>
<p>而参数有以下含义</p>
<ul>
<li>正数: 将会cookie写入浏览器所在电脑硬盘,持久化存储到期自动删除</li>
<li>负数: 默认值, Cookie存在于浏览器内存中,浏览器关闭自动销毁</li>
<li>零: 删除对应cookie</li>
</ul>
<h3 id="存储中文"><a href="#存储中文" class="headerlink" title="存储中文"></a>存储中文</h3><p>Cookie不支持存中文, 如果非要存中文可以把中文进行<strong>URL编码</strong>存进去, 取的时候再解码</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>客户端会话技术,基于Cookie实现, 将数据保存在服务端, JavaEE提供了HttpSession接口来实现一次会话多次请求间数据的共享功能</p>
<h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Session对象</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">hs</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"><span class="comment">//设置session值, 键值对</span></span><br><span class="line">hs.setAttribute(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="comment">//根据key获取Session的值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> (String) hs.getAttribute(<span class="string">&quot;key&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="钝化"><a href="#钝化" class="headerlink" title="钝化"></a>钝化</h3><p>服务端正常关闭后,Tomcat会自动将Session数据写入到硬盘文件中</p>
<h3 id="活化"><a href="#活化" class="headerlink" title="活化"></a>活化</h3><p>服务器启动后,会从文件中加载Session</p>
<h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><ol>
<li>在web.xml配置Session到期时间, 添加下面代码,时间单位: <strong>分钟</strong></li>
</ol>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>调用Session的 invalidate() 方法销毁</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>cookie和session都是来完成一次会话多次请求之间的数据共享</p>
<p>区别：</p>
<ul>
<li>存储位置: cookie存储在客户端, session存储在服务端</li>
<li>安全性: cookie不安全, session安全</li>
<li>数据大小: cookie最多3kb, session无大小限制</li>
<li>存储时间: cookie可以无限期存储, session默认30分钟</li>
<li>性能影响: cookie不占用服务器资源, session占用服务器资源</li>
</ul>
]]></content>
      <categories>
        <category>note</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-请求和响应</title>
    <url>/JavaWeb/JavaWeb-%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>Request: 获取请求数据</li>
<li>Response: 设置响应数据</li>
</ul>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="获取请求数据"><a href="#获取请求数据" class="headerlink" title="获取请求数据"></a>获取请求数据</h3><p>一些需要了解的方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">// http://localhost:8080/EoeWebDemo_war/test?username=aas&amp;password=1234567</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求行的数据</span></span><br><span class="line">    req.getMethod(); <span class="comment">// GET  提交方法</span></span><br><span class="line">    req.getContextPath(); <span class="comment">// EoeWebDemo_war  虚拟路径</span></span><br><span class="line">    req.getRequestURL(); <span class="comment">// http://localhost:8080/EoeWebDemo_war/test</span></span><br><span class="line">    req.getRequestURI(); <span class="comment">// /EoeWebDemo_war/test</span></span><br><span class="line">    req.getQueryString();  <span class="comment">// username=aas&amp;password=1234567</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求头的数据, 根据请求头名称获取值</span></span><br><span class="line">    req.getHeader(<span class="string">&quot;User-Agent&quot;</span>);</span><br><span class="line">    <span class="comment">//Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//获取POST请求体的数据</span></span><br><span class="line">    <span class="comment">//获取流对象</span></span><br><span class="line">    <span class="comment">// BufferedReader getReader()：获取字符输入流 只能操作字符数据</span></span><br><span class="line">    <span class="comment">// ServletInputStream getInputStream()：获取字节输入流 可以操作所有类型数据</span></span><br><span class="line">    req.getInputStream();</span><br><span class="line">    req.getReader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>Reuqest提供的获取参数的方法,不管是get还是post都通用</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有参数</span></span><br><span class="line">Map&lt;String, String[]&gt; stringMap = req.getParameterMap();</span><br><span class="line"><span class="comment">//获取指定参数名的多个值</span></span><br><span class="line">String[] pars = req.getParameterValues(<span class="string">&quot;某个参数名&quot;</span>);</span><br><span class="line"><span class="comment">//获取指定参数的单个值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">par</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;某个参数名&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="中文参数乱码解决方式"><a href="#中文参数乱码解决方式" class="headerlink" title="中文参数乱码解决方式"></a>中文参数乱码解决方式</h3><p>浏览器对url中的中文会进行URL编码,而Tomcat在解码时使用的字符集是<strong>ISO-8859-1</strong>, 会导致中文乱码.</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//POST请求直接使用这个方法设置即可</span></span><br><span class="line">req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//GET请求需要我们手动对字符串进行编码解码操作</span></span><br><span class="line"><span class="comment">//把收到的字符串转为二进制</span></span><br><span class="line"><span class="type">byte</span>[] bytes = req.getParameter(<span class="string">&quot;参数名&quot;</span>).getBytes();</span><br><span class="line"><span class="comment">//在用utf8字符集把二进制数据转成String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">newParame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure></div>

<h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><p>一种服务器内部资源跳转方式</p>
<p>特点</p>
<ul>
<li>浏览器地址栏不会发生变化</li>
<li>转发只能转到服务器内部资源</li>
<li>转发是一次请求,可以使用request共享数据</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转发资源间共享数据方式</span></span><br><span class="line">request.setAttribute(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">request.getAttribute(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">request.removeAttribute(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="comment">//请求转发</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">&quot;其他资源的访问路径&quot;</span>).forward(request,response);</span><br></pre></td></tr></table></figure></div>

<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p>一些方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//设置响应代码</span></span><br><span class="line">    response.setStatus(<span class="number">200</span>);</span><br><span class="line">    <span class="comment">//设置响应头</span></span><br><span class="line">    response.setHeader(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="comment">//获取字符输出流</span></span><br><span class="line">    response.getWriter();</span><br><span class="line">    <span class="comment">//获取字节输出流</span></span><br><span class="line">    response.getOutputStream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Response重定向"><a href="#Response重定向" class="headerlink" title="Response重定向"></a>Response重定向</h3><p>介绍：一种资源跳转方式</p>
<p>特点</p>
<ul>
<li>地址栏路径发生变化</li>
<li>可以重定向到任意位置资源, 服务器内部, 外部都可</li>
<li>两次请求,不能在多个资源共享数据</li>
</ul>
<p>实现方式</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置重定向代码</span></span><br><span class="line">response.setStatus(<span class="number">302</span>);</span><br><span class="line"><span class="comment">//设置重定向路径</span></span><br><span class="line"><span class="comment">//需要添加request.getContextPath()虚拟目录</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Location&quot;</span>, request.getContextPath() + <span class="string">&quot;/ts&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化方式, 使用这个</span></span><br><span class="line">response.sendRedirect(request.getContextPath() + <span class="string">&quot;/ts&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="响应字符数据"><a href="#响应字符数据" class="headerlink" title="响应字符数据"></a>响应字符数据</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//response.setHeader(&quot;Content-Type&quot;,&quot;text/html&quot;);</span></span><br><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">pw.write(<span class="string">&quot;aaaaa&quot;</span>);</span><br><span class="line">pw.write(<span class="string">&quot;&lt;h1&gt;aaaaa&lt;/h1&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//响应完成后, response 会被销毁, PrintWriter会被服务器关闭</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//响应字节流数据</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/bg.jpg&quot;</span>);</span><br><span class="line"><span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> ((lenght = fileInputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    out.write(buffer,<span class="number">0</span>,lenght);</span><br><span class="line">&#125;</span><br><span class="line">fileInputStream.close();</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>note</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>Resquest</tag>
        <tag>Response</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Redis实现Session共享的登录功能</title>
    <url>/JavaWeb/%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0Session%E5%85%B1%E4%BA%AB%E7%9A%84%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="传统Session形式"><a href="#传统Session形式" class="headerlink" title="传统Session形式"></a>传统Session形式</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/07/aZidRxJSXGpqTFk.png"
                      alt="session登录流程.png"
                ></p>
<h3 id="验证码发送"><a href="#验证码发送" class="headerlink" title="验证码发送"></a>验证码发送</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;  </span><br><span class="line">    <span class="comment">//手机号码验证  </span></span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号码错误&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//验证码生成  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">//保存到session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line">    <span class="comment">//实际通过短信发送验证码需借助第三方的短信服务</span></span><br><span class="line">    log.debug(<span class="string">&quot;验证码: &#123;&#125;&quot;</span>, code);  </span><br><span class="line">    <span class="keyword">return</span> Result.success();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="登录与注册"><a href="#登录与注册" class="headerlink" title="登录与注册"></a>登录与注册</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(User cUser, HttpSession session)</span> &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> cUser.getPhone();</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> cUser.getCode();</span><br><span class="line">    <span class="comment">//检验手机号  </span></span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号错误&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//从session获取验证码</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="comment">//检验验证码</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCode == <span class="literal">null</span> || !cacheCode.toString().equals(code)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//根据手机号码查询用户  </span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();  </span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="comment">//数据库没信息，创建新用户</span></span><br><span class="line">        user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="comment">//...user doSomething</span></span><br><span class="line">        <span class="comment">//user信息入库</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//session保存用户信息</span></span><br><span class="line">    <span class="comment">//这里存放的User信息要注意是否有敏感信息, 如密码，手机号等</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>, user);  </span><br><span class="line">    <span class="keyword">return</span> Result.success();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="校验用户信息"><a href="#校验用户信息" class="headerlink" title="校验用户信息"></a>校验用户信息</h3><p>使用拦截器校验用户信息</p>
<h4 id="设置拦截器"><a href="#设置拦截器" class="headerlink" title="设置拦截器"></a>设置拦截器</h4><p>新建一个拦截器类 <code>UserInterceptor</code> 并实现 <code>HandlerInterceptor</code> 接口</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="comment">//获取session  </span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();  </span><br><span class="line">        <span class="comment">//获取用户  </span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);  </span><br><span class="line">        <span class="comment">//判断用户是否存在  </span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="comment">//用户不存在，拦截请求  </span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//保存到ThreadLocal, 每个请求都是一个线程，保存到ThreadLocal，不会与其他请求线程的信息发生冲突</span></span><br><span class="line">        UserLocal.save((User) user);  </span><br><span class="line">        <span class="comment">//放行  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>用户保存到ThreadLocal, 每个请求都是一个线程，保存到ThreadLocal，不会与其他请求线程的信息发生冲突，且在控制器那边获取用户信息也只需要在ThreadLocal获取即可</p>
</blockquote>
<h4 id="添加拦截器"><a href="#添加拦截器" class="headerlink" title="添加拦截器"></a>添加拦截器</h4><p>新建一个配置类 <code>MvcConfig</code> 实现 <code>WebMvcConfigurer</code> 接口 <code>addInterceptors</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;  </span><br><span class="line">        registry</span><br><span class="line">		        <span class="comment">//添加拦截器</span></span><br><span class="line">                .addInterceptor(<span class="keyword">new</span> <span class="title class_">UserInterceptor</span>())  </span><br><span class="line">                <span class="comment">//排除不需要拦截的路径，以下路径不会被拦截  </span></span><br><span class="line">                .excludePathPatterns(  </span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,  </span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                );  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>至此，一个简单的基于session的登录注册功能便完成</strong></p>
<h3 id="Session共享问题"><a href="#Session共享问题" class="headerlink" title="Session共享问题"></a>Session共享问题</h3><p>多台tomcat服务器并不共享session存储空间，当请求切换到不同的tomcat服务器时导致数据丢失</p>
<h2 id="Redis共享Session形式"><a href="#Redis共享Session形式" class="headerlink" title="Redis共享Session形式"></a>Redis共享Session形式</h2><h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><p>流程与传统方式差不多，区别在于把数据存在Redis里和把Token返回给前端，以及配置拦截器刷新token</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/07/XGeJqN9rVf8uk2w.png"
                      alt="redis_token登录.png"
                ></p>
<h3 id="验证码发送-1"><a href="#验证码发送-1" class="headerlink" title="验证码发送"></a>验证码发送</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;  </span><br><span class="line">    <span class="comment">//手机号码验证</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//验证码生成  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);  </span><br><span class="line">    <span class="comment">//手机号码作key把验证码存到redis里</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);  </span><br><span class="line">    log.debug(<span class="string">&quot;验证码: &#123;&#125;&quot;</span>, code);  </span><br><span class="line">    <span class="keyword">return</span> Result.success();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="登陆与注册"><a href="#登陆与注册" class="headerlink" title="登陆与注册"></a>登陆与注册</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(User cUser, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> cUser.getPhone();</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> cUserr.getCode();</span><br><span class="line">    <span class="comment">//检验手机号  </span></span><br><span class="line">    ...  </span><br><span class="line">    <span class="comment">//检验验证码  </span></span><br><span class="line">    <span class="comment">//从redis获取验证码  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);  </span><br><span class="line">    <span class="keyword">if</span> (cacheCode == <span class="literal">null</span> || !cacheCode.equals(code)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//根据手机号码查询用户  </span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();  </span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;<span class="comment">//数据库没信息，创建新用户  </span></span><br><span class="line">        user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="comment">//对新用户信息初始化 </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//生成随机TOKEN  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);  </span><br><span class="line">    <span class="comment">//User对象转HashMap存储  </span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">    <span class="comment">//对象转map </span></span><br><span class="line">    Map&lt;String, Object&gt; beanToMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),  </span><br><span class="line">            CopyOptions.create()  </span><br><span class="line">                    <span class="comment">//忽略空值  </span></span><br><span class="line">                    .setIgnoreNullValue(<span class="literal">true</span>)  </span><br><span class="line">                    <span class="comment">//值转字符串类型  </span></span><br><span class="line">                    .setFieldValueEditor((key, value) -&gt; value.toString())  </span><br><span class="line">    );  </span><br><span class="line">    <span class="comment">//存到redis里  </span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> LOGIN_USER_KEY + token;  </span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(key, beanToMap);  </span><br><span class="line">    <span class="comment">//设置数据有效期  </span></span><br><span class="line">    stringRedisTemplate.expire(key, <span class="number">1</span>, TimeUnit.MINUTES);  </span><br><span class="line">    <span class="keyword">return</span> Result.success(token);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="检验用户信息"><a href="#检验用户信息" class="headerlink" title="检验用户信息"></a>检验用户信息</h3><p>当一些用户长时间不活跃时，他们的登录信息依然存在Redis里，这造成一定的内存空间浪费。所以我给用户登录的信息设置了失效时间。当让，也同时也为活跃用户刷新失效数据时间，只要用户还有操作。那数据就一直存在。否则，就会超时被自动回收。</p>
<p>为了实现这个我设置了两个拦截器。一个拦截所有请求，为登录的用户刷新Token以及其他数据。另一个则用来做登录判定，具体实现如下</p>
<h4 id="登陆拦截器"><a href="#登陆拦截器" class="headerlink" title="登陆拦截器"></a>登陆拦截器</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="keyword">if</span>(UserLocal.getUser() == <span class="literal">null</span>) &#123;<span class="comment">//没用户信息，拦截  </span></span><br><span class="line">            response.setStatus(<span class="number">301</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//有用户信息，放行  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="刷新拦截器"><a href="#刷新拦截器" class="headerlink" title="刷新拦截器"></a>刷新拦截器</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="comment">//获取请求头中的token</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123; <span class="comment">//token为空但是放行给 LoginInterceptor</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> LOGIN_USER_KEY + token;  </span><br><span class="line">    <span class="comment">//根据token获取用户  </span></span><br><span class="line">    Map&lt;Object, Object&gt; entries = redisTemplate.opsForHash().entries(key);  </span><br><span class="line">    <span class="comment">//判断用户是否存在  </span></span><br><span class="line">    <span class="keyword">if</span>(entries.isEmpty()) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//用户信息为空但是放行给 LoginInterceptor</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//hash数据转对象  </span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(entries, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);  </span><br><span class="line">    <span class="comment">//有用户信息，保存到ThreadLocal</span></span><br><span class="line">    UserLocal.saveUser(userDTO);  </span><br><span class="line">    <span class="comment">//刷新token时间  </span></span><br><span class="line">    redisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);  </span><br><span class="line">    <span class="comment">//放行  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="拦截器注册"><a href="#拦截器注册" class="headerlink" title="拦截器注册"></a>拦截器注册</h4><p>我们新增的拦截器会被注册成 <code>InterceptorRegistration</code> 内部有个属性 <code>order</code> 用来决定拦截器触发顺序。默认为0，如果不设置将按下面这样以添加顺序来执行拦截器</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">//TOKEN刷新  </span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">TokenInterceptor</span>(stringRedisTemplate))  </span><br><span class="line">            .addPathPatterns(<span class="string">&quot;/**&quot;</span>);  </span><br><span class="line">    <span class="comment">//登录拦截  </span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())  </span><br><span class="line">            <span class="comment">//排除不需要拦截的路径，以下路径不会被拦截  </span></span><br><span class="line">            .excludePathPatterns(  </span><br><span class="line">                    <span class="string">&quot;/user/code&quot;</span>,  </span><br><span class="line">                    <span class="string">&quot;/user/login&quot;</span>,  </span><br><span class="line">                    <span class="string">&quot;/shop/**&quot;</span>,  </span><br><span class="line">                    <span class="string">&quot;/shop-type/**&quot;</span>,  </span><br><span class="line">                    <span class="string">&quot;/blog/**&quot;</span>  </span><br><span class="line">            );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>note</category>
        <category>JavaWeb</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>session</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存</title>
    <url>/JavaWeb/%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h2><blockquote>
<p>缓存是数据交换的缓冲区(称作 Cache)，是存贮数据的临时地方，一般读写性能很高。</p>
</blockquote>
<p><strong>好处</strong></p>
<ul>
<li>降低后端负载，缓解数据库压力</li>
<li>提高读写效率，降低响应时间</li>
</ul>
<p><strong>成本</strong></p>
<ul>
<li>数据一致性成本</li>
<li>为了解决一致性导致的代码维护成本</li>
<li>运维成本</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://camo.githubusercontent.com/a8e4f82ccadea3e6cdc8366ad167b231558250d026e4347f5432fd32d185d0de/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f436f6465724c65697869616f73687561692f6173736574732f3230323130322f32303231303530343231353633322d323032312d30352d30342d32312d35362d33332e706e67"
                     
                ></p>
<blockquote>
<p>图源 <a class="link"   href="https://github.com/CoderLeixiaoshuai/java-eight-part/blob/master/docs/redis/" >https://github.com/CoderLeixiaoshuai/java-eight-part/blob/master/docs/redis/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<h2 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a>使用缓存</h2><blockquote>
<p>流程图，需要注意的是此图并没有对缓存异常做解决方案， <mark style="background: #FF5582A6;">只是最基础的使用流程</mark></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/07/mvwd5sPIyXtJbgL.png"
                      alt="缓存流程图 _1_.png"
                ></p>
<blockquote>
<p>简单例子</p>
</blockquote>
<ol>
<li>传入查询条件，这里是查询店铺信息，传入店铺Id</li>
<li>查询redis缓存，缓存存在就直接返回</li>
<li>缓存不存在，查询数据库，数据库数据存在就写入redis再返回，数据库数据不存在直接返回错误</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;  </span><br><span class="line">    <span class="comment">//尝试从redis查询缓存  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);  </span><br><span class="line">    <span class="comment">//判断缓存是否存在  </span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123; <span class="comment">//缓存存在，直接返回  </span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);  </span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//缓存数据不存在，根据条件查数据库数据  </span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);  </span><br><span class="line">    <span class="comment">//数据库数据不存在  </span></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;数据不存在&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//数据库数据存在  </span></span><br><span class="line">    <span class="comment">//数据库数据写入缓存  </span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));  </span><br><span class="line">    <span class="comment">//返回查询的数据  </span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h2><table>
<thead>
<tr>
<th></th>
<th>内存淘汰</th>
<th>超时提出</th>
<th>主动更新</th>
</tr>
</thead>
<tbody><tr>
<td>简介</td>
<td>不用自己维护，利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据，下次查询时更新缓存</td>
<td>给缓存数据添加TTL时间，到期后自动删除缓存。下次查询时更新缓存</td>
<td>编写业务逻辑，当修改数据库的同时，更新缓存</td>
</tr>
<tr>
<td>一致性</td>
<td>差</td>
<td>低</td>
<td>好</td>
</tr>
<tr>
<td>维护成本</td>
<td>无</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<p>使用场景：</p>
<ul>
<li>低一致性需求：使用内存淘汰机制。例如店铺类型的缓存</li>
<li>高一致性需求：主动更新，加上超时剔除作为兜底方案。例如店铺详情的缓存。店铺商品数据的缓存</li>
</ul>
<p>一般我们会选择 <code>主动更新</code> 来作为我们的缓存更新策略。但使用 <code>主动更新</code> 须注意以下几个问题</p>
<ol>
<li>更新缓存时应选择直接删掉缓存，让缓存失效。而不是更新缓存的内容。如果选择更新缓存内容，会产生较多的 <mark style="background: #FF5582A6;">写</mark> 操作</li>
<li>应保证缓存与数据库的操作原子性，要么同时成功，要么同时失败。在 <mark style="background: #FFF3A3A6;">单体系统</mark> 上，我们可以<mark style="background: #ADCCFFA6;">把缓存与数据库的操作放在同一个事务里</mark>  而在 <mark style="background: #BBFABBA6;">分布式系统</mark> 里，则可以<mark style="background: #ADCCFFA6;">利用TCC等分布式事务方案</mark></li>
<li>在更新缓存时，应该先修改数据库内容再删除缓存。以确保在多线程下缓存与数据库不一致。</li>
</ol>
<blockquote>
<p>实际上，不管是 <mark style="background: #ABF7F7A6;"> 先删缓存再更新数据库</mark>  还是 <mark style="background: #FFB86CA6;">先更新数据库再删缓存</mark> 都是可以的。只不过前者较大概率会出现缓存跟数据库数据不一致的问题。后者也会出现此问题，但几率比起前者较小</p>
</blockquote>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><blockquote>
<p>缓存穿透是指 <mark style="background: #ABF7F7A6;">客户端请求的数据在缓存中和数据库中都不存在</mark> 这样缓存永远不会生效，这些请求都会到达数据库。为了解决这个问题，有以下两种方案解决</p>
</blockquote>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><strong>1. 缓存空对象</strong><br>当客户端请求获取一个不存在的数据时，程序把这个不存在的数据转成假数据写入Redis。这样下次有同样的请求的话，就直接从Redis返回</p>
<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ol>
<li>造成额外的内存消耗（可以通过设置TTL缓解）</li>
<li>且可能造成短期的数据不一致，例如用户访问了一个不存在的非法数据，这时会写入并返回空对象缓存。但短暂时间后，这个数据合法了，并写入数据库了。那此时用户再访问，返回的还是空缓存对象。当然，我们可以在数据合法化时，手动更新缓存，对原来的空对象进行覆盖，以此缓解该问题。</li>
</ol>
</li>
</ul>
<p><strong>2. 布隆过滤</strong><br>当客户端请求数据时，请求会先经过一个过滤器，由过滤器判断请求获取的数据存不存在。再决定放不放行。</p>
<ul>
<li>优点：内存占用少，没有多余的缓存数据</li>
<li>缺点<ol>
<li>实现较复杂</li>
<li>可能存在误判（如过滤器判定数据存在，但实际数据不存在<br><strong>3. 接口参数权限校验</strong><br>在API接口处对参数进行校验，过滤非法值。也可以给接口添加访问权限，并对访问频率进行限流等。</li>
</ol>
</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><blockquote>
<p>缓存雪崩是指在 <mark style="background: #FFB86CA6;">同一时间段大量的缓存数据同时失效</mark>  或者 <mark style="background: #BBFABBA6;">redis服务宕机</mark>  导致大量的请求数据直接到达数据库，给数据库带来巨大压力</p>
</blockquote>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li>给不用的缓存的TTL添加随机值，让缓存数据过期时间分散开。</li>
<li>利用redis集群提高服务的可用性，主从redis服务，一台挂了，另一台顶上</li>
<li>给缓存业务添加降级限流策略，redis挂了，随机对一些请求直接返回错误，而不是全都去查数据库</li>
<li>给业务添加多级缓存</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><blockquote>
<p><strong>缓存击穿问题</strong>也叫 <mark style="background: #ABF7F7A6;">热点Key问题</mark> 就是一个被 <mark style="background: #FFF3A3A6;">高并发访问并且缓存重建业务比较复杂的key突然失效</mark> 了，无数的访问请求就会给数据库带来巨大压力。</p>
</blockquote>
<p><strong>常见的解决方案</strong></p>
<ol>
<li>互斥锁：在多个请求中，只有一个请求线程能拿到锁并查询数据库进行缓存重建，其他请求进入等待状态。等待缓存重建完成后，走缓存返回数据。</li>
<li>逻辑过期：将热点缓存数据设置为不过期，<mark style="background: #ABF7F7A6;">把过期时间存在对应缓存数据里</mark>，然后<mark style="background: #BBFABBA6;">由定时任务去异步加载数据更新缓存</mark>。在<mark style="background: #FFB86CA6;">缓存更新期间请求返回的还是旧数据</mark>。适合比较极端的场景，例如访问量特别大的场景，使用时需考虑业务是否能接受数据时间不一致。<table>
<thead>
<tr>
<th>解决方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>互斥锁</td>
<td>没有额外的内存消耗<br>保证一致性</td>
<td>线程需要等待<br>可能有死锁风险</td>
</tr>
<tr>
<td>逻辑过期</td>
<td>线程无需等待，性能较好</td>
<td>不保证一致性<br>有额外内存消耗</td>
</tr>
</tbody></table>
</li>
</ol>
<p><strong>互斥锁</strong><br>简单的案例，利用redis的 <code>SETNX</code> 命令实现简单的互斥锁<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/09/xvn4I3LG5Thqjwt.png"
                      alt="互斥锁解决缓存击穿 _1_.png"
                ></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">queryMutex</span><span class="params">(<span class="keyword">final</span> String key)</span> &#123;  </span><br><span class="line">    <span class="comment">//尝试从redis查询缓存  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheData</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);  </span><br><span class="line">    <span class="keyword">if</span>(cacheData == <span class="literal">null</span>) &#123; <span class="comment">//缓存失效，需要重建  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">//加锁，开始缓存重建  </span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);  </span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;  </span><br><span class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">//获取锁失败，休眠后再次尝试  </span></span><br><span class="line">                <span class="keyword">return</span> queryMutex(key); <span class="comment">//递归重试  </span></span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//获取锁成功，开始缓存重建  </span></span><br><span class="line">            <span class="comment">//二次缓存检查  </span></span><br><span class="line">            <span class="type">String</span> <span class="variable">dupCheck</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);  </span><br><span class="line">            <span class="keyword">if</span> (StrUtil.isNotBlank(dupCheck)) &#123;  </span><br><span class="line">                <span class="keyword">return</span> JSONUtil.toBean(dupCheck, YouBean.class);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//缓存重建逻辑....</span></span><br><span class="line">            <span class="comment">//防止穿透逻辑....</span></span><br><span class="line">            <span class="comment">//缓存写入逻辑....  </span></span><br><span class="line">            <span class="comment">//缓存返回逻辑....</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            unlock(lockKey);<span class="comment">//解锁  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cacheData;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;  </span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;lock&quot;</span>, LOCK_TTL, TimeUnit.MINUTES);  </span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;  </span><br><span class="line">    stringRedisTemplate.delete(key);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>逻辑过期</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/09/2oxnMZumQL1JlGp.png"
                      alt="逻辑过期解决缓存击穿.png"
                ></p>
<p>以下用例实现了一个简单的逻辑过期，其中上锁使用Redis的  <code>SETNX</code>  实现</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Shop <span class="title function_">queryWithLogical</span><span class="params">(Long id)</span> &#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">dataJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);  </span><br><span class="line">    <span class="comment">//缓存未命中，直接返回  </span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(dataJson)) <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="comment">//缓存命中  </span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(dataJson, RedisData.class);  </span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">cacheExpire</span> <span class="operator">=</span> redisData.getExpire();  </span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);  </span><br><span class="line">    <span class="keyword">if</span> (cacheExpire.isAfter(LocalDateTime.now())) &#123;<span class="comment">//缓存未过期，直接返回数据  </span></span><br><span class="line">        <span class="keyword">return</span> shop;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//缓存过期，开始独立线程重建  </span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;  </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);  </span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;  </span><br><span class="line">        <span class="comment">////获取锁成功，开启独立线程，  </span></span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">//实现缓存重建逻辑</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();  </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">                unlock(lockKey);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//获取锁失败，直接返回旧数据  </span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>note</category>
        <category>JavaWeb</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>redis</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记</title>
    <url>/git/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>工作区: 包含.git文件夹的目录就是工作区，也就是你的项目文件夹</p>
<p>暂存区: <strong>.git</strong>文件夹中的index文件是暂存区,也叫做stage，是临时保存修改文件的地方</p>
<p>版本库: <strong>.git</strong>文件夹是版本库，版本库中存储了许多配置信息，日志信息，文件版本等</p>
<blockquote>
<p>流程: 工作区发生改变后使用命令[ git add . ] 将修改临时保存到暂存区, 使用命令 [ git commit -m “提交信息”] 提交到版本库</p>
</blockquote>
<h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><ul>
<li>untracked 未跟踪 [未被纳入版本控制]</li>
<li>tracked [已被纳入版本控制]<ul>
<li>Unmodified 未修改状态</li>
<li>Modified 已修改状态</li>
<li>Staged 已暂存状态</li>
</ul>
</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局设置</span></span><br><span class="line"><span class="comment"># 设置用户名</span></span><br><span class="line">git config --global user.name <span class="string">&quot;用户名&quot;</span></span><br><span class="line"><span class="comment"># 设置用户邮箱</span></span><br><span class="line">git config --global user.email <span class="string">&quot;邮箱地址&quot;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="仓库操作"><a href="#仓库操作" class="headerlink" title="仓库操作"></a>仓库操作</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件的修改添加到暂存区</span></span><br><span class="line">git add [file1][file2]...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件, 并将这次操作放入暂存区</span></span><br><span class="line">git <span class="built_in">rm</span> [file1][file2]...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">git <span class="built_in">rm</span> --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件改名，这次操作放入暂存区</span></span><br><span class="line">git <span class="built_in">mv</span> [file-original] [file-renamed]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将暂存区的文件取消暂存或者切换到指定版本</span></span><br><span class="line">git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将暂存区的文件修改提交到版本区</span></span><br><span class="line">git commit -m <span class="string">&quot;提交信息&quot;</span> [file]</span><br><span class="line">git commit [file1][file2]... -m <span class="string">&quot;提交信息&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程仓库</span></span><br><span class="line">git remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程仓库</span></span><br><span class="line">git remote add [shotName] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从远程仓库克隆</span></span><br><span class="line">git <span class="built_in">clone</span> [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从远程仓库拉取</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到远程仓库</span></span><br><span class="line">git push -u [shotName] [branchName]</span><br></pre></td></tr></table></figure></div>

<h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看分支</span></span><br><span class="line"><span class="comment"># 不加参数 列出所有本地分支</span></span><br><span class="line"><span class="comment"># -r 列出所有远程分支</span></span><br><span class="line"><span class="comment"># -a 列出本地跟远程的所有分支</span></span><br><span class="line">git branch [-r/-a]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch [name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建分支并切换</span></span><br><span class="line">git checkout -b [name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到远程仓库分支</span></span><br><span class="line">git push [shortName] [name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并分支</span></span><br><span class="line">git merge [name]</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>React笔记</title>
    <url>/html/React%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="React的优点和特性"><a href="#React的优点和特性" class="headerlink" title="React的优点和特性"></a>React的优点和特性</h2><ol>
<li>React使用虚拟DOM，减少了真实DOM的操作，性能比较高</li>
<li>React采用组件系统，核心思想是将页面中的任何一个区域获取元素都可以看作一个组件；常用组件有：UI组件，容器组件，受控组件，非受控组件，类组件，函数式组件，高阶组件</li>
<li>React是单项数据流，需要手动设置数据。这与Vue是最大的区别，Vue是双向数据绑定</li>
<li>React使用JSX语法，这也是React特有的</li>
<li>最新的React拥有很多功能强大的钩子函数</li>
</ol>
<h2 id="React与Vue的区别"><a href="#React与Vue的区别" class="headerlink" title="React与Vue的区别"></a>React与Vue的区别</h2><ul>
<li>React是Facebook团队维护的前端框架，是单向数据流，使用React提供的钩子函数进行数据绑定，采用JSX语法。有一整套的移动端解决方案：react、react-router、redux、react-native（app开发）。React功能更强大，更稳定，更安全，学习成本比Vue高，出现时间比Vue早，周边生态更好</li>
<li>Vue是由国人尤雨溪开发的前端框架，是双向数据流，采用模板语法，有很好的中文文档支持，学习成本比React低。也有一些列解决方案：vue、vue-router、vuex、weex（原生app解决方案）。</li>
</ul>
<h3 id="开发感受上的不同"><a href="#开发感受上的不同" class="headerlink" title="开发感受上的不同"></a>开发感受上的不同</h3><ul>
<li>在基于react+ts+antd的项目开发时，使用的是JSX语法，创建的更多是函数式组件，在循环，判断，属性绑定时，感觉更像是在写原生TS。同时因为React是单向数据流，所以需要使用React提供的钩子函数 <code>useState</code> 或 <code>useReducer</code> 来获取和设置数据。我们也可以自定义钩子来实现一些业务功能。</li>
<li>在基于Vue3+ts+element-plus的项目开发时，使用的是模板语法（类似传统HTML的方式），创建的是xxx.vue的文件的组件。使用了组合式API和 <code>setup</code> 语法糖。可以让编写js代码时更接近原生体验，当然也可以选择选项式的API，具体因项目组而异。在循环，判断，属性绑定时，使用的是Vue提供的指令，同时因为Vue是双向数据绑定，我们使用 ref 和 reactive 为数据创建响应对象，通过双大括号在模板区域使用 <code>&#123;&#123; 响应对象名 &#125;&#125;</code> 其真实值会被自动解析映射到对应元素上</li>
</ul>
<h2 id="新版React的特性"><a href="#新版React的特性" class="headerlink" title="新版React的特性"></a>新版React的特性</h2><ol>
<li><p>使用了React Fiber代替了diff算法，在React16前使用的是递归和diff算法来处理组件更新和渲染，而JS是单线程语言，当遇到长时间的任务时，主线程会阻塞，导致其他任务无法得到执行，从而造成页面卡顿和不响应。<br> Fiber会将耗时的长任务分成很多小片，这样每一个小片运行时间短，虽然总耗时还是一样的，但是在小片任务运行完毕后给了其他任务执行的机会。</p>
</li>
<li><p>ReactDOM.render改成了ReactDOM.createRoot</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以前</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在</span></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>添加了useTransition和useDeferredValue, 将紧急更新与转换分开。</p>
</li>
<li><p>添加了useId,用于生成唯一ID。</p>
</li>
<li><p>添加了createRoot，标识使用并发新功能。</p>
</li>
<li><p>添加选择性hydrate。</p>
</li>
<li><p>添加了transition为useTransition没有待处理时的callback。</p>
</li>
<li><p>strictMode重新运行效果以检查可恢复状态。</p>
</li>
<li><p>添加了useSyncExternalStore以帮助外部存储库与react集成。</p>
</li>
<li><p>添加了useInsertionEffect用于css-in-js库。</p>
</li>
</ol>
<h2 id="props和state的区别"><a href="#props和state的区别" class="headerlink" title="props和state的区别"></a>props和state的区别</h2><p>props是组件的配置，有父组件传递给子组件，就子组件而言，<mark style="background: #BBFABBA6;">props是只读的</mark>，组件无法修改其自身的props。props除了可以传递数据外也可以传递回调函数。</p>
<p>state是一种数据结构，用于组件挂载时所需的数据默认值，可能会随用户对组件的操作或事件的推移而发生改变。</p>
<h2 id="setState的使用和同步异步问题"><a href="#setState的使用和同步异步问题" class="headerlink" title="setState的使用和同步异步问题"></a>setState的使用和同步异步问题</h2><p>setState本身不是异步的，只是因为react的性能优化机制所以体现为异步（在同一个函数里，调用多次setState时会进行合并处理）<br>在react的生命周期函数或者作用域下为异步，在原生环境中（事件绑定函数或者setTimeout）为同步</p>
<p><strong>setState的两个参数</strong></p>
<ul>
<li>第一个参数可以是对象或者一个回调函数。如是函数形式，那么它将接受两个参数，分别是 <code>prevState</code> 表示更改前的状态 和 <code>props</code> 表示当前组件的属性<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象形式</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">key</span>: value &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数形式</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 根据 prevState 和 props 计算新的状态对象</span></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">key</span>: value &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></li>
<li>第二个参数为可选的回调函数（会在更新完毕并重新渲染后被调用，一般用于状态更新后需要立刻执行的操作）<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">key</span>: value &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在状态更新后执行一些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>合并执行</strong><br>react会对同个函数中的多次setState进行合并执行，因为合并使用的是 <code>Object.assign</code> 所以导致key相同时，setState只会执行一次</p>
<p><strong>调用后的流程</strong></p>
<ul>
<li>setState会进行状态更新，将传入的参数对象与组将当前状态合并，然后触发所谓的调和过程，经过调和过程，根据新的state，React会重新构建虚拟DOM，并进行diff算法对比新旧虚拟DOM树的区别，进行视图更新</li>
<li>setState采用任务队列机制，不会马上更新，而是加入队列在下一次事件循环时一次执行</li>
</ul>
<h3 id="React18上-setState-和以前的区别"><a href="#React18上-setState-和以前的区别" class="headerlink" title="React18上 setState 和以前的区别"></a>React18上 setState 和以前的区别</h3><p>在React18之后，无论在什么样的语境中，setState都是异步处理，如果需要异步转同步，可以使用 <code>flushSync</code> ，如下所示用 flushSync包裹 setState语句可以将异步转同步</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">// flushSync它方法就可以让里面的操作为同步</span></span><br><span class="line"><span class="keyword">import</span> &#123; flushSync &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    state = &#123; <span class="attr">count</span>: <span class="number">100</span> &#125;</span><br><span class="line">    addCount = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// react18中，就想让setState它为同步， setState它就是同步的</span></span><br><span class="line">        <span class="title function_">flushSync</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;)) &#125;)</span><br><span class="line">        <span class="comment">// 因为setState放在flushSync方法里面了，则它现在是一个同步的，所以在此处可以得到最新的数据</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.addCount&#125;</span>&gt;</span>累加count<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span></span><br></pre></td></tr></table></figure></div>

<h2 id="受控组件与非受控组件"><a href="#受控组件与非受控组件" class="headerlink" title="受控组件与非受控组件"></a>受控组件与非受控组件</h2><p>React组件的数据渲染被调用者传递的props或state完全控制的组件叫受控组件，否则叫非受控组件。如下所示</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//受控组件，使用state修改和获取值</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Components1</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> [name, setName] = <span class="title function_">useState</span>(props.<span class="property">name</span>)</span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">		<span class="title function_">setName</span>(e.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;name&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;handleChange&#125;/</span>&gt;</span></span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非受控组件，使用ref获取值</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Components2</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> divRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;divRef&#125;/</span>&gt;</span></span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><ul>
<li>父传子：子组件通过props接收来自父组件的数据</li>
<li>子传父：一般使用回调函数（props中定义回调函数），子组件调用父组件给的回调函数，将数据发送给父组件</li>
<li>兄弟组件之间： 兄弟组件之间传数据可以使用状态提升，将需要传输的状态提升到 父组件中，由父组件统一管理</li>
<li>祖先传子孙：使用Context（上下文），使用Provider 发送数据，使用Consumer接收数据</li>
<li>任意组件间复杂传参：使用Redux对状态进行统一管理，就可实现任意组件之间的复炸数据传参</li>
</ul>
<h2 id="常用钩子函数"><a href="#常用钩子函数" class="headerlink" title="常用钩子函数"></a>常用钩子函数</h2><ol>
<li>useState：用于在函数式组件中管理状态。</li>
<li>useEffect：用于处理副作用操作，例如订阅数据、更新 DOM 等。</li>
<li>useContext：用于在函数式组件中访问上下文（Context）。</li>
<li>useReducer：用于管理复杂的状态逻辑，类似于 Redux 中的 reducer。</li>
<li>useRef：用于创建可变的 ref 对象，用于存储任意可变值。</li>
<li>useMemo：用于记忆计算结果，避免不必要的重复计算。</li>
<li>useCallback：用于记忆回调函数，避免不必要的函数重新创建。</li>
<li>useLayoutEffect：类似于 useEffect，但在 DOM 更新之后同步触发。</li>
<li>useImperativeHandle：用于自定义暴露给父组件的实例值和函数。</li>
<li>useDebugValue：用于在 React 开发工具中显示自定义钩子的标签。</li>
</ol>
<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>useEffect是用来处理副作用的一个钩子函数，第一个参数接受一个函数，一般用于异步请求，DOM操作等。第二个参数接受一个数组，当数组中的值发生变化时，第一个参数的函数才会被调用。同时他还有一个返回值，会在组件销毁或调用函数前调用。如下所示</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">//逻辑代码，一般在这调用请求</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">	<span class="keyword">const</span> intervalId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">	&#125;, <span class="number">1000</span>);</span><br><span class="line">	<span class="comment">// 返回值,返回一个清理函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// 会在组件卸载，或者副作用函数调用前触发，可以用来清理定时器</span></span><br><span class="line">		<span class="built_in">clearInterval</span>(intervalId)</span><br><span class="line">		<span class="comment">//do something....</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;, [name])</span><br></pre></td></tr></table></figure></div>

<ol>
<li>useEffect无参数时，相当于 componentDidMount 挂载后 和 componentDidUpdate 更新后；</li>
<li>第二个参数为空数组时，相当于 componentDidMount </li>
<li>返回的清理函数相当于 componentWillUnmount 卸载后</li>
</ol>
<h2 id="useMemo和useCallback的区别"><a href="#useMemo和useCallback的区别" class="headerlink" title="useMemo和useCallback的区别"></a>useMemo和useCallback的区别</h2><blockquote>
<p>两者都是优化性能用的，当依赖项发生变化时才会重新计算，否则返回缓存</p>
</blockquote>
<p><strong>useMemo：</strong> 是用于记忆计算结果的钩子函数。它接收一个计算函数和一个依赖数组作为参数，并返回计算函数的结果。useMemo 会在依赖数组中的任何值发生变化时重新计算结果，否则会使用上一次的缓存结果，会执行一次并返回结果（类似Vue的计算属性）</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useMemo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">&#123; a, b &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 计算逻辑</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;, [a, b]); <span class="comment">// 当a或b发生变化时，会重新计算，否则返回缓存</span></span><br><span class="line">  <span class="comment">// 其他组件逻辑...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;result&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>useCallback：</strong> 是用于记忆回调函数的钩子函数。它接收一个回调函数和一个依赖数组作为参数，并返回一个记忆化后的回调函数。这意味着返回的回调函数仅在依赖数组中的值发生变化时才会更改，否则会重用上一次的回调函数。不会自动执行，而是返回一个函数让我们调用</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">&#123; onClick &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理点击事件</span></span><br><span class="line">    <span class="title function_">onClick</span>();</span><br><span class="line">  &#125;, [onClick]); <span class="comment">//当onClick变化时，才会重新返回</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他组件逻辑...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="useEffect-和useLayoutEffect的区别"><a href="#useEffect-和useLayoutEffect的区别" class="headerlink" title="useEffect 和useLayoutEffect的区别"></a>useEffect 和useLayoutEffect的区别</h2><p>区别在于调用时机的不同：useLayoutEffect和原来componentDidMount和componentDidUpdate一致，在react完成DOM更新后马上同步调用的代码，会阻塞页面渲染。而useEffect是会在整个页面渲染完才会调用的代码。</p>
<h2 id="高阶组件（Higher-Order-Component-HOC）"><a href="#高阶组件（Higher-Order-Component-HOC）" class="headerlink" title="高阶组件（Higher-Order Component | HOC）"></a>高阶组件（Higher-Order Component | HOC）</h2><p>高阶组件其实就是一个函数，用于对已有的组件进行拓展增强，传递的参数是一个组件，返回值是增强后的组件。可以将通用逻辑抽离出来，增加复用。或者对已有的组件进行包装，修改props或增加其他功能，而不必去修改原组件代码</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">withLogger</span> = (<span class="params">WrappedComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component has mounted.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component will unmount.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 渲染原始组件，并传递所有的 props</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyComponent</span> = (<span class="params">&#123; name &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, &#123;name&#125;!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用高阶组件包装原始组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">EnhancedComponent</span> = <span class="title function_">withLogger</span>(<span class="title class_">MyComponent</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用增强后的组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">EnhancedComponent</span> <span class="attr">name</span>=<span class="string">&quot;jack&quot;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>代码复用：将通用逻辑和功能转为高阶组件，可在多个组件间共享使用</li>
<li>认证和授权：通过高阶组件封装身份认证，权限控制等逻辑。对需要认证和授权额组件进行包装，以实现访问认证功能</li>
<li>数据获取和状态管理：通过高阶组件可以封装数据获取逻辑、状态管理等，使组件具备统一的数据流和状态管理能力，减少冗余代码。</li>
<li>功能增强：通过高阶组件可以对组件进行功能增强，例如添加日志记录、性能监控、错误边界等功能。</li>
</ol>
<h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><blockquote>
<p>传送门是可以将组件渲染到其他层级结构之外的DOM节点上，而不受父组件限制的技术</p>
</blockquote>
<h2 id="lazy和suspense"><a href="#lazy和suspense" class="headerlink" title="lazy和suspense"></a>lazy和suspense</h2><ul>
<li>lazy 是一个函数，<mark style="background: #FFB86CA6;">用于延迟加载（懒加载）组件</mark>。通过使用 lazy，你<mark style="background: #FFF3A3A6;">可以将组件的加载推迟到它们实际被渲染到屏幕上时</mark>。这样可以减少初始加载时间并提高应用程序的性能。</li>
<li>Suspense <mark style="background: #BBFABBA6;">是一个用于处理异步加载组件的组件</mark>。它可以在组件树中的任意位置使用，并且用于指定在等待异步加载的组件时应该显示的占位符。<br><strong>例子：</strong><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; lazy, <span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./MyComponent&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>一般用在对话框、提示框等组件上，将其显示在根节点，配合遮罩实现盖住所有元素的效果</p>
<h2 id="封装过那些自定义钩子"><a href="#封装过那些自定义钩子" class="headerlink" title="封装过那些自定义钩子"></a>封装过那些自定义钩子</h2><ol>
<li>我封装过菜单的权限，将没有权限的菜单过滤掉；</li>
<li>将时间戳转日期时间；</li>
<li>还将页面中的复杂逻辑进行了hook的封装，比如：表格、分页、查询、添加、修改、删除都做成了hook的形式进行调用；</li>
<li>完成url地址参数解析的hook；</li>
<li>完成标题的自定义hook。</li>
<li>快捷的导航按钮功能；</li>
<li>头部的title栏。</li>
<li>头部返回功能。</li>
<li>日志处理程序。</li>
<li>数据校验程序。</li>
<li>异常处理程序</li>
</ol>
<h2 id="React的项目优化"><a href="#React的项目优化" class="headerlink" title="React的项目优化"></a>React的项目优化</h2><ol>
<li>页面卸载前，需要 停止定时器、停止获取数据、停止轮播图、停止未渲染完的页面、对事件解除绑定；</li>
<li>state 里面的数据越少越好，不是页面上显示的数据，建议保存成 react的本地变量；减少使用 state和 setState；</li>
<li>静态组件使用PureComponent 或shouldComponentUpdate ,在 函数式组件里可以使用memo；</li>
<li>一个功能一个组件，组件尽可能拆分</li>
<li>移动端的搜索框和长列表的滚动条事件可以使用手写防抖节流，或lodash 实用工具库中的防抖节流函数；</li>
<li>路由做了封装处理，路由配置统一写在config中，统一配置路由守卫；注意 ：router5.*   router6.* 配置写法有所不同；</li>
<li>路由 使用懒加载、保证 首页只加载显示的页面内容，减少加载时间  lazy suspense 对路由进行了懒加载；</li>
<li>对axios 进行封装   请求拦截、响应拦截；</li>
<li>对api进行封装、对数据统一管理；</li>
<li>项目的组件中如果存在重复的功能需要封装为  类组件：封装为 高阶组件 HOC或函数式组件自定义hook；</li>
<li>状态 （包括 购物车、用户状态、各个页面的数据） 做了统一处理，保管在 redux中；</li>
<li>使用了 antd mobile 的ui框架；</li>
<li>如果使用的React版本是16以上，项目建议使用钩子函数（hook）的写法, 例如：useState，useEffect、useRef，优化时使用了 useCallback  useMemo；</li>
</ol>
<h2 id="shouldComponentUpdate的作用"><a href="#shouldComponentUpdate的作用" class="headerlink" title="shouldComponentUpdate的作用"></a>shouldComponentUpdate的作用</h2><p>shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。<br>有些静态组件在父组件更新时是不需要重新渲染的，这时就需要shouldComponentUpdate。shouldComponentUpdate方法，避免了静态资源重复性渲染，可以极大的提高性能。 shouldComponentUpdate，在类组件中可以也可以写成PureComponent，在函数式组件中可以写成 React.memo。</p>
<h2 id="虚拟DOM为什么会提高性能"><a href="#虚拟DOM为什么会提高性能" class="headerlink" title="虚拟DOM为什么会提高性能"></a>虚拟DOM为什么会提高性能</h2><p>虚拟DOM是在JS和真实DOM之间增加了一个缓存，利用diff算法避免了没必要的DOM操作，从而提高性能。<br>用JS对象结构表示DOM树的结构，利用虚拟树构建一个真实DOM树。当状态更新时，会重新创建一棵新的虚拟树，然后对比并记录新旧两棵树的差异。将所记录的差异更新到真实树中。更新视图</p>
<h2 id="diff原理"><a href="#diff原理" class="headerlink" title="diff原理"></a>diff原理</h2><p>将树形结构按层级分解，只比较同级元素。会给列表结构每个单元添加唯一的key属性方便比较。<br>如果是同一个类的组件，则会继续往下做diff比较，如果不是同一个类的组件，则删除该组件下的所有子组件创建新的</p>
<h2 id="UI组件和容器组件的不同"><a href="#UI组件和容器组件的不同" class="headerlink" title="UI组件和容器组件的不同"></a>UI组件和容器组件的不同</h2><p>UI组件：只负责UI呈现，不带任何的业务逻辑；没有状态（不使用state）；所有数据都有props提供；不适用任何Redux的API<br>容器组件：负责管理数据和业务逻辑，不负责UI呈现；带有内部状态，使用Redux的API<br>如果一个组件既有UI又有业务逻辑，那么可以将其拆分为两个部分：一个容器组件包含一个UI组件。前者负责与外部通信，将数据传给后者渲染视图</p>
<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><blockquote>
<p>Redux是一个状态管理器，用于组件之间的通信</p>
</blockquote>
<p>使用流程如下</p>
<ol>
<li>store是redux的数据仓库，保存数据信息</li>
<li>通过reducer定义初始状态</li>
<li>在组件中触发动作生产者，调用 actions</li>
<li>使用dispatch将action派发到store的redurces中</li>
<li>在reducers中接受旧值和动作，返回新的值</li>
<li>当状态改变时，会被 <code>subscribe</code> 监听到，然后触发 <code>render</code> 重新渲染页面</li>
</ol>
<p><strong>三大使用原则：</strong> 唯一数据源，状态是只读的，数据的更改必须使用reducer完成</p>
<h3 id="redux-sage-和-redux-thunk的区别"><a href="#redux-sage-和-redux-thunk的区别" class="headerlink" title="redux-sage 和 redux-thunk的区别"></a>redux-sage 和 redux-thunk的区别</h3><p>redux-saga可以解决thunk 的两个问题： </p>
<ol>
<li>action的形式不统一 </li>
<li>就是异步操作太为分散，分散在了各个action中 不易维护<br>saga将异步操作放到统一的一个文件中处理</li>
</ol>
<h2 id="React路由传参"><a href="#React路由传参" class="headerlink" title="React路由传参"></a>React路由传参</h2><p><strong>params</strong><br>读取参数:this.props.match.params.***<br>优势 ： 刷新地址栏，参数依然存在 缺点:只能传字符串，并且，如果传的值太多的话，url会变得长而丑陋。<br>刷新页面后参数不消失，参数会在地址栏显示，需要在Route中配置参数名称<br><strong>query</strong><br>读取参数: this.props.location.query.***<br>优势：传参优雅，参数为对象； 缺点：刷新地址栏，参数丢失<br><strong>state</strong><br>读取参数: this.props.location.state<br>优势：传参优雅，参数为对象； 缺点：刷新地址栏，参数丢失<br><strong>search</strong><br>读取参数：this.props.location.search<br>用location.search所获取的是查询字符串，所以，还需要进一步的解析，自己自行解析，也可以使用第三方模块：qs，或者nodejs里的query-string</p>
<h2 id="支付流程"><a href="#支付流程" class="headerlink" title="支付流程"></a>支付流程</h2><ol>
<li>到商品详情页，点击添加购物车按钮，将商品添加到购物车，在添加购物车之前，要判断一下用户是否是登录状态</li>
<li>在购物车页面，计算了 商品的总价，点击 去结算，调用生成 预订单的api接口，跳转到预订单的页面</li>
<li>在预订单的页面选择邮寄的地址、选择 优惠券、是否开发票、是否用积分、是否包邮、 计算一下这个订单的总价格，调用 后台接口，生成订单。</li>
<li>点击提交订单，选择支付方式 （微信扫码支付、跳转到微信平台支付、跳转到支付宝平台支付）</li>
<li>在后台调起支付接口，当支付成功或者支付失败的情况下，都会给 前端页面返回一个结果，如果支付成功，就跳转到 未发货订单页面；如果支付失败，就跳转到 为支付订单页面；<br> 可以使用 websocket 或者是 轮询处理，究竟什么时候算是支付完成了，如果支付时间超时，也算是一种支付失败；<br> 支付失败：有可能给的订单的数据不对，网络不通支付时间超时，或者取消支付，（注意：所以的消息都是第三方发给 后台，后台再发给前台的）</li>
</ol>
]]></content>
      <categories>
        <category>note</category>
        <category>html</category>
        <category>js</category>
        <category>css</category>
        <category>react</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>html</tag>
        <tag>css</tag>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-JDBC-API详解</title>
    <url>/jdbc-note/API%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个链接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost/database?useSSL=false&amp;allowPublicKeyRetrieval=true&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url,user,pwd);</span><br></pre></td></tr></table></figure></div>



<h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><p><strong>用于获取执行SQL的对象和管理事务</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建链接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url,user,pwd);</span><br><span class="line"><span class="comment">//要执行的SQL语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE users SET money = 1000 WHERE id = 114514;&quot;</span>;</span><br><span class="line"><span class="comment">//创建执行对象</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//开启事务</span></span><br><span class="line">    connection.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//执行语句</span></span><br><span class="line">    statement.executeUpdate(sql);</span><br><span class="line">    <span class="comment">//事务提交</span></span><br><span class="line">    connection.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">//若执行失败则回滚事务</span></span><br><span class="line">    connection.rollback();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><p>作用：执行SQL语句</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行DML DDL 语句， 增删改，返回受影响的行数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">executeUpdate</span><span class="params">(String sql)</span></span><br><span class="line"><span class="comment">//执行DQL语句 返回ResultSet结果集对象,查询语句</span></span><br><span class="line">ResultSet <span class="title function_">executeQuery</span><span class="params">(String sql)</span></span><br></pre></td></tr></table></figure></div>

<h2 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h2><p>作用：一个结果集对象，封装了DQL查询语句的结果</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行DQL语句返回ResultSet对象</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将光标从当前位置往前移动一行，判断当前是否为有效行</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">next</span><span class="params">()</span>; <span class="comment">//true 有效行，当前行有数据 | 无效行 当前行无数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数据</span></span><br><span class="line"><span class="comment">//数据类型 get数据类型(参数);</span></span><br><span class="line">String <span class="title function_">getString</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字段名 name 的值</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    System.out.println(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><p>作用：预编译SQL语句并执行，预防SQL注入问题</p>
<blockquote>
<p>  SQL注入是通过操作输入来修改事先定义号的SQL语句，用以达到攻击服务器的作用 </p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url,user,pwd);</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM goods WHERE id = ?&quot;</span>;</span><br><span class="line"><span class="comment">//获取预编译Sql对象</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line"><span class="comment">//设置 ？的参数值</span></span><br><span class="line"><span class="comment">//参数位置 | 参数值</span></span><br><span class="line">ps.setInt(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//执行语句</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery();</span><br><span class="line">rs.next();</span><br><span class="line">System.out.println(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title>前端备忘笔记</title>
    <url>/html/%E5%89%8D%E7%AB%AF%E5%A4%87%E5%BF%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="CSS优先级"><a href="#CSS优先级" class="headerlink" title="CSS优先级"></a>CSS优先级</h3><blockquote>
<p>不同选择器具有不同的优先级，优先级高的选择器会覆盖优先级低的选择器样式<br>优先级：继承 &lt; 通配符选择器 &lt; 标签选择器 &lt; 类选择器 &lt; id选择器 &lt; 行内样式 &lt; !important<br><mark style="background: #FFF3A3A6;">作用：当一个标签使用了多个选择器时发生样式冲突，会按照优先级选择最终样式</mark></p>
</blockquote>
<ul>
<li>!important 写在属性后面，分号前面</li>
<li>!important 不能提升继承的优先级（继承的优先级最低）</li>
<li>不建议使用 !important</li>
</ul>
<h3 id="优先级权重计算"><a href="#优先级权重计算" class="headerlink" title="优先级权重计算"></a>优先级权重计算</h3><blockquote>
<p>当很多的样式被应用到某一个元素上时，权重将决定哪种样式生效<br>口诀：从0开始，一个行内样式+1000，一个id选择器+100，一个属性选择器、class或者伪类+10，一个元素选择器，或者伪元素+1，通配符+0最后加起来看哪个值高就选哪个</p>
</blockquote>
<p>例子</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: blueviolet;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.p1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: brown;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span><span class="selector-class">.d1</span> <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">38</span>, <span class="number">117</span>, <span class="number">255</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 带有标签，类，两种选择器，权重第二大 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span><span class="selector-class">.d1</span> <span class="selector-tag">p</span><span class="selector-class">.p1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: burlywood;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 带有标签，类，id三种选择器，权重最大,本例会使用这个 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span><span class="selector-class">.d1</span> <span class="selector-tag">p</span><span class="selector-class">.p1</span><span class="selector-id">#test</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">49</span>, <span class="number">255</span>, <span class="number">73</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">            测试文本</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>


<h3 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h3><blockquote>
<p>元素显示模式就是元素（标签）以什么方式进行显示。比如，自己占一行，一行可以放多个等</p>
</blockquote>
<h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4><blockquote>
<p>常见的块元素标签 h系列 p div ul ol li<br>p 标签主要用于存放文字，因此 p 里面不能放块级元素，特别是不能放 div<br>同理h系列都是文字类块级标签，里面也不能放其他块级元素</p>
</blockquote>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>独占一行</li>
<li>高度，宽度、外边距以及内边距都可以控制</li>
<li>宽度默认是容器<mark style="background: #BBFABBA6;">（父级宽度）</mark>的100%</li>
<li>是一个容器及盒子，里面可以放行内或者块级元素</li>
</ul>
<h4 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h4><blockquote>
<p>常见的块元素标签 a strong b em i del s ins u span</p>
</blockquote>
<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ul>
<li>相邻行内元素在一行上，一行可以显示多个</li>
<li>高、宽直接设置是无效的</li>
<li>默认宽度就是它本身内容的宽度</li>
<li>行内元素只能容纳文本或其他行内元素</li>
</ul>
<h4 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h4><blockquote>
<p>常见的行内块标签 img input textarea</p>
</blockquote>
<h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><ul>
<li>和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙</li>
<li>一行可以显示多个（行内元素特点）</li>
<li>默认宽度就是它本身内容的宽度（行内元素特点）</li>
<li>高度，行高、外边距以及内边距都可以控制（块级元素特点）</li>
</ul>
<h4 id="显示模式转换"><a href="#显示模式转换" class="headerlink" title="显示模式转换"></a>显示模式转换</h4><ul>
<li>转换为块元素：display:block;</li>
<li>转换为行内元素：display:inline;</li>
<li>转换为行内块：display: inline-block;</li>
</ul>
<h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p><mark style="background: #FFB86CA6;">每一个标签都可以叫 盒子</mark><br>每个盒子模型由 内容区域(content) 内边距(padding) 外边距(margin) 边框构成(border)组成</p>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><h4 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h4><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">.p3 &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    top: -30px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;p1 p3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    相对文本</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h5 id="效果如下"><a href="#效果如下" class="headerlink" title="效果如下"></a>效果如下</h5><p>黄色区域是添加了 <code>position: relative</code>的区域，可以看到，黄色区域与文字之间有一个空白区域，这是 <code>top: -30px</code> 产生的，相对定位的元素可以理解成元素的幻影，其本体还在原地，但在其他地方显示。不会对其他元素的布局产生影响<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/04/27/5Mtf8P13hkrvTsx.png"
                      alt="image.png"
                ></p>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul>
<li>relative：是相对自身进行偏移</li>
<li>使用relative定位的元素，可以理解为产生了”幻影”，其本体依然在原来的位置上，不会影响页面中其他的元素的布局。而如果margin那么就会影响其他元素的布局</li>
</ul>
<h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><ul>
<li>绝对定位是以父元素的左上角原点为定位基准点，absolute 会将对象拖离出正常的文档流，不考虑它周围内容的布局。</li>
<li>如果父级没有设定position属性，那么当前的absolute则结合TRBL属性以浏览器左上角为原始点进行定位；</li>
<li>如果父级设定position属性，那么当前的absolute则结合TRBL属性以父级（最近）的左上角为原始点进行定位。</li>
</ul>
<h4 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h4><ul>
<li>粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。</li>
<li>当页面滚动没有超出目标区域时，它与 position:relative 类似</li>
<li>而当页面滚动超出目标区域时，它与 position:fixed 类似，会固定在目标位置</li>
</ul>
<h2 id="JavaScript相关"><a href="#JavaScript相关" class="headerlink" title="JavaScript相关"></a>JavaScript相关</h2><h3 id="防抖（Debounce）"><a href="#防抖（Debounce）" class="headerlink" title="防抖（Debounce）"></a>防抖（Debounce）</h3><blockquote>
<p>在单位时间内，频繁触发事件，只执行后最后一次<br>例如：手机号，邮箱等数据的检测。等待用户输入完成后再检测是否合法，使用防抖减少检测函数的触发频率</p>
</blockquote>
<p>例如以下例子<br>鼠标在box里每移动一像素，文本就会+1. 如果在实际业务中需要执行一定计算量的代码，此操作就会导致卡顿，性能不佳</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> i = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> counter = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.counter&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.box&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    box.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousemove&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">innerHTML</span> = i++</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li>使用 <code>lodash</code> 的debounce防抖函数</li>
<li>使用定时器 ( setTimeout ) 实现<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fn 需要进行防抖的函数</span></span><br><span class="line"><span class="comment">//t  停止操作多长时间后再执行业务函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, t</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	    <span class="comment">//如果有定时器就取消</span></span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	        <span class="comment">//执行业务函数</span></span><br><span class="line">            <span class="title function_">fn</span>()</span><br><span class="line">        &#125;, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logicFun</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用例</span></span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousemove&quot;</span>, <span class="title function_">debounce</span>(logicFun, <span class="number">500</span>))</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>需要注意的是不支持匿名函数，请把业务函单独抽出来</p>
</blockquote>
</li>
</ol>
<h3 id="节流（Throttle）"><a href="#节流（Throttle）" class="headerlink" title="节流（Throttle）"></a>节流（Throttle）</h3><blockquote>
<p>在单位时间内，频繁触发事件，只执行一次。可以理解成函数调用有个cd时间。<br>使用场景： 记录视频播放位置（ontimeupdate记录当前视频播放的时间，此事件触发频率很高，可以使用节流减缓保存函数的调用频率）</p>
</blockquote>
<ul>
<li>例子同防抖</li>
</ul>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li>使用 <code>lodash</code> 的throttle防抖函数</li>
<li>使用定时器 ( setTimeout ) 实现<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, t</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	    <span class="comment">//如果没有定时器，则创建</span></span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="title function_">fn</span>()</span><br><span class="line">                <span class="comment">// 清除定时器，在定时器里clearTimeout(timer)无法删除定时器</span></span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用同防抖</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
]]></content>
      <categories>
        <category>note</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-JDBC-连接池</title>
    <url>/jdbc-note/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<p><strong>简介: 数据库连接池是个容器, 负责分配, 管理数据库链接, 允许应用程序重复使用现有的数据库链接, 而不是重新建立一个新连接</strong></p>
<p>标准接口: DataSource</p>
<h3 id="Druid配置文件"><a href="#Druid配置文件" class="headerlink" title="Druid配置文件"></a>Druid配置文件</h3><div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql:///eoezora?useSSL=false&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#初始化连接数量</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#最大连接数</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">#最大等待时间 ms</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure></div>

<h3 id="加载配置"><a href="#加载配置" class="headerlink" title="加载配置"></a>加载配置</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.加载配置文件</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> DruidDemo.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">pro.load(is);</span><br><span class="line"><span class="comment">//2.获取连接池对象</span></span><br><span class="line"><span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"><span class="comment">//3.获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection();</span><br></pre></td></tr></table></figure></div>

<h3 id="归还连接-释放资源"><a href="#归还连接-释放资源" class="headerlink" title="归还连接|释放资源"></a>归还连接|释放资源</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet rs, Statement stmt, Connection conn)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rs!=<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stmt!=<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stmt.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (conn!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn.close();<span class="comment">//归还连接</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-MyBatis-增删改查</title>
    <url>/myBatis/Mybatis-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
    <content><![CDATA[<h2 id="增删改查例子"><a href="#增删改查例子" class="headerlink" title="增删改查例子"></a>增删改查例子</h2><h3 id="AccountMapper-xml"><a href="#AccountMapper-xml" class="headerlink" title="AccountMapper.xml"></a><strong>AccountMapper.xml</strong></h3><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- namespace是映射接口的路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.eoezora.mybatisDemo.mapper.AccountMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加数据, 参数POJO -&gt; EoeAccount --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加这两个 useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; 属性在insert标签里可以返回主键 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addAccount&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addAccount&quot;</span> &gt;</span></span><br><span class="line">        INSERT INTO account (name, age, brithDay, location)</span><br><span class="line">        <span class="comment">&lt;!-- 这里的名字要与POJO类力的变量名一致 --&gt;</span></span><br><span class="line">        VALUES (#&#123;name&#125;,#&#123;age&#125;,#&#123;brithDay&#125;,#&#123;location&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 删除一条数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delAccouintById&quot;</span>&gt;</span></span><br><span class="line">        DELETE</span><br><span class="line">        FROM account</span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 删除多条数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delAccouintByIds&quot;</span>&gt;</span></span><br><span class="line">        DELETE</span><br><span class="line">        FROM account</span><br><span class="line">        WHERE id in</span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">            collection需要遍历的集合 </span></span><br><span class="line"><span class="comment">            item 集合里的元素 </span></span><br><span class="line"><span class="comment">            separator 分隔符</span></span><br><span class="line"><span class="comment">            open 前缀符</span></span><br><span class="line"><span class="comment">            close 后缀符</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 查询所以数据 多个条件使用 and 分割 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAccounts&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.eoezora.mybatisDemo.pojo.EoeAccount&quot;</span>&gt;</span></span><br><span class="line">        SELECT *</span><br><span class="line">        FROM account;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据ID查询数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAccount&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.eoezora.mybatisDemo.pojo.EoeAccount&quot;</span>&gt;</span></span><br><span class="line">        SELECT *</span><br><span class="line">        FROM account</span><br><span class="line">        WHERE id = #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据ID修改数据 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 动态修改参考动态查询 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;setAccountAge&quot;</span>&gt;</span></span><br><span class="line">        UPDATE account</span><br><span class="line">        SET age = #&#123;age&#125;</span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="AccountMapper-class"><a href="#AccountMapper-class" class="headerlink" title="AccountMapper.class"></a><strong>AccountMapper.class</strong></h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.eoezora.mybatisDemo.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.eoezora.mybatisDemo.pojo.EoeAccount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//映射接口, 方法名与上方SQL映射xml里的ID一致</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;insert id=&quot;addAccount&quot; parameterType=&quot;com.eoezora.mybatisDemo.pojo.EoeAccount&quot;&gt;</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addAccount</span><span class="params">(EoeAccount eoeAccount)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;select id=&quot;selectAccounts&quot; resultType=&quot;com.eoezora.mybatisDemo.pojo.EoeAccount&quot;&gt;</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    List&lt;EoeAccount&gt; <span class="title function_">selectAccounts</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;select id=&quot;selectAccount&quot; parameterType=&quot;int&quot; resultType=&quot;com.eoezora.mybatisDemo.pojo.EoeAccount&quot;&gt;</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    EoeAccount <span class="title function_">selectAccount</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span><span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;delete id=&quot;delAccouintById&quot;&gt;</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delAccouintById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span><span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;delete id=&quot;delAccouintByIds&quot;&gt; 传入数组批量删除多条数据</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delAccouintById</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> <span class="type">int</span>[] id)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传递参数的三种方式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多个单独的参数, <span class="doctag">@Param</span>里的值与xml映射表的占位符一致,也就是与 xml 里的 #&#123;&#125; 里的一致 例如: #&#123;name&#125;</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    List&lt;EoeAccount&gt; <span class="title function_">selectAccountByCondition</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;age&quot;)</span> intn age)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果参数可以封装在同一个类里,也可以直接传一个对象过来. xml #&#123;&#125; 将使用该对象参数名作为占位符</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    List&lt;EoeAccount&gt; <span class="title function_">selectAccountByCondition</span><span class="params">(EoeAccount account)</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap key -&gt; value </span></span><br><span class="line"><span class="comment">     *  - 占位符名称 -&gt; 数值</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    List&lt;EoeAccount&gt; <span class="title function_">selectAccountByCondition</span><span class="params">(Map map)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用注解查询, 一般使用在简单的sql语句上, 复杂的语句还是使用xml映射</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM account WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    EoeAccount <span class="title function_">selectAccount</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用接口进行增删改查"><a href="#使用接口进行增删改查" class="headerlink" title="使用接口进行增删改查"></a>使用接口进行增删改查</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">    <span class="type">AccountMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(AccountMapper.class);</span><br><span class="line">    mapper.selectAccounts();</span><br><span class="line">    mapper.addAccount();</span><br><span class="line">    <span class="comment">//需要注意的是 mybatis 对数据库进行增删改的操作后需要手动提交</span></span><br><span class="line">    session.commit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取主键</span></span><br><span class="line"><span class="comment"> * 当数据添加完成后, 若insert标签有设置useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; 属性</span></span><br><span class="line"><span class="comment"> * 则可以根据 以下方式获取返回的主键id</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="type">EoeAccount</span> <span class="variable">ea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EoeAccount</span>(<span class="string">&quot;蔡某&quot;</span>,<span class="number">25</span>,<span class="string">&quot;1919-08-10&quot;</span>,<span class="string">&quot;荔枝星&quot;</span>);</span><br><span class="line">mapper.addAccount(ea);</span><br><span class="line">System.out.println(ea.getId());</span><br></pre></td></tr></table></figure></div>

<h2 id="多条件动态查询"><a href="#多条件动态查询" class="headerlink" title="多条件动态查询"></a>多条件动态查询</h2><p>在根据条件查询时,多个条件使用以下方式,传入的条件参数是固定的。比如下面这条是3个.</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询所以数据 多个条件使用 and 分割 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAccounts&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.eoezora.mybatisDemo.pojo.EoeAccount&quot;</span>&gt;</span></span><br><span class="line">    SELECT *</span><br><span class="line">    FROM account WHERE id = 1 AND name = &#x27;xxx&#x27; AND AGE = 24;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>有时候我们需要的是模糊查询, 用户给的条件数量是不固定的，有时一个有时三个。我们需要根据传来的条件参数数量来<strong>动态调整我们的SQL</strong>语句。MyBatis提供了许多标签来支持此功能: <strong>if</strong> | <strong>choose(when, otherwise)</strong> | <strong>trim(where, set)</strong> | <strong>foreach</strong></p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAccounts&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.eoezora.mybatisDemo.pojo.EoeAccount&quot;</span>&gt;</span></span><br><span class="line">    SELECT *</span><br><span class="line">    FROM account</span><br><span class="line">    <span class="comment">&lt;!-- 使用where标签可以解决第一个条件不存在时的报错, 同时会帮我们去掉多余的AND --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 下面为例 当id小于0，条件不会被拼到sql语句里,且会帮我们去掉name前面的AND --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- test后面跟判断条件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id &gt; 0&quot;</span>&gt;</span></span><br><span class="line">            AND id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">            AND name LIKE #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age &gt; 0&quot;</span>&gt;</span></span><br><span class="line">            AND age = #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="单条件动态查询"><a href="#单条件动态查询" class="headerlink" title="单条件动态查询"></a>单条件动态查询</h2><p>当我们需要单条件动态查询时，使用以下方法</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAccounts&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.eoezora.mybatisDemo.pojo.EoeAccount&quot;</span>&gt;</span></span><br><span class="line">    SELECT *</span><br><span class="line">    FROM account</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span><span class="comment">&lt;!-- 类似switch --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;id &gt; 0&quot;</span>&gt;</span><span class="comment">&lt;!-- 类似case --&gt;</span></span><br><span class="line">                id = #&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                name like #&#123;name&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;age &gt; 0&quot;</span>&gt;</span></span><br><span class="line">                age = #&#123;age&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span>1 = 1<span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span><span class="comment">&lt;!-- 类似default 使用where标签可以去掉这个 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>Mybatis接口方法可以接受各种各样的参数，底层会对这些参数进行不同的封装处理</p>
<h3 id="单个参数"><a href="#单个参数" class="headerlink" title="单个参数:"></a>单个参数:</h3><ul>
<li>POJO类型</li>
<li>Map集合</li>
<li>Coolection</li>
<li>List</li>
<li>Array</li>
<li>其他类型</li>
</ul>
<h3 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数:"></a>多个参数:</h3><p>类似</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">EoeAccount <span class="title function_">selectAccount</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span><span class="type">int</span> id, <span class="meta">@Param(&quot;name&quot;)</span>String name...)</span>;</span><br></pre></td></tr></table></figure></div>
<p>参数需要有@Param注解,里面的值与xml映射文件里的占位符一致</p>
<h2 id="D"><a href="#D" class="headerlink" title="#:D"></a>#:D</h2><h3 id="参数占位符"><a href="#参数占位符" class="headerlink" title="参数占位符"></a>参数占位符</h3><p>#{}: 执行SQL时, 会将#{}占位符替换成 ? 会自动设置参数, 防止sql注入</p>
<p>${}: 拼SQL语句,会出现sql注入问题.</p>
<p><strong>一般在传参数时使用 #{} 在对表名，列名进行动态设置时，使用${} 进行拼接.</strong></p>
<h3 id="parameterType"><a href="#parameterType" class="headerlink" title="parameterType"></a>parameterType</h3><p>用于设置传入的参数类型, 此属性可以省略</p>
<h3 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h3><p>执行SQL语句后返回的数据进行封装，此属性指定封装后的类型</p>
<h3 id="xml中特殊字符处理"><a href="#xml中特殊字符处理" class="headerlink" title="xml中特殊字符处理"></a>xml中特殊字符处理</h3><p>在xml文件写SQL语句时难免会出现 大于小于的判断 而 &lt; 是xml标签起始。所以需要进行处理。下面为例子</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAccount&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.eoezora.mybatisDemo.pojo.EoeAccount&quot;</span>&gt;</span></span><br><span class="line">    SELECT *</span><br><span class="line">    FROM account</span><br><span class="line">    <span class="comment">&lt;!-- 此处的小于号 &lt; 会报错, 因为被xml判定成了不完成的标签 --&gt;</span></span><br><span class="line">    WHERE id &lt; 5;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 正确的写法应该是 CDATA 或者 转义字符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAccount&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.eoezora.mybatisDemo.pojo.EoeAccount&quot;</span>&gt;</span></span><br><span class="line">    SELECT *</span><br><span class="line">    FROM account</span><br><span class="line">    WHERE id</span><br><span class="line">    <span class="comment">&lt;!-- 把他也输符号写在CDATA 里就不会报错了 --&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">	 &lt;</span><br><span class="line">    ]]&gt; #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue备忘笔记</title>
    <url>/html/Vue%E5%A4%87%E5%BF%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="div设置水平居中"><a href="#div设置水平居中" class="headerlink" title="div设置水平居中"></a>div设置水平居中</h3><p>所有方法共用如下结构</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="通过设置margin"><a href="#通过设置margin" class="headerlink" title="通过设置margin"></a>通过设置margin</h4><p>需设置 <code>overflow: hidden</code> 且上下外边距为 <code>(父元素高度 - 子元素高度) / 2</code> </p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background-color</span>: brown;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="comment">/* 上下外边距为 (父元素高度 - 子元素高度) / 2 */</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">109</span>, <span class="number">255</span>, <span class="number">160</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="使用定位"><a href="#使用定位" class="headerlink" title="使用定位"></a>使用定位</h4><p>第一种</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: brown;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">109</span>, <span class="number">255</span>, <span class="number">160</span>);</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>第二种</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: brown;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">109</span>, <span class="number">255</span>, <span class="number">160</span>);</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>第三种</p>
<blockquote>
<p>当父子元素宽高度不确定时，建议使用这种</p>
</blockquote>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: brown;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">109</span>, <span class="number">255</span>, <span class="number">160</span>);</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="使用弹性盒子-Flex"><a href="#使用弹性盒子-Flex" class="headerlink" title="使用弹性盒子(Flex)"></a>使用弹性盒子(Flex)</h4><blockquote>
<p>当父子元素宽高度不确定时，建议使用这种</p>
</blockquote>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: brown;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">109</span>, <span class="number">255</span>, <span class="number">160</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="宽高不确定时"><a href="#宽高不确定时" class="headerlink" title="宽高不确定时"></a>宽高不确定时</h4><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个方法中，<code>.father</code> 容器被设置为表格布局(display: table)，并且设置了width: 100%以使其占满父容器的宽度。<code>.table-cell</code> 类被设置为表格单元格布局(display: table-cell)，同时设置了vertical-align: middle以使其在垂直方向上居中对齐，text-align: center 以使其在水平方向上居中对齐。</p>
<h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>盒子模型定义了一个元素在文档中所占据的空间和元素的各个部分（内容、内边距、边框和外边距）的组成关系。它可以把元素看作一个盒子，该盒子由四个部分组成：</p>
<ol>
<li>内容（Content）：盒子内部显示的实际内容，如文本、图像等。</li>
<li>内边距（Padding）：内容与边框之间的空白区域，用于控制内容与边框之间的距离。</li>
<li>外边距（Margin）：盒子与其他元素之间的空白区域，用于控制元素与相邻元素之间的距离。</li>
<li>边框（Border）：围绕内容和内边距的线条或边界，用于给元素提供可见的外观。</li>
</ol>
<p>在css中由以下几个属性来控制</p>
<ul>
<li>width 和 height 属性用于设置盒子的宽度和高度。</li>
<li>padding 属性用于设置内边距。</li>
<li>margin 属性用于设置外边距。</li>
<li>border 属性用于设置边框的样式、宽度和颜色。</li>
</ul>
<h3 id="六种布局方式"><a href="#六种布局方式" class="headerlink" title="六种布局方式"></a>六种布局方式</h3><ul>
<li>浮动布局（Float Layout）：通过将元素设置为浮动（float）来实现布局，使元素脱离正常的文档流并进行位置调整。浮动元素会向左或向右移动，其他内容会围绕其周围排列</li>
<li>流动布局（Flow Layout）：元素按照其在HTML文档中出现的顺序自上而下进行流动排列，如果空间不足则会自动换行。这是<mark style="background: #FF5582A6;">默认的布局方式</mark>，元素的宽度会自动适应父容器或内容的宽度。</li>
<li>弹性盒子布局（Flexbox Layout）：使用 CSS 弹性盒子布局模型（Flexbox）来实现灵活的、自适应的布局。通过设置容器的 display: flex 属性，可以对容器内的子元素进行弹性的排列、对齐和调整。</li>
<li>自适应布局：使用媒体查询，针对不同的屏幕尺寸有不同的css属性</li>
<li>响应式布局：结合流动布局与弹性布局，再配合媒体查询实现自适应桌面端与移动端。一般使用rem&#x2F;vh&#x2F;vm&#x2F;百分比</li>
<li>网格布局（Grid Layout）：使用 CSS 网格布局模型（Grid）来实现复杂的网格结构布局。通过将容器设置为网格布局（display: grid）并定义行和列，可以对子元素进行精确的定位和布局。</li>
</ul>
<h3 id="flex-1是什么意思"><a href="#flex-1是什么意思" class="headerlink" title="flex: 1是什么意思"></a>flex: 1是什么意思</h3><p>flex: 1等同于 flex:1 1 auto 表示空间有剩余则放大，不够则缩小。是flex-grow、flex-shrink、flex-basis三个属性的缩写（默认是 flex: 0 1 auto (空间不够不会方法缩小)）</p>
<ul>
<li>flex-grow属性<mark style="background: #FFB8EBA6;">指定了flex容器中剩余空间的多少应该被分配给项目</mark>。flex-grow设置的值为扩张因子，默认为0，剩余空间将会按照这个权重分别分配给子元素项目。</li>
<li>flex-shrink属性<mark style="background: #FFF3A3A6;">指定了flex元素的收缩规则</mark>。flex元素仅在默认宽度之和大于容器的时候才会发生收缩。默认属性值为1，所以在空间不够的时候，子项目将会自动缩小。</li>
<li>flex-basis属性<mark style="background: #FFB86CA6;">指定了flex元素在主轴方向上的初始大小</mark>。如果不使用box-sizing改变盒模型的话，那么这个属性就决定了flex元素的内容的尺寸。如果设置了flex-basis值，那么元素占用的空间为flex-basis值；如果<mark style="background: #ADCCFFA6;">没有设置或者设置为auto，那么元素占据的空间为元素的width&#x2F;height值。</mark></li>
</ul>
<h3 id="HTML5的新特性"><a href="#HTML5的新特性" class="headerlink" title="HTML5的新特性"></a>HTML5的新特性</h3><h4 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h4><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">等</span><br></pre></td></tr></table></figure></div>

<h4 id="增强表单"><a href="#增强表单" class="headerlink" title="增强表单"></a>增强表单</h4><p>Input新的输入类型 <code>color</code> <code>url</code> <code>date</code> 等</p>
<h4 id="新增媒体标签"><a href="#新增媒体标签" class="headerlink" title="新增媒体标签"></a>新增媒体标签</h4><p>新增视频 <code>&lt;video&gt;</code> 和音频标签 <code>&lt;audio&gt;</code><br>常用属性如下</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>autoplay</td>
<td>是否自动播放</td>
</tr>
<tr>
<td>controls</td>
<td>是否显示工具条</td>
</tr>
<tr>
<td>loop</td>
<td>是否循环</td>
</tr>
<tr>
<td>muted</td>
<td>是否静音</td>
</tr>
<tr>
<td>preload</td>
<td>是否预加载</td>
</tr>
</tbody></table>
<p>常用函数如下</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>play</td>
<td>播放</td>
</tr>
<tr>
<td>pause</td>
<td>暂停</td>
</tr>
<tr>
<td>reload</td>
<td>重播</td>
</tr>
</tbody></table>
<h4 id="Canvas绘图"><a href="#Canvas绘图" class="headerlink" title="Canvas绘图"></a>Canvas绘图</h4><p> CanvasAPI是HTML5吸能的标签。用于在实时生成图像，并且可以操控图像内容，是一个可以用js操控的位图</p>
<h3 id="获取地理位置"><a href="#获取地理位置" class="headerlink" title="获取地理位置"></a>获取地理位置</h3><p>判断是否支持获取地理位置</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&quot;geolocation&quot;</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  <span class="comment">// 浏览器支持 Geolocation API</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 浏览器不支持 Geolocation API</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>获取一次</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 getCurrentPosition 获取一次地理位置</span></span><br><span class="line">navigator.<span class="property">geolocation</span>.<span class="title function_">getCurrentPosition</span>(</span><br><span class="line">	<span class="function"><span class="params">ok</span> =&gt;</span> &#123; <span class="comment">//获取成功或用户同意获取</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(ok);</span><br><span class="line">	&#125;, </span><br><span class="line">	<span class="function"><span class="params">fail</span> =&gt;</span> &#123;<span class="comment">//获取失败或用户不允许获取</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(fail);</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>获取多次</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//会一直获取位置</span></span><br><span class="line">navigator.<span class="property">geolocation</span>.<span class="title function_">watchPosition</span>(<span class="function"><span class="params">ok</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(ok);</span><br><span class="line">&#125;, <span class="function"><span class="params">fail</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(fail);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>


<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h3><blockquote>
<p>在 JavaScript 中，每个对象都有一个原型（prototype），而原型又可以连接到另一个对象的原型，形成一个原型链（prototype chain）。原型和原型链是 JavaScript 中实现继承和共享属性的机制。<br>实例对象是new出来的那种，没有prototype属性，但是有 <mark style="background: #FFF3A3A6;"><strong>proto</strong></mark>  属性指向原型对象<br>而构造函数则拥有 prototype。请看下列例子</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span> (name) &#123;</span><br><span class="line">	<span class="attr">name</span>: name || <span class="string">&#x27;animal&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Animal是构造函数，拥有prototype属性，可以拓展属性或方法</span></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span>(<span class="params">food</span>) &#123;</span><br><span class="line">	<span class="title function_">log</span>(name, <span class="string">&quot;正在吃&quot;</span>, food)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是new出来的实例对象，有 __proto__ 但是没有 prototype</span></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;cat&quot;</span>)</span><br><span class="line"><span class="comment">// __proto__ 指向构造函数的原型对象</span></span><br><span class="line"><span class="title function_">log</span>(cat.<span class="property">__proto__</span> === <span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></div>

<h3 id="原型的继承"><a href="#原型的继承" class="headerlink" title="原型的继承"></a>原型的继承</h3><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><ul>
<li>优点： 代码简单明了</li>
<li>缺点：<ul>
<li>不支持多继承</li>
<li>无法传参给父类</li>
<li>来自原型的所有方法属性被所有实例对象(继承了Animal的实例对象)共享</li>
<li>拓展方法属性要在 <code>new Animal()</code> 后<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params"></span>)&#123; </span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;cat&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<h4 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h4><ul>
<li>优点： <ul>
<li>可以传参</li>
<li>可以多继承(多个call)</li>
</ul>
</li>
<li>缺点：<ul>
<li>无法继承原型上方法和属性</li>
<li>本质上并没有真正继承，只是把父类的属性方法复制过来而已</li>
<li>且每个子类都有父类实例函数的副本<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name || <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<h4 id="实例继承-x2F-拷贝继承"><a href="#实例继承-x2F-拷贝继承" class="headerlink" title="实例继承&#x2F;拷贝继承"></a>实例继承&#x2F;拷贝继承</h4><ul>
<li>缺点：<ul>
<li>返回的实例是父类，不是子类</li>
<li>不支持多继承<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> instance = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">  <span class="comment">//拓展父类后返回</span></span><br><span class="line">  instance.<span class="property">name</span> = name || <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><ul>
<li>优点：<ul>
<li>可以传参</li>
<li>可以复用</li>
<li>即是子类实例，也是父类实例</li>
<li>继承了父类属性方法和原型属性方法</li>
</ul>
</li>
<li>缺点：<ul>
<li>调用了两次构造函数<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="comment">//复制属性方法</span></span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name || <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 挂在原型为父类对象</span></span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="comment">// 重置构造函数</span></span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Cat</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<h4 id="寄生继承"><a href="#寄生继承" class="headerlink" title="寄生继承"></a>寄生继承</h4><blockquote>
<p>优点与组合击沉一样，但是使用寄生对象，去掉了父类属性方法的实例化</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name || <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个没有实例方法的类</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Super</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;;</span><br><span class="line"><span class="title class_">Super</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="comment">//将实例作为子类的原型</span></span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Super</span>();</span><br></pre></td></tr></table></figure></div>

<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><blockquote>
<p>AJAX是利用 JavaScript 和浏览器提供的 XMLHttpRequest 对象，在不刷新整个页面的情况下与服务器进行异步通信的技术，是<mark style="background: #BBFABBA6;">异步</mark>的</p>
</blockquote>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol>
<li>创建XMLHttpRequest对象,也就是创建一个异步调用对象. </li>
<li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</li>
<li>设置响应HTTP请求状态变化的函数.</li>
<li>发送HTTP请求 (send)</li>
<li>获取异步调用返回的数据.(onreadystatechange)</li>
<li>使用JavaScript和DOM实现局部刷新</li>
</ol>
<h2 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h2><ol>
<li>引入块级作用域和新的关键字<br> <code>let</code>：定义可变的变量，没有变量提升<br> <code>const</code>：定义不可变的常量，没有变量提升</li>
<li>箭头函数</li>
<li>变量结构赋值：<br> <code>const [a,b,c] = [1,2,3]</code><br> <code>const &#123;id, name, age&#125; = &#123;id:1,name:jack,age:18&#125;</code></li>
<li>扩展运算符：<code>[...arr] and &#123;...obj&#125;</code> 扩展运算符，可以展开迭代对象。可以将伪数组转成真数组，一层深拷贝</li>
<li>新增数据结构 <code>Set</code> <code>Map</code></li>
<li>引入类的概念</li>
<li>引入Promise对象，用于更方便地处理异步操作</li>
</ol>
<h2 id="HTTP事务流程"><a href="#HTTP事务流程" class="headerlink" title="HTTP事务流程"></a>HTTP事务流程</h2><blockquote>
<p>浏览器与服务器交互的一个过程，假设是用户在浏览器搜索为例</p>
</blockquote>
<ol>
<li>用户在搜索框输入，浏览器判断输入的是地址，还是搜索内容。如果是搜索内容，则用浏览器默认的搜索引擎拼接上搜索内容合成URL。如果是地址，则会自动加上协议</li>
<li>用户按下回车后，浏览器会将最终的URL通过IPC（进程通信）将传给网络进程。网络进程会先查找该URL是否有对应的缓存资源。有的话直接返回，没有再进入真正的网络请求</li>
<li>进入网络请求后，会先获取URL域名的真实IP地址。会先从本地hosts文件中获取，若该文件没有，则使用DNS解析获取</li>
<li>获取IP地址后，使用对应IP地址与目标服务器建立TCP连接</li>
<li>连接建立后，浏览器会构建数据包（请求行，请求头，请求正文，以及将COOKIE等数据添加到请求头中）。数据包建立后，向服务器发送请求</li>
<li>服务器接收到请求后，会根据请求信息构建响应数据（响应行，响应头，响应正文）。然后将响应数据发送回浏览器的网络进程</li>
<li>网络进程会对响应数据进行解析，如果发现响应行的状态码是301&#x2F;302，则会使用响应头中的Location字段。根据字段值（一个URL）重复上面的步骤再次发送一次请求去，另一个URL拿资源。如果状态码是200，则表示拿到数据了</li>
<li>浏览器很根据数据的Content-Type字段来决定数据的打开方式<ol>
<li>如果 Content-Type是text&#x2F;html，则表示是网页类型，浏览器会准备渲染</li>
<li>如果 Content-Type是application&#x2F;octet-stream等等类型，则该数据会被提交给下载管理器。让下载管理器去下载这个数据</li>
</ol>
</li>
<li>当响应数据是网页时，浏览器会把响应数据提交给渲染进程。渲染进程和网络基础进程会建立传输通道</li>
<li>当数据提交开始传输后，渲染进程就会开始渲染界面</li>
<li>数据传输完毕后，浏览器就会更新页面状态（地址信息，历史记录，安全状态等）</li>
<li>当页面渲染完毕后，渲染进程会通知浏览器。浏览器则会停止图标转动</li>
</ol>
<h2 id="强制缓存与协商缓存"><a href="#强制缓存与协商缓存" class="headerlink" title="强制缓存与协商缓存"></a>强制缓存与协商缓存</h2><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>服务器在响应资源时在响应头中添加相关的缓存规则，浏览器接收响应数据后很具响应头中的缓存规则去设置缓存<br><strong>常见的强制缓存响应头字段有</strong></p>
<ol>
<li>Expries： 表示缓存失效的时间，是一个具体的日期时间</li>
<li>Cache-Control：表示缓存行为，比如设置max-age&#x3D;0表示缓存0秒后过期</li>
</ol>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>浏览器与服务器进行一次通信，本次通信会带上缓存的相关信息交给服务器判断缓存是否有效。如果缓存还有效，则返回 304（Not Modified）状态码，表示缓存没过期可以用。若缓存过期了，服务器会把最新的资源返回给浏览器更新</p>
<p><strong>常用的协商缓存请求头和响应头字段</strong></p>
<ul>
<li>IF-MODIFIED-SINCE：表示请求时间</li>
<li>LAST-MODIFIED：表示资源最后的修改时间</li>
<li>IF-NONE-MATCH：表示缓存的标识符</li>
<li>ETAG：表示当前返回的资源标识符</li>
</ul>
<p>服务器在响应的时候告诉浏览器资源最后的修改日期。当缓存过期时，浏览器发现缓存有Last-Modified属性，则会向服务器发送请求，并带上If-Modified-Since表示当前的请求时间。<br>服务器收到请求后发现请求头有If-Modified-Since。则会将这个请求头与服务器资源最后的修改时间进行对比。若服务器资源修改时间大于请求时间，则返回304表示没修改，可以用缓存。若小于请求时间，则返回最新的资源</p>
<h3 id="怎么判断服务器资源是否更改？"><a href="#怎么判断服务器资源是否更改？" class="headerlink" title="怎么判断服务器资源是否更改？"></a>怎么判断服务器资源是否更改？</h3><p>可以在打包时给输出的文件名添加一个随机且唯一的值，让打包后的文件与缓存文件名不一致</p>
<h2 id="HTTP-x2F-HTTPS-x2F-WEBSOCKET的区别"><a href="#HTTP-x2F-HTTPS-x2F-WEBSOCKET的区别" class="headerlink" title="HTTP&#x2F;HTTPS&#x2F;WEBSOCKET的区别"></a>HTTP&#x2F;HTTPS&#x2F;WEBSOCKET的区别</h2><blockquote>
<p>HTTP协议、HTTPS协议和WebSocket协议是网络通信中常用的三种协议</p>
</blockquote>
<p><strong>HTTP协议（Hypertext Transfer Protocol）：</strong></p>
<ul>
<li>HTTP是一种基于客户端-服务器模型的协议，用于在Web浏览器和Web服务器之间传输超文本数据。</li>
<li>HTTP通信是无状态的，即每个请求-响应之间相互独立，服务器不会保留客户端的状态信息。</li>
<li>HTTP通信默认使用明文传输，安全性较低。</li>
<li>HTTP请求一般是短暂的，发送请求后即关闭连接。</li>
</ul>
<p><strong>HTTPS协议（HTTP Secure）：</strong></p>
<ul>
<li>HTTPS是在HTTP基础上加入了加密和身份验证机制的安全协议。</li>
<li>HTTPS使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议对数据进行加密传输，提供了对通信内容的保护，使数据传输更加安全。</li>
<li>HTTPS使用公钥证书对服务器进行身份验证，防止中间人攻击。</li>
<li>HTTPS使用的默认端口是443，而不是HTTP的默认端口80。</li>
</ul>
<p><strong>WebSocket协议：</strong></p>
<ul>
<li>WebSocket是一种全双工、长连接的协议，允许在一个单独的TCP连接上进行双向通信。</li>
<li>WebSocket在建立连接后，客户端和服务器之间可以直接发送消息，实现了实时的双向数据传输。</li>
<li>WebSocket协议通过HTTP的升级机制进行握手，建立连接后使用自定义的协议进行数据传输。</li>
<li>WebSocket连接是持久的，不会像HTTP请求一样在每次通信后关闭连接，因此适用于需要实时通信的应用，如在线聊天、实时推送等。</li>
</ul>
<p><strong>总结：</strong><br>HTTP协议是一种传输超文本数据的协议，无状态且安全性较低。HTTPS是在HTTP基础上加入了加密和身份验证机制的安全协议，提供了更高的安全性。WebSocket是一种全双工、长连接的协议，适用于实时通信场景。</p>
<h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><ol>
<li>解析获取到的HTML，生成DOM树，解析CSS，生成CSSOM树</li>
<li>将DOM树和CSSOM树进行结合，生成渲染树（render tree）</li>
<li>根据生成的渲染树，进行回流（Layout）,得到节点的几何信息（位置，大小）</li>
<li>重绘（Painting）：根据渲染树以及回流得到的几何信息，得到节点的绝对像素（像素，背景色，外观等）</li>
<li>Display将像素发送给GPU，展示在页面上。</li>
</ol>
<h3 id="回流（reflow）："><a href="#回流（reflow）：" class="headerlink" title="回流（reflow）："></a>回流（reflow）：</h3><p>回流是指浏览器根据DOM树和CSSOM树的变化，重新计算并确定元素的几何属性（如位置、大小、布局等），并确定它们在页面中的精确位置的过程。回流是一种相对较慢的操作，它会涉及整个渲染树的重新计算和布局。</p>
<h4 id="触发回流的操作包括"><a href="#触发回流的操作包括" class="headerlink" title="触发回流的操作包括"></a>触发回流的操作包括</h4><p>页面首次渲染<br>浏览器窗口大小改变<br>元素的尺寸、位置、内容等属性发生改变<br>添加或删除可见的DOM元素<br>修改CSS样式等</p>
<h3 id="重绘（repaint）："><a href="#重绘（repaint）：" class="headerlink" title="重绘（repaint）："></a>重绘（repaint）：</h3><p>重绘是指浏览器根据已计算好的布局信息，将元素绘制成像素的过程。重绘的操作是相对较快的，它只需要对已计算好的布局进行像素绘制，而不会重新计算元素的几何属性。</p>
<h4 id="触发重绘的操作包括"><a href="#触发重绘的操作包括" class="headerlink" title="触发重绘的操作包括"></a>触发重绘的操作包括</h4><p>元素的背景色、边框颜色等样式属性发生改变<br>元素的可见性、透明度等样式属性发生改变<br>滚动页面等<br>需要注意的是，回流和重绘是紧密相关的，回流必然会触发重绘。当触发了回流时，浏览器会重新计算布局，并将布局渲染成像素，然后进行重绘。因此，减少回流和重绘的次数可以提高页面的渲染性能。</p>
<h3 id="优化回流和重绘的方法"><a href="#优化回流和重绘的方法" class="headerlink" title="优化回流和重绘的方法"></a>优化回流和重绘的方法</h3><p>尽量使用CSS的transform和opacity等属性，而不是影响元素几何属性的属性。<br>避免使用table布局，因为它在布局上会比其他布局方式更复杂，触发回流的代价更高。<br>避免频繁地修改元素的样式属性，最好将样式的修改集中在一起进行，或者使用批量处理的方式。<br>使用虚拟DOM等技术，对多次修改进行合并和优化，减少不必要的回流和重绘。</p>
<h2 id="跨域的解决方案"><a href="#跨域的解决方案" class="headerlink" title="跨域的解决方案"></a>跨域的解决方案</h2><blockquote>
<p>跨域是指在浏览器中，当前网页的域名、协议、端口与请求的目标资源不一致，浏览器会限制页面中发起的跨域请求，以保障用户的安全。</p>
</blockquote>
<h3 id="常见的跨域场景"><a href="#常见的跨域场景" class="headerlink" title="常见的跨域场景"></a>常见的跨域场景</h3><ol>
<li>不同域名之间的跨域：例如从 example.com 的网页向 api.example.com 发起请求。</li>
<li>不同子域之间的跨域：例如从 <a class="link"   href="http://www.example.com/" >www.example.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 的网页向 api.example.com 发起请求。</li>
<li>不同协议之间的跨域：例如从 <a class="link"   href="http://example.com/" >http://example.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 的网页向 <a class="link"   href="https://example.com/" >https://example.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 发起请求。</li>
<li>不同端口之间的跨域：例如从 <a class="link"   href="http://example.com:3000/" >http://example.com:3000 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 的网页向 <a class="link"   href="http://example.com:8080/" >http://example.com:8080 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 发起请求。</li>
</ol>
<h3 id="常见的解决方案"><a href="#常见的解决方案" class="headerlink" title="常见的解决方案"></a>常见的解决方案</h3><ol>
<li><p>JSONP（JSON with Padding）：JSONP 是一种利用<code> &lt;script&gt;</code> 标签可以跨域加载资源的特性来实现跨域请求的方法。通过在请求的 URL 中添加回调函数名作为参数，服务器返回一个包含回调函数调用的 JavaScript 脚本，使得浏览器能够执行回调函数并获取数据。<br>优点：兼容性好，简单易用。<br>缺点：只支持 GET 请求，不安全，需要服务器端支持 JSONP。</p>
</li>
<li><p>CORS（Cross-Origin Resource Sharing）：CORS 是一种标准的跨域解决方案，通过在服务器端设置响应头来允许跨域请求。<br>优点：支持各种类型的 HTTP 请求，安全可靠。<br>缺点：需要服务器端的支持，在某些复杂的跨域请求场景下配置可能较复杂。</p>
</li>
<li><p>代理服务器：前端应用可以通过配置代理服务器来转发请求，将跨域请求转发到同源的接口上，然后再将结果返回给前端。<br>优点：<mark style="background: #FF5582A6;">适用于开发环境下的调试和开发</mark>，不需要浏览器的特殊设置。<br>缺点：增加了一层额外的服务器，部署和维护相对复杂。</p>
</li>
<li><p>WebSocket：WebSocket 是一种支持跨域通信的协议，可以在浏览器和服务器之间建立持久的、全双工的通信连接。</p>
</li>
</ol>
<p>优点：支持跨域通信，实时性好。<br>缺点：需要服务器端的支持，协议相对复杂。</p>
<h2 id="Vue的双向绑定原理"><a href="#Vue的双向绑定原理" class="headerlink" title="Vue的双向绑定原理"></a>Vue的双向绑定原理</h2><blockquote>
<p>Vue2使用Obejct.defineProperty()实现. Vue3使用ES6中的Proxy来实现</p>
</blockquote>
<p>vue的双向绑定是通过数据劫持 <code>Obejct.defineProperty()</code> 再结合发布订阅模式来实现的。每个组件实例都有对应的watcher实例对象。它会在组件渲染过程中把属性记录为依赖，之后当依赖的setter被调用时会通知watcher重新计算。从而使得它关联的组件更新<br>步骤如下:</p>
<ol>
<li>实现一个监听器Observer，对数据对象进行遍历，包括子属性对象的属性。利用 <code>Object.defineProperty()</code> 给每个属性都加上 setter 和 getter。当这个对象的属性被修改时，都会触发setter。就能监听到数据的变化</li>
<li>实现一个解析器 Compile：解析Vue模板的指令，将模板中的变量替换为数据。然后初始化渲染视图。并将每个指定对应的节点绑定更新函数。添加监听数据的订阅者。每当数据发生变化时就调用跟更新函数更新数据</li>
<li>实现一个订阅者Watcher：订阅者是监听器和解析器之间沟通的桥梁。主要作用是订阅Observer中属性变化的消息。当消息发生变化时触发解析器中的更新函数</li>
<li>实现一个订阅器Dep：订阅器使用发布-订阅模式，用来收集订阅者，对监听器和订阅者进行统一管理</li>
</ol>
<h3 id="vue修改数组或对象的值，页面不会发生变化的情况"><a href="#vue修改数组或对象的值，页面不会发生变化的情况" class="headerlink" title="vue修改数组或对象的值，页面不会发生变化的情况"></a>vue修改数组或对象的值，页面不会发生变化的情况</h3><ul>
<li>对象：vue无法检测属性的添加和移除</li>
<li>数组：vue无法检测利用索引直接设置一个数组项和直接修改数组长度<br><strong>对上述两种情况，Model层发生变化时，View并不会响应地作出修改。为了解决上述问题，Vue提供了如下方法</strong></li>
</ul>
<ol>
<li>对于数组，使用vue二次封装的变异方法 <ul>
<li>数组有push()、pop()、unshift()、splice()、sort()、reverse() filter()、concat()、slice()等</li>
<li>对象有Object.assign</li>
</ul>
</li>
<li>使用$set</li>
<li>使用$forceUpdate强制更新</li>
</ol>
<p><strong>$set的实现原理：</strong> 如果目标是数组，则使用数组splice方法触发响应式；如果目标是对象，会判断读属性是否存在、对象是否是响应式。最终使用defineReactive方法进行响应式处理(defineReactive是vue初始化对象时，给对象属性使用defineProperty动态添加setter和getter时所调用的方法)</p>
<p>以下为代码例子</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接修改数组长度，不会触发响应式更新</span></span><br><span class="line">vm.<span class="property">arr</span>.<span class="property">length</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接设置索引，不会触发响应式更新</span></span><br><span class="line">vm.<span class="property">arr</span>[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的方式是使用Vue提供的数组变异方法来修改数组</span></span><br><span class="line">vm.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="number">4</span>); <span class="comment">// 使用 push() 方法添加新元素</span></span><br><span class="line">vm.<span class="property">arr</span>.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>); <span class="comment">// 使用 splice() 方法替换元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><blockquote>
<p>虚拟DOM是一种用于提高Web应用性能的技术概念，最开始由React提出，后背许多前端框架采用。Vue就使用了该概念</p>
</blockquote>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在传统的前端开发中，当数据发生变化，我们需要操作真实DOM元素修改其内容属性。然后浏览器会重新计算整个页面的布局和渲染。这种操作真实DOM元素的方式如果遇到频繁更新的场景时会导致性能的下降</p>
<p>虚拟DOM是通过在JS中构建一个轻量级的虚拟DOM树来解决这个问题。虚拟DOM树是一个用JS对象表示的抽象层次结构，当数据发生变化时，会先在虚拟DOM中进行计算和对比，找出需要修改的部分，然后批量更新到实际真实DOM中，最小化了真实DOM的操作</p>
<p><strong>虚拟dom实现原理：用js模拟DOM结构（vnode），当数据发生变化时，生成新的vnode，然后新旧vnode对比，得出最小的变更范围，最后根据变更去更新真实DOM，在数据驱动视图的模式下，有效控制DOM操作。用到的算法：diff 算法 — 比较两棵虚拟 DOM 树的差异；pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</strong></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><strong>保证了性能下限：</strong> 虚拟DOM需要适配上层API可能产生的操作，一些DOM操作的实现是普适的。因为性能并不是最优的，但是比起手动操作DOM，性能还是要好很多。在不手动优化的前提下可以提供不错的性能<br><strong>无需手动操作DOM：</strong> 我们只需要写好ViewModel层的逻辑代码即可，Vue就会根据虚拟DOM和双向绑定帮助我们更新视图，大大提高了开发效率</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>无法进行极致的优化，虚拟DOM + 合理的优化可以应对绝大多数的需求。但对一些对性能要求极致的应用中，虚拟DOM无法提供针对性的性能优化</p>
<h2 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h2><p>M： Model 代表数据<br>V：View 代表试图<br>VM： 代表vue对象可以将M和V关联起来，VM不是特指Vue，而是Vue担任了这一角色<br>所谓的MVVM就是，通过VM层将M和V的数据进行双向绑定</p>
<h2 id="v-show和v-if的区别"><a href="#v-show和v-if的区别" class="headerlink" title="v-show和v-if的区别"></a>v-show和v-if的区别</h2><p>共同点：这两个指令都是控制元素的显示与隐藏<br>不同点：<br>    v-show是控制元素的css属性 <code>display:none</code> 来控制元素的显示与隐藏。只会编译一次<br>    v-if则是动态地向DOM树添加&#x2F;删除DOM元素来控制元素的显示与隐藏。若初始值为false则不会编译<br>如果元素需要频繁切换是否显示某节点，建议使用v-show，因为切换渲染开销较小。若元素不会频繁切换，则使用v-if。因为初始化开销较小</p>
<h2 id="常用的事件修饰符"><a href="#常用的事件修饰符" class="headerlink" title="常用的事件修饰符"></a>常用的事件修饰符</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">stop</span> 阻止冒泡； </span><br><span class="line">.<span class="property">prevent</span> 阻止默认事件；</span><br><span class="line">.<span class="property">capture</span> 事件捕获模式；</span><br><span class="line">.<span class="property">self</span>  点到自己才运行；</span><br><span class="line">.<span class="property">once</span> 只运行一次；</span><br><span class="line">.<span class="property">passive</span> 滚动事件的默认行为会立即触发；</span><br><span class="line">.<span class="property">lazy</span> 光标从input框移出才触发更新；</span><br><span class="line">.<span class="property">number</span> 变为数值类型；</span><br><span class="line">.<span class="property">trim</span> 去掉空格;</span><br><span class="line">.<span class="property">enter</span> .<span class="property">space</span>  .<span class="property">delete</span>; 按键修饰符  </span><br><span class="line">.<span class="property">native</span> 可以在自定义组件上绑定原生事件</span><br></pre></td></tr></table></figure></div>

<h2 id="计算属性computed和侦听器watch的区别"><a href="#计算属性computed和侦听器watch的区别" class="headerlink" title="计算属性computed和侦听器watch的区别"></a>计算属性computed和侦听器watch的区别</h2><ul>
<li>计算属性：有缓存，响应式；依赖项发生变化时，计算属性会重新调用。可以依赖多个值返回一个结果，不需要手动调用，且计算属性的名字不能和data中的变量名重复</li>
<li>侦听器：没有缓存，每次只能侦听一个值；一般情况下大数据量或异步操作时使用。一般能用计算属性就用计算属性；少用或不用侦听器</li>
<li>计算属性和普通函数的区别：计算属性有缓存，普通函数没有。计算属性不用手动调用，直接写函数名就行，普通函数需要调用。如果依赖项没有更改，则计算属性只会计算一次，而普通函数则每次都计算</li>
</ul>
<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><blockquote>
<p>vue的钩子函数指的是是&#x3D;在组件生命周期的不同阶段被调用的特殊函数</p>
</blockquote>
<p><strong>常用的钩子函数有如下几个:</strong></p>
<ul>
<li>beforeCreate: 组件实例被创建之前调用，此时组件的数据观测和事件机制尚未初始化。</li>
<li>created: 组件实例已经创建完成，可以访问组件的数据、方法和DOM元素，但此时尚未挂载到页面中。</li>
<li>beforeMount: 在组件挂载到页面之前调用，此时模板编译已完成，但尚未将组件的模板渲染为真实的DOM。</li>
<li>mounted: 组件已经挂载到页面上，此时可以访问到组件的DOM元素，也可以执行DOM操作或调用第三方库。</li>
<li>beforeUpdate: 组件更新之前调用，当组件的数据变化时会触发该钩子函数，此时尚未重新渲染DOM。</li>
<li>updated: 组件更新完成之后调用，DOM已经重新渲染，可以执行操作依赖于更新后的DOM的代码。</li>
<li>beforeDestroy: 组件销毁之前调用，可以执行一些清理操作，例如取消定时器、解绑事件等。</li>
<li>destroyed: 组件销毁之后调用，此时组件实例及其相关的DOM已经被完全销毁。</li>
</ul>
<h3 id="父子组件渲染时钩子函数触发顺序"><a href="#父子组件渲染时钩子函数触发顺序" class="headerlink" title="父子组件渲染时钩子函数触发顺序"></a>父子组件渲染时钩子函数触发顺序</h3><p><strong>其顺序为: 父 - beforeCreate -&gt; created -&gt; beforeMount -&gt; 子 - beforeCreate -&gt; created -&gt; beforeMount -&gt; Mounted -&gt; 父 - Mounted</strong><br>简单地说就是组件在挂载前会初始化所有子元素。等子元素挂载后，父元素才会挂载 </p>
<h2 id="vue的数据绑定是双向的，组件传参是单向的"><a href="#vue的数据绑定是双向的，组件传参是单向的" class="headerlink" title="vue的数据绑定是双向的，组件传参是单向的"></a>vue的数据绑定是双向的，组件传参是单向的</h2><p>vue的组件传参，只能是父组件通过props的形式传给子组件，且子组件对<mark style="background: #FFB86CA6;">props是只读的</mark>。这是为了防止更改子组件时导致父组件的值也被更改。<br><strong>可以使用子组件的本地变量和计算属性解决这个问题</strong>，如果传入的参数是一个对象。那么这个对象是可以修改的，但是不推荐修改。</p>
<h2 id="vue组件间的通信"><a href="#vue组件间的通信" class="headerlink" title="vue组件间的通信"></a>vue组件间的通信</h2><ul>
<li>props：父传子</li>
<li>emit：子传父</li>
<li>eventBus：兄弟组件通信，（emit，on，off）</li>
<li>vuex：任意组件间复杂数据的传输</li>
<li>$refs：获取真实DOM元素</li>
<li>provide和inject：跨级传输，可以从祖先传到后代</li>
<li>$root：获取根节点信息</li>
<li>$parent：获取父节点信息</li>
<li>$children：获取子节点信息</li>
<li>localStorage与sessionStorage：使用缓存传参</li>
<li>作用域插槽，将子组件的数据给父组件使用</li>
</ul>
<h2 id="组件缓存"><a href="#组件缓存" class="headerlink" title="组件缓存"></a>组件缓存</h2><p>可以使用 <code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code> 对一个不经常修改的组件进行缓存，避免重新渲染，保留一些信息，如上一次的搜索结果；保留滚动的位置等。<br>同时可以添加一些属性，来决定哪些组件被缓存，哪些不被缓存</p>
<ol>
<li>include：包含哪些组件（以组件名或组件注册名）</li>
<li>exclude：排除哪些组件（以组件名或组件注册名）</li>
<li>max：最大的缓存数量，当达到上限时，会清除那些最久没被访问的组件</li>
</ol>
<p>当使用缓存时组件的以下生命钩子会被触发</p>
<ul>
<li>activated：缓存组件进入时触发</li>
<li>deactivated：缓存组件离开时触发</li>
</ul>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><blockquote>
<p>插槽是一种机制，允许你在组件中设置一些占位符。当使用组件时，可以往组件中的这些占位符插入内容</p>
</blockquote>
<p>插槽可分为以下几种<br><strong>具名插槽</strong><br>具名插槽允许在组件中定义多个有名字的占位符。在使用组件时 通过插槽名字来决定要插入的内容</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span> <span class="comment">&lt;!--自定义的组件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--元素h1会被替换到 1 的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is the header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:content</span>&gt;</span>‘</span><br><span class="line">    <span class="comment">&lt;!--元素p会被替换到 2 的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is the content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--文本会被替换到 3 的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span>This is the footer<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>默认插槽</strong><br>当组件中的插槽没有设置名字时，vue会自动使用这个默认插槽</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">```html</span><br><span class="line"><span class="comment">&lt;!--定义--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span> <span class="comment">&lt;!--自定义的组件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is the header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>作用域插槽</strong><br>是一种高级插槽技术，允许子组件通过作用于插槽向父组件传递数据，如下所示</p>
<p><strong>父组件</strong></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component</span> <span class="attr">v-slot</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; slotProps.message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;slotProps.handleClick&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>子组件</strong></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:message</span>=<span class="string">&quot;message&quot;</span> <span class="attr">:handleClick</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="v-html会出现的问题"><a href="#v-html会出现的问题" class="headerlink" title="v-html会出现的问题"></a>v-html会出现的问题</h2><blockquote>
<p>强烈不推荐使用 v-html， 在站点上动态渲染 html很容易受到 xss 攻击</p>
</blockquote>
<p>v-html可以将提供的内容作为普通html 插入到 innerHTML中，这很容易导致XSS攻击。<br>v-html只会将内容以html插入，所以vue模板中的插值表达式是无法编译的<br>v-html中带作用域的css不会被应用</p>
<h2 id="v-if和v-for的优先级"><a href="#v-if和v-for的优先级" class="headerlink" title="v-if和v-for的优先级"></a>v-if和v-for的优先级</h2><p>在Vue2中，v-for优先级高于v-if<br>在vue3中，v-if优先级高于v-for<br>在vue中，永远不要在同一个元素中使用这两个指令，因为会造成性能浪费（每次渲染都会先循环再判断）。可以在外层嵌套一层 <code>&lt;template&gt;</code> （template不会生成dom节点）。如下</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--绝对不要这么做--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这么做会先把内容渲染出来，然后在执行v-if判断，发现为false，会把渲染好的元素删掉--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--等于是白渲染了，浪费了系统资源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 元素内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--强烈建议下面这种--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--外层判断为false，不渲染。v-for不会执行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 元素内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="Vue组件的data为什么是函数而不是对象"><a href="#Vue组件的data为什么是函数而不是对象" class="headerlink" title="Vue组件的data为什么是函数而不是对象"></a>Vue组件的data为什么是函数而不是对象</h2><p>因为Vue的组件是用来复用的，且JS的对象是引用关系，如果组件中的data是一个对象，那么这样作用没有隔离，子组件中的data属性就会互相影响<br>而如果组件中的data是一个函数，那么每一个组件实例都可以维护并返回一份对象的独立拷贝，这样组件间的data就不会互相影响</p>
<h2 id="watch和watchEffect的区别"><a href="#watch和watchEffect的区别" class="headerlink" title="watch和watchEffect的区别"></a>watch和watchEffect的区别</h2><ul>
<li>watch需要接受两个参数，要监听的响应式数据和回调函数，可选第三个配置选项。初始化时不会立刻执行，要等监听的数据变了才会被调用，可以获取修改前的值。会返回一个停止函数，需要手动在组件卸载时调用该函数停止监听</li>
<li>watchEffect不需要手动传入依赖，会先执行一次用来自动收集依赖，无法获取变化前的值，只能获取变化后的值，会在组件卸载时自动停止</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 watch 监听 count 的变化</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> state.<span class="property">count</span>, <span class="function">(<span class="params">newCount, oldCount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Count changed from <span class="subst">$&#123;oldCount&#125;</span> to <span class="subst">$&#123;newCount&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 watchEffect 自动追踪 count 的变化</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Count in watchEffect:&#x27;</span>, state.<span class="property">count</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<h2 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h2><ol>
<li>安装 vue-router</li>
<li>创建编写组件页面</li>
<li>配置路由表（router.js）</li>
<li>创建路由对象（new VueRouter）</li>
<li>注册路由</li>
<li>设置路由出口 router-view</li>
<li>设置路由连接 router-link</li>
</ol>
<p>路由表中有如下属性</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">//路由路径, 支持一些表达式，具体看官方文档</span></span><br><span class="line">	<span class="attr">path</span>: <span class="string">&#x27;/test&#x27;</span>,</span><br><span class="line">	<span class="comment">// 目标路由组件</span></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/TestView.vue&#x27;</span>),</span><br><span class="line">    <span class="comment">//路由元信息</span></span><br><span class="line">    <span class="attr">meta</span>: &#123;</span><br><span class="line">	  <span class="comment">// 可以在这里添加自定义字段，可在路由守卫访问得到</span></span><br><span class="line">	  <span class="comment">// 例如这里添加了一个授权验证，表示该路由需要登录才能访问。然后在路由守卫进行判断</span></span><br><span class="line">      <span class="attr">authorization</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 配置子路由，结构一样</span></span><br><span class="line">    <span class="attr">children</span>:[],</span><br><span class="line">    <span class="attr">redirect</span>:<span class="string">&#x27;路由路径&#x27;</span>, <span class="comment">//路由重定向</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></div>

<h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><ol>
<li><p>路径参数<br>在配置路由时，我们可以在路由路径上设置占位符来传递参数，以<code>:</code> 开头，后面跟参数名<br>参数跟在URL后面，刷新页面，参数还存在</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test/1/jack</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">path</span>: <span class="string">&#x27;/test/:id/:name&#x27;</span>,</span><br><span class="line">	<span class="comment">//...其他配置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取参数，注意，这里得id，name要与占位符名字一样</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>.<span class="property">id</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>.<span class="property">name</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>查询参数<br>在路由的查询字符串中传递参数。在导航链接或编程式导航中，使用 query 参数来指定查询参数的键值对。在组件中通过 $route.query 访问参数值。<br><strong>会以 ? 开头，参数跟值以键值对形式拼接在URL后面，刷新页面，参数还在</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test?id=1&amp;name=jack</span></span><br><span class="line"><span class="comment">// 导航链接</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; path: &#x27;/test&#x27;, query: &#123; id: 1, name: &#x27;jack&#x27; &#125; &#125;&quot;</span>&gt;<span class="title class_">User</span>&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编程式导航</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/test&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件中获取参数值</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">id</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">name</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>命名路由参数<br>当使用命名路由时，可以通过 params 参数传递参数。在导航链接或编程式导航中，使用 params 参数来指定命名路由参数的键值对。在组件中通过 $route.params 访问参数值<br><strong>需要注意的是，参数没有在URL后面，刷新页面，参数就没了</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由定义</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/test&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">TestView</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导航链接</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; name: &#x27;test&#x27;, params: &#123; id: 1, name: &#x27;jack&#x27; &#125; &#125;&quot;</span>&gt;<span class="title class_">Test</span>&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编程式导航</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件中获取参数值</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>.<span class="property">id</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>.<span class="property">name</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><blockquote>
<p>路由懒加载（Route Lazy Loading）是一种优化技术，用于在需要时按需加载路由组件，而不是在应用程序启动时加载所有路由组件。这可以提高应用程序的初始加载性能，并减少不必要的资源占用。</p>
</blockquote>
<p><strong>(使用import) 这种方式的懒加载是已经在 webpack中设置好的，是vue官网推荐的</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, </span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>, </span><br><span class="line">	<span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/home.vue&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>异步加载   resolve   require</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;@/components/home&#x27;</span>],resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>webpack提供的require.ensure()</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>: <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.<span class="title function_">ensure</span>([], <span class="function">() =&gt;</span> <span class="title function_">r</span>(<span class="built_in">require</span>(<span class="string">&#x27;@/components/home&#x27;</span>)), <span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="router-和-route的区别"><a href="#router-和-route的区别" class="headerlink" title="$router 和 $route的区别"></a>$router 和 $route的区别</h3><p>$route 当前页路径 ，常用属性： path 、params、query、name<br>$router 项目的所有路由路径，常用属性：options.routes 是个数组<br>常用函数：push() 跳转到某一页,go()返回上一页</p>
<h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><p>路由守卫分为三大类</p>
<ul>
<li>全局守卫：<mark style="background: #FF5582A6;"> 全局前置守卫 beforeEach</mark>、全局后置钩子afterEach、全局解析守卫beforeResolve </li>
<li>路由独享守卫：beforeEnter</li>
<li>组件级守卫：进入组件的守卫beforeRouteEnter、离开组件的守卫beforeRouteLeave、组件更新时的守卫beforeRouteUpdate</li>
</ul>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><blockquote>
<p>Vuex是Vue.js官方推荐的状态管理库，用于管理Vue.js应用程序中的共享状态。它提供了一个集中式的状态存储，并通过一系列规则确保状态的一致性和可维护性。Vuex可以帮助我们更好地组织和管理应用程序的数据流，使得状态的变化可追踪、可预测，并支持高效的状态更新。</p>
</blockquote>
<p>Vuex可以将项目中需要跨组件传输的数据统一管理在Vuex的store中；例如购物车，用户信息，登录状态等；</p>
<h3 id="5大核心概念"><a href="#5大核心概念" class="headerlink" title="5大核心概念"></a>5大核心概念</h3><p>State（状态）：<br>State是应用程序中的共享数据源，类似于组件中的data。但是，与组件的data不同，State的数据可以在整个应用程序中共享和访问。</p>
<p>Getters（获取器）：<br>Getters用于从State中派生出一些状态，类似于组件中的计算属性。可以在Getters中对State进行处理，使得数据获取更加灵活和高效。</p>
<p>Mutations（突变）：<br>Mutations是用于修改State的方法，类似于事件。每个Mutation都有一个字符串的类型和一个回调函数，用于实际的状态修改操作。<mark style="background: #FFB86CA6;">Mutations必须是同步函数</mark>，用于确保状态变更的可追踪性。</p>
<p>Actions（动作）：<br>Actions用于处理异步操作或批量的突变操作。Actions是通过触发Mutations来改变State的，<mark style="background: #BBFABBA6;">可以包含任意异步操作</mark>，如API请求、延迟调用等。Actions也可以触发其他Actions。</p>
<p>Modules（模块）：<br>Modules允许将Vuex状态树进行模块化拆分，使得大型应用程序可以更好地组织和管理状态。每个模块都拥有自己的State、Getters、Mutations和Actions，可以相互嵌套和组合。</p>
<h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ol>
<li>在组件中触发动作，使用 dispatch 发送动作 到 actions</li>
<li>在 动作actions 中 commit 提交一个状态到 mutations</li>
<li>在 mutations 中 修改 state状态值</li>
<li>当state的状态值发生变化时，会通知render 重新渲染页面</li>
<li>在mutations 中可以调用 devtools</li>
<li>在 actions中可以异步调用 后台api</li>
</ol>
<h3 id="和全局对象的区别"><a href="#和全局对象的区别" class="headerlink" title="和全局对象的区别"></a>和全局对象的区别</h3><p>Vuex的State是响应式的。当组件使用了Vuex的state时；若state发生了改变，那么相对应的组件的state也会得到更新。<br>不要直接更改state，而是通过 <code>commit</code> 的方式显式触发 mutation，在mutation里更改state值。这样方便追踪state的变化，同时也利于代码解耦。</p>
<h3 id="映射辅助函数"><a href="#映射辅助函数" class="headerlink" title="映射辅助函数"></a>映射辅助函数</h3><p>在使用Vuex时会遇到如下场景</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app 时模块名， count是app的state</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">app</span>.<span class="property">count</span></span><br></pre></td></tr></table></figure></div>

<p>会发现，这么一大串代码太长了，于是Vuex提供了映射辅助函数来简化</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">	<span class="comment">// count为state属性</span></span><br><span class="line">    ...<span class="title function_">mapState</span>([<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		&#123;&#123;count&#125;&#125; //使用时只需要打对应属性名即可</span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></div>
<p>同样的除了State外，Getters、Mutations和Actions也有对应的映射函数，<mark style="background: #FFB86CA6;">全都需要展开</mark><br><code>mapState</code> <code>mapGetters</code> <code>mapMutations</code> <code>mapActions</code></p>
<h3 id="和缓存localStorage的区别"><a href="#和缓存localStorage的区别" class="headerlink" title="和缓存localStorage的区别"></a>和缓存localStorage的区别</h3><ul>
<li>vuex是响应式的，我们更改state，有用到该state的地方会自动更新，而localStorage不是响应式的，需要手动更新</li>
<li>vuex不是持久化的，页面刷新会重置state，localStorage是持久化的，页面刷新不会重置数据</li>
</ul>
<h3 id="Vuex中的异步操作"><a href="#Vuex中的异步操作" class="headerlink" title="Vuex中的异步操作"></a>Vuex中的异步操作</h3><p><strong>在Mutation中可以做异步操作，但是强烈不推荐，因为违背Vuex的设计理念，以及<mark style="background: #ABF7F7A6;">异步操作的state无法被检测到</mark>。若需要在vuex中做异步操作，请使用Action。<br>在Action中 异步 <code>commit</code> mutation，然后mutation做同步更改</strong></p>
<h3 id="Vuex的持久化"><a href="#Vuex的持久化" class="headerlink" title="Vuex的持久化"></a>Vuex的持久化</h3><p>Vuex本身是不支持持久化的，页面关闭或刷新数据就会重置。一般会使用插件 来进行持久化 。当然也可以手动设置localStorage。但推荐用插件，简单又方便</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装插件</span></span><br><span class="line">npm install vuex-persistedstate --save</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> createPersistedState <span class="keyword">from</span> <span class="string">&quot;vuex-persistedstate&quot;</span></span><br><span class="line">conststore =newVuex.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="comment">// ...其他配置</span></span><br><span class="line">  <span class="comment">// 引入插件</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">	  <span class="title function_">createPersistedState</span>(&#123;</span><br><span class="line">		  <span class="comment">// 配置</span></span><br><span class="line">		  <span class="attr">paths</span>:[<span class="string">&#x27;state属性名&#x27;</span>]</span><br><span class="line">	  &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p>插件也提供了一些配置，可根据需要进行配置</p>
<ul>
<li>key：指定存储的键名，默认为vuex</li>
<li>storage：指定存储引擎，默认为localStorage</li>
<li>paths：指定需要持久化的状态路径，默认为全部状态</li>
<li>reducer：一个函数，用于自定义状态的持久化逻辑</li>
<li>filter：一个函数，用于过滤需要持久化的状态</li>
</ul>
<h2 id="Vue项目优化"><a href="#Vue项目优化" class="headerlink" title="Vue项目优化"></a>Vue项目优化</h2><ol>
<li>组件卸载前进行资源回收，例如：事件解除绑定；定时器停止；闭包清理；</li>
<li>对于不显示在视图上的数据，不建议定义在data里，可定义成自由数据。因为data里的数据是双向绑定的，每次数据读写，都要维护双向绑定表，所以data里的数据越少越好。</li>
<li>长列表的优化：可以用 <code>onScroll</code> 判断列表是否到底了，到底就获取新数据追加到列表中，而不是一下子就加载全部数据</li>
<li>对于 <code>onScroll</code> 事件需做防抖节流处理</li>
<li>对于图片可以使用懒加载（vue-lazyload）</li>
<li>路由需要使用懒加载，在路由表中配置。在打包后会减少首页加载时间</li>
<li>使用组件库或插件时按需引入</li>
<li>对重复的模板代码封装成组件，提高复用性</li>
<li>对data，computed等重复部分，封装成mixin（vue3为compositionAPI）自定义钩子函数</li>
<li>如果兄弟组件，或者不同级组件之间需频繁共享数据，可以使用Vuex进行统一管理。</li>
<li>对axios进行封装，设置baseURL，请求头，过期时间等。比如说，请求量拦截器中配置token信息。每次向服务器请求数据都带上token进项权限验证，可防止恶意越权的请求到达服务器。也可以在响应拦截器中对响应进行处理。进行统一的成功或失败操作</li>
<li>将服务器接口统一封装，方便管理维护</li>
</ol>
<h2 id="Vue打包优化"><a href="#Vue打包优化" class="headerlink" title="Vue打包优化"></a>Vue打包优化</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">publicPath</span>: <span class="string">&#x27;./&#x27;</span>,  <span class="comment">//项目打包时使用的，表示根目录，避免一些错误</span></span><br><span class="line"><span class="attr">outputDir</span>: <span class="string">&quot;输出路径&quot;</span>,<span class="comment">//打包后代码的输出文件夹名称</span></span><br><span class="line"><span class="comment">// eslint-loader 是否在保存的时候检查，生产环境下不检查语法  性能会更优</span></span><br><span class="line"><span class="attr">lintOnSave</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line"><span class="comment">// 生产环境是否生成 sourceMap 文件, 显示源文件错误在第几行，有利于调试;false 优化性能</span></span><br><span class="line"><span class="attr">productionSourceMap</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>, </span><br><span class="line"><span class="comment">//可以看到打包后每个文件的内容的大小</span></span><br><span class="line">webpack-bundle-analyzer</span><br><span class="line"><span class="comment">//路由懒加载在router.js文件中，原来的静态引用方式</span></span><br><span class="line"><span class="comment">//安装compression-webpack-plugin ，可以进行 gzip压缩</span></span><br><span class="line"><span class="comment">//使用uglifyjs-webpack-plugin插件去除console.log打印以及注释</span></span><br><span class="line"><span class="comment">//chunk-vendors.js 体积过大时，对 他单独打包</span></span><br><span class="line"><span class="comment">//当我们运行项目并且打包的时候，会发现chunk-vendors.js这个文件非常大，那是因为webpack将所有的依赖全都压缩到了这个文件里面，这时我们可以将其拆分，将所有的依赖都打包成单独的js。</span></span><br></pre></td></tr></table></figure></div>

<h2 id="Vue项目环境设置"><a href="#Vue项目环境设置" class="headerlink" title="Vue项目环境设置"></a>Vue项目环境设置</h2><p>环境配置，可以在不更改代码的情况下，根据输入的相关指令去访问不用环境下的不同api接口，方便代码的调试。可以在本地模拟运行在服务器环境下的代码效果。<br>在项目根目录创建生产环境、开发环境、测试环境的配置文件。将相关配置文件添加到根节点，其中每个配置文件名分别是</p>
<ul>
<li><code>.env.development</code></li>
<li><code>.env.production</code></li>
<li><code>.env.test</code><br>我们可以在这三个文件里添加不同的代码，例如<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">NODE_ENV</span> = <span class="string">&quot;development&quot;</span></span><br><span class="line"><span class="variable constant_">VUE_APP_API_URL</span>=<span class="string">&quot;http://127.0.0.1:8080&quot;</span></span><br><span class="line"><span class="comment">// 其他配置</span></span><br></pre></td></tr></table></figure></div>
这些配置可以通过 <code>process.env</code> 访问到，例如 <code>process.env.VUE_APP_API_URL</code> 获取服务器接口地址<br>可以使用如下命令启动不同的环境<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在package.json文件中</span></span><br><span class="line"><span class="attr">&quot;production&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-cli-service serve --mode production&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-cli-service serve --mode test&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="Vue开发时的项目规范"><a href="#Vue开发时的项目规范" class="headerlink" title="Vue开发时的项目规范"></a>Vue开发时的项目规范</h2><ol>
<li>封装服务器API，统一使用API发送请求</li>
<li>Vuex的Mutation统一使用SET_XXX</li>
<li>action统一大写，创建统一常量.js 文件进行统一管理</li>
<li>删除操作要有确认框</li>
<li>提交请求要使用POST方法</li>
<li>请求必须添加token</li>
</ol>
<h2 id="VueSSR"><a href="#VueSSR" class="headerlink" title="VueSSR"></a>VueSSR</h2><p>Vue是构建Web客户端应用程序的框架，默认情况下，可以在浏览器中构建vue组件，生成DOM和DOM操作。<br>而SSR指得是服务端渲染，它在服务端将Vue组件进行构建，然后将构建好的HTML内容返回给浏览器</p>
<p>SSR的工作流程如下：</p>
<ol>
<li>服务器接收到请求。</li>
<li>服务器创建一个Vue实例，并根据请求的URL路由和参数等上下文信息，获取需要渲染的组件及其对应的数据。</li>
<li>在服务器上执行组件的生命周期钩子函数，获取组件的状态和数据。</li>
<li>生成一个虚拟DOM，并使用组件的状态和数据进行渲染。</li>
<li>将最终渲染得到的HTML内容返回给客户端。</li>
<li>客户端接收到HTML内容，并激活其中的Vue实例，实现后续的交互和动态更新。</li>
</ol>
<p><strong>优势:</strong></p>
<ol>
<li>更好的SEO：搜索引起只会爬取和渲染静态的HTML内容，SSR可以将HTML直接提供给搜索引擎，有助于提升在搜索引擎的结果排名</li>
<li>更好的首次渲染：因为是直接返回HTML，所以第一次渲染会更快</li>
</ol>
<h2 id="Vue3-的双向绑定原理变化"><a href="#Vue3-的双向绑定原理变化" class="headerlink" title="Vue3 的双向绑定原理变化"></a>Vue3 的双向绑定原理变化</h2><p>在Vue2中，双向绑定是基于 <code>Object.defineProperty</code> 来进行数据的劫持。<br>而Vue3则是使用 ES6的新对象I <code>Proxy</code> 实现的。两者的区别在于 <code>Object.defineProperty</code> 有比较多的限制；比如：响应化过程需要遍历对象的data，消耗较大，不支持Set&#x2F;Map、class、数组等类型；对于新增或删除的属性无法监听，需要使用Vue提供的变异方法。<br>Vue3使用的Proxy可以直接监听对象，而不是属性，且可以监听数组的变化（包括索引修改）。<br>在初始化时不需要遍历对象，减少了开销，可以监控到成员的增加和删除。<br>Proxy返回的是一个新对象，我们可以操作新对象来达到目的。<br>同时Proxy拥有13种拦截的方法，包括但不限于：apply，ownKey，deleteProperty，has等 <code>Object.defineProperty</code> 所不具备的</p>
<h2 id="Vue3的新特性、亮点和变化"><a href="#Vue3的新特性、亮点和变化" class="headerlink" title="Vue3的新特性、亮点和变化"></a>Vue3的新特性、亮点和变化</h2><p>vue3.0比vue2.0快1.2~2倍 ，3.0 比2.0 更小体积更小，是2.0 的一半；<br>为什么vue3的速度更快了？</p>
<ol>
<li>diff算法优化了，vue2中虚拟dom是全量对比，vue3中新增了静态标识位，与上次节点对比时只对比带有标识位的节点；vue2中无论元素是否更新每次都会重新创建；vue3中对于不参与更新的元素，只会被创建一次，之后每次只调用就可以了；vue3的事件侦听开了缓存；</li>
<li>vue3按需加载，体积比vue2更小</li>
<li>vue3使用了CompositionAPI 组合api，</li>
<li>vue3更好的支持了ts</li>
<li>vue3暴露了自定义的渲染api<br>6 . vue3中添加了更先进的组件，如Fragment(即根节点可以添加多个标签)，Telport传送门(为了使用弹窗组件时减少div层级)，suspense 用于异步组件</li>
<li>生命周期钩子函数进行更改</li>
<li>Vue3中可以写自定义hook</li>
</ol>
<h3 id="模板变化"><a href="#模板变化" class="headerlink" title="模板变化"></a>模板变化</h3><ol>
<li>新增自动分段（Fragment）：在vue2中模板中只能由一个根节点，而在Vue3中，当出现多个根节点时，会自动使用 Fragment 将这个根节点包裹</li>
<li>改了作用域插槽，Vue2的机制会导致当作用域插槽变了，父组件重新渲染。而Vue3中将作用域插槽改成了函数的方式，这样只会影响子元件的重新渲染，提高了性能</li>
</ol>
<h3 id="v-model的变化"><a href="#v-model的变化" class="headerlink" title="v-model的变化"></a>v-model的变化</h3><ul>
<li>在自定义组件上使用v-model时，属性和事件的默认名称变了</li>
<li>v-bind的 sync修饰符在Vue3中被移除了，合并到了v-model中</li>
<li>同一组件可以同时设置多个v-model</li>
<li>可以自定义v-model的修饰符</li>
</ul>
<h3 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h3><blockquote>
<p>组合式 API 是 Vue 3 中引入的一种新的编写组件逻辑的方式。它提供了一组函数式的 API，使得组件逻辑可以更好地组织、复用和测试。</p>
</blockquote>
<p>下面是一些常用的组合式 API：</p>
<p>setup：setup 函数是组合式 API 的入口点。它<mark style="background: #FFB86CA6;">在组件创建阶段被调用</mark>，用于设置组件的初始状态和行为。setup 函数接收两个参数：props 和 context。props 是组件接收的属性，context 包含了一些组件实例上的方法和属性，如 attrs、slots、emit 等。setup 函数可以返回一个对象，将其中的数据和方法暴露给模板使用，也可以返回一个渲染函数。</p>
<p>ref：ref 函数用于创建一个响应式的数据引用。它接收一个初始值作为参数，并返回一个包装了该值的响应式对象。通过 ref 创建的响应式数据需要使用 .value 进行访问。</p>
<p>reactive：reactive 函数用于创建一个响应式的数据对象。它接收一个普通对象作为参数，并返回一个包装了该对象的响应式代理对象。通过 reactive 创建的响应式数据可以直接访问对象的属性。</p>
<p>computed：computed 函数用于创建一个计算属性。它接收一个计算函数作为参数，并返回一个计算属性的响应式引用。计算函数可以依赖于其他响应式数据，当依赖的数据发生变化时，计算属性会重新计算。</p>
<p>watch：watch 函数用于监听响应式数据的变化。它接收一个依赖值或一个依赖值的数组，以及一个回调函数。当依赖值发生变化时，回调函数会被触发。watch 还可以接收第三个参数作为配置选项，用于控制监听的行为。</p>
<p>watchEffect：watchEffect 函数用于创建一个副作用函数，它会自动追踪其中使用的响应式数据，并在数据变化时重新运行。与 watch 不同，watchEffect 不需要显式指定依赖，它会自动追踪。</p>
<p>toRefs：toRefs 函数用于将响应式对象转换为由响应式引用组成的普通对象。这样做可以确保在解构对象时，每个属性都保持响应式。</p>
<p>除此之外，我们还可以使用组合式API，将重复的代码抽出来封装成自定义钩子函数，如下所示</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useCounter</span>(<span class="params">initialValue, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">ref</span>(initialValue);</span><br><span class="line">  <span class="keyword">let</span> timerId;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">start</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    timerId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      count.<span class="property">value</span>++;</span><br><span class="line">    &#125;, interval);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">stop</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(timerId);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">start</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">stop</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count,</span><br><span class="line">    start,</span><br><span class="line">    stop</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用 </span></span><br><span class="line"><span class="keyword">const</span> &#123; count, start, stop &#125; = <span class="title function_">useCounter</span>(<span class="number">0</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="nextTick的使用"><a href="#nextTick的使用" class="headerlink" title="$nextTick的使用"></a>$nextTick的使用</h2><blockquote>
<p>$nextTick所指定的回调会在浏览器完成DOM更新后再执行</p>
</blockquote>
<p>当修改了一个响应式数据后马上获取其值，是获取不到更新后的值的。需要使用 $nextTick ，让获取修改后的数据的操作等DOM更新后再执行，这样才能获取成功，而 $nextTick 是异步操作，数据变化时，页面也会跟着同步</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>在生命周期函数 <code>Created()</code> 中进行DOM操作，一定要将这些的代码放到 $nextTick 中</li>
<li>数据发生变化后要进行某个操作，而这个操作需要根据数据的变化而去改变DOM时，也要在 $nextTick 中进行操作</li>
</ol>
<h2 id="Vue初始化页面闪动问题"><a href="#Vue初始化页面闪动问题" class="headerlink" title="Vue初始化页面闪动问题"></a>Vue初始化页面闪动问题</h2><p>使用Vue开发时，在Vue初始化前，元素是不归Vue管的，所以在Vue起作用前，页面上会出现 类似 <code>&#123;&#123; message &#125;&#125;</code> 的字样，这是Vue的插值表达式，因为Vue还没初始化，所以无法将其替换成真正的数据。虽然这种情况一般是很短暂的，但还是有必要解决</p>
<p>可以使用内置指令 <code>v-cloak</code> ，隐藏尚未完成编译的 DOM 模板</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[v-cloak]</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* or  */</span></span><br><span class="line">&lt;<span class="selector-tag">div</span> v-cloak&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure></div>

<p>如果使用上面的方法后，还是 会出现闪动问题，那么可以在根节点上添加如下内容</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;display: &#x27;block&#x27;&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="Vue框架的优点"><a href="#Vue框架的优点" class="headerlink" title="Vue框架的优点"></a>Vue框架的优点</h2><p>轻量级框架：只关注视图层，是一个构建视数据的视图集合，大小只有几十kb，有很好的中文文档<br>双向数据绑定：在数据操作方面更为简单<br>组件化：实现了html的封装和重用，在构建单页面应用有独特的优势<br>数据，结构，数据分离：使数据更改更简单，不需要进行逻辑代码的修改<br>虚拟DOM：使用js对象模拟真实DOM，最小化真实DOM的操作</p>
<h2 id="项目中做过的复杂编写"><a href="#项目中做过的复杂编写" class="headerlink" title="项目中做过的复杂编写"></a>项目中做过的复杂编写</h2><p>从详情页返回列表时保存浏览位置</p>
<ol>
<li>用到了 <code>keep-alive</code> 来缓存组件，而不是每次都创建新的列表实例，从而达到保存浏览位置的效果</li>
<li>使用路由守卫，在离开列表前，通过（beforeRouteLeave）记录并保存列表信息（使用vuex做持久化），当返回列表时，根据保存的列表信息恢复列表状态</li>
</ol>
<p>登录流程<br>设置axios拦截器，在拦截器中判断token是否存在，然后根据路由表进行权限的判断。若访问合法则放行，不合法则重定向到对应页面</p>
<p>代码复用<br>将重复的代码进行抽取封装成钩子函数，提高了代码的复用性，减少了代码耦合，同时也易于维护</p>
<p>全局状态统一管理<br>使用Vuex去统一管理项目状态数据，比如用户信息，用户的个性化设置，从服务器获取的异步数据，各个功能模块产生的数据</p>
]]></content>
      <categories>
        <category>note</category>
        <category>html</category>
        <category>js</category>
        <category>css</category>
        <category>react</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>html</tag>
        <tag>css</tag>
        <tag>js</tag>
        <tag>react</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-MyBatis配置文件</title>
    <url>/myBatis/Mybatis-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><strong>简介</strong></p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-MyBatis快速入门笔记</title>
    <url>/myBatis/Mybatis/</url>
    <content><![CDATA[<p><strong>简介: 一个用于数据持久层的框架</strong></p>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mybatis配置文件</span></span><br><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">    <span class="comment">//此处是直接调用方法进行操作，建议使用代理开发</span></span><br><span class="line">    List&lt;EoeAccount&gt; datas = session.selectList(<span class="string">&quot;test.selectAll&quot;</span>);</span><br><span class="line">    datas.forEach(System.out::println);</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>Mybatis配置文件</strong>(mybatis-config.xml)</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/eoezora?useSSL=false<span class="symbol">&amp;amp;</span>allowPublicKeyRetrieval=true&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/TestDemoMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>SQL语句</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>映射文件</strong>(TestDemoMapper.xml)</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 代理开发中 namespace的值应该是 Mapper接口的全限定名 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 例如 com.eoezora.mapper.TestDemoMapper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- resultType 返回值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.eoezora.pojo.EoeAccount&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM account;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h2 id="Mapper代理开发"><a href="#Mapper代理开发" class="headerlink" title="Mapper代理开发"></a>Mapper代理开发</h2><p><strong>定义与SQL映射文件同名的Mapper接口,并且将Mapper接口与SQL映射文件放置在同名文件下</strong></p>
<p><strong>设置SQL映射文件的namespace属性与Mapper接口全限定名</strong></p>
<p><strong>在Mapper接口中定义方法,方法名是SQL映射文件中的sql语句ID，并保持参数类型和返回值类型一致</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">    <span class="comment">//获取Mapper接口</span></span><br><span class="line">    <span class="type">TestDemoMapper</span> <span class="variable">testDemoMapper</span> <span class="operator">=</span> session.getMapper(TestDemoMapper.class);</span><br><span class="line">    <span class="comment">//使用接口调用方法</span></span><br><span class="line">    testDemoMapper.selectAll().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h2><p>在Nybatis的sql的映射文件中,会使用paramterType、resultType 来设置 sql 语句的输入输出参数，一般参数都是基本的数据类型或封装类型，但都需要声明该类型的全路径，java.lang.String，或者 cn.com.mybatis.pojo.User, 这时就可以通过 typeAliases设置别名,简化复杂度，提高阅读性, 例子如下</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mybatis.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM USER WHERE username LIKE &#x27;%$&#123;value&#125;%&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>使用别名简化后</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.mybatis.pojo.User&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;string&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- paramterType、resultType直接使用别名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM USER WHERE username LIKE &#x27;%$&#123;value&#125;%&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>其他</strong></p>
<p>批量添加别名,以下设置,会为该包下的所有类自动添加别名,为对应类名的首字母小写 User -&gt; user</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.mybatis.pojo&quot;</span>/&gt;</span></span><br><span class="line">&lt;/typeAliases</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql笔记-事务</title>
    <url>/mysql-note/%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h2><ul>
<li>数据库的事务是一种机制，一个操作序列，包含一组数据库操作命令</li>
<li>事务把所有命令作为一个整体向系统提交或撤销。这组命令要么同时成功，要么同时失败</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 定义事务开启</span></span><br><span class="line"><span class="comment">-- 事务开启后所作的操作为临时性的</span></span><br><span class="line"><span class="keyword">BEGIN</span>; <span class="comment">-- 也可以使用 START TRANSACTION;</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;蔡徐坤&#x27;</span>;</span><br><span class="line">假设这行语句错误</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">8000</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;孙笑川&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 回滚操作</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h2><ul>
<li><p><strong>原子性：事务是不可分割的最小操作单位，要么同时成功，要么同时失败；</strong></p>
</li>
<li><p><strong>一致性：事务完成后，必须是所有数据都保持一致状态</strong></p>
</li>
<li><p><strong>隔离性：多个事务之间，操作的可见性。每个事务之间操作隔离</strong></p>
</li>
<li><p><strong>持久性：事务一旦提交或者回滚，他对数据库的改变就是永久的</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看事务默认提交方式</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改默认提交方式 - 1 自动提交 - 0 手动提交</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql笔记1</title>
    <url>/mysql-note/mysql%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整形类型"><a href="#整形类型" class="headerlink" title="整形类型"></a>整形类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>有符号范围</th>
<th>无符号范围</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>1 byte</td>
<td>(-128,127)</td>
<td>(0,255)</td>
<td>小整数</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2 bytes</td>
<td>(-32768, 32768)</td>
<td>(0,65535)</td>
<td>大整数</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3 bytes</td>
<td>(-8388608,8388607)</td>
<td>(0, 16777215)</td>
<td>大整数</td>
</tr>
<tr>
<td>INT或INTEGER</td>
<td>4 bytes</td>
<td>(-2147483684, 2147483647)</td>
<td>(0,4294967295)</td>
<td>大整数</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8 bytes</td>
<td>(-2^63, 2^63 - 1)</td>
<td>(0, 2^64 - 1)</td>
<td>极大整数</td>
</tr>
<tr>
<td>FLOAT</td>
<td>4 bytes</td>
<td>(-3.402823466E+38,3.402823466351E+38)</td>
<td>0 和 (1.175494351E-38, 3.402823466E+38)</td>
<td>单精度浮点数值</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8 bytes</td>
<td>(-1.7976931348623157E+308, 1.7976931348623157E+308)</td>
<td>0 和 (2.2250738585072014E-308, 1.7976931348623157E+308)</td>
<td>双精度浮点数值</td>
</tr>
<tr>
<td>DECTMAL</td>
<td></td>
<td>依赖于M(精度)和D(标度)的值</td>
<td>依赖于M(精度)和D(标度)的值</td>
<td>小数值(精确定点数)</td>
</tr>
</tbody></table>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR</td>
<td>0-255 bytes</td>
<td>定长字符串, 长度不可变，性能较好</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>0-65535 bytes</td>
<td>可变字符串,根据存入的内容,长度会进行变化,性能较差</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>0-255 bytes</td>
<td>二进制数据</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>0-255 bytes</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>0-65535 bytes</td>
<td>二进制长文本</td>
</tr>
<tr>
<td>TEXT</td>
<td>0-65535 bytes</td>
<td>长文本数据</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>0-16777215 bytes</td>
<td>二进制中等长度文本</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>0-16777215 bytes</td>
<td>中等长度文本</td>
</tr>
<tr>
<td>LONGTBLOB</td>
<td>0-4294967295 bytes</td>
<td>二进制形式极大长度文本数据</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>0-4294967295 bytes</td>
<td>极大长度文本数据</td>
</tr>
</tbody></table>
<h3 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h3><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>范围</th>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td>3</td>
<td>1000-01-01 &gt; 9999-12-31</td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td>-838:59:59 &gt; 838:59:59</td>
<td>HH:MM:SS</td>
<td>时间值或持续时间</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>1901 &gt; 2155</td>
<td>YYYY</td>
<td>年份值</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01 00:00:00 &gt; 9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4</td>
<td>1970-01-01 00:00:01 &gt; 2038-01-19 03:14:07</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间，时间戳</td>
</tr>
</tbody></table>
<h2 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h2><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><blockquote>
<p>数据定义语言，用来定义数据库对象（数据库，表，字段）</p>
</blockquote>
<ol>
<li>查询所有数据库: <code>SHOW DATABASES;</code></li>
<li>查询当前数据库：<code>SELECT DATABASE();</code></li>
<li>创建数据库：<code>CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE] 排序规则;</code></li>
<li>删除数据库：<code>DROP DATABASE [IF EXISTS] 数据库名;</code></li>
<li>使用数据库：<code>USE 数据库名;</code></li>
<li>查询当前数据库所有表：<code>SHOW TABLES;</code></li>
<li>查询表结构：<code>DESC 表名</code></li>
<li>查询指定表的建表语句：<code>SHOW CREATE TABLE 表名</code></li>
<li>表创建：<code>CREATE TABLE 表名(字段 类型 [COMMENT 字段注释]....)[COMMENT 表注释]</code></li>
<li>添加字段：<code>ALTER TABLE 表名 ADD 字段名 类型 [COMMENT 字段注释] 约束</code></li>
<li>修改字段数据类型：<code>ALTER TABLE 表名 MODIFY 字段名 新的数据类型</code></li>
<li>修改字段名和字段类型：&#96;ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型  [COMMENT 字段注释] 约束&#96;&#96;</li>
<li>添加外键：<code>ALTER TABLE 表名 ADD CONSTRANINT 外键名 FOREIGN KEY(外键名) REFERENCES 关联表(主键名) [ON UPDATE 更新行为] [ON DELETE 删除行为]</code><ol>
<li>例如： <code>ALTER TABLE emp ADD CONSTRANINT fk_emp_dept_id FOREIGN KEY(dept_id) REFERENCES dept(id)</code></li>
</ol>
</li>
<li>删除外键：<code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名</code> </li>
<li>删除字段：<code>ALTER TABLE 表名 DROP 字段名</code></li>
<li>表名修改：<code>ALTER TABLE 表名 RENAME TO 新表名</code></li>
<li>删除表：<ol>
<li>删除表 <code>DROP TABLE 表名</code> </li>
<li>先删除表再重新创建该表 <code>TRUNCATE TABLE 表名</code></li>
</ol>
</li>
</ol>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><blockquote>
<p>数据操作语言，用来对数据库中的数据进行增删改</p>
</blockquote>
<ol>
<li><p>添加数据：</p>
<ol>
<li>插入指定字段的一条数据：<code>INSERT INTO 表名 (字段1，字段2...) VALUES (值1，值2)</code> </li>
<li>插入全部字段的一条数据：<code>INSERT INTO 表名 VALUES (值1,值2....)</code></li>
<li>插入指定字段的多条数据：<code>INSERT INTO 表名 (字段1，字段2...) VALUES (值1，值2), (值1，值2), (值1，值2).....</code></li>
<li>插入全部字段的多条数据：<code>INSERT INTO 表名 VALUES (值1,值2...),(值1,值2....),(值1,值2....)...</code><blockquote>
<p>插入数据时，字段位置与值位置应一一对应<br>字符串和日期类型数据应包含在双引号中<br>插入的值的大小应符合字段要求</p>
</blockquote>
</li>
</ol>
</li>
<li><p>修改数据：<code>UPDATE 表名 SET 字段1=值1，字段2=值2,... [WHERE 条件]</code></p>
</li>
<li><p>删除数据：&#96;DELETE FROM 表名 [WHERE 条件]</p>
</li>
</ol>
<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><blockquote>
<p>数据查询语言，用来查询数据库中表的记录</p>
</blockquote>
<p>执行顺序</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>       <span class="comment">-- 4</span></span><br><span class="line"><span class="comment">-- 	字段列表</span></span><br><span class="line"><span class="keyword">FROM</span>         <span class="comment">-- 1</span></span><br><span class="line"><span class="comment">-- 	表名列表</span></span><br><span class="line"><span class="keyword">WHERE</span>        <span class="comment">-- 2</span></span><br><span class="line"><span class="comment">-- 	条件列表</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>     <span class="comment">-- 3</span></span><br><span class="line"><span class="comment">-- 	分组列表</span></span><br><span class="line"><span class="keyword">HAVING</span>       <span class="comment">-- 分组条件后执行</span></span><br><span class="line"><span class="comment">-- 	分组后条件</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>     <span class="comment">-- 5</span></span><br><span class="line"><span class="comment">-- 	排序字段</span></span><br><span class="line">LIMIT        <span class="comment">-- 6</span></span><br><span class="line"><span class="comment">-- 	限制查询返回数据的数量，用于分页限制</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>详细查看 <a href="https://kita-17.github.io/mysql-note/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2/">查看单表查询</a></p>
</blockquote>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><blockquote>
<p>数据控制语言，用来创建数据库用户，控制数据库的访问权限</p>
</blockquote>
<h4 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h4><ol>
<li>查询用户：在系统数据库 <code>mysql</code> 中使用 <code>SELECT * FROM user;</code></li>
<li>创建用户：<code>CREATE USER &#39;用户名@主机地址&#39; IDENTIFIED BY 密码</code><ul>
<li>主机地址：只允许这个地址的电脑访问，例如 <code>localhost</code> 表示只允许本地主机访问。如果想任意主机访问，主机地址使用 <code>%</code> 即可，例如 <code>&#39;kita&#39;@&#39;%&#39;</code></li>
</ul>
</li>
<li>修改用户密码：<code>ALTER USER &#39;用户名@主机地址&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;</code></li>
<li>删除用户：<code>DROP USER &#39;用户名@主机地址&#39;</code></li>
</ol>
<h4 id="权限操作"><a href="#权限操作" class="headerlink" title="权限操作"></a>权限操作</h4><table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ALL,ALL PRIVILEGES</td>
<td>所有权限</td>
</tr>
<tr>
<td>SELECT</td>
<td>查询数据</td>
</tr>
<tr>
<td>INSTER</td>
<td>插入数据</td>
</tr>
<tr>
<td>UPDATE</td>
<td>修改数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除数据</td>
</tr>
<tr>
<td>ALTER</td>
<td>修改表</td>
</tr>
<tr>
<td>DROP</td>
<td>删除数据库&#x2F;表&#x2F;视图</td>
</tr>
<tr>
<td>CREATE</td>
<td>创建数据库&#x2F;表</td>
</tr>
</tbody></table>
<ol>
<li>查询权限：<code>SHOW GANTS FOR &#39;用户名@主机地址&#39;</code></li>
<li>授予权限：<code>GRANT 权限列表 ON 数据库.表名 TO &#39;用户名@主机地址&#39;</code></li>
<li>撤销权限：<code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名@主机地址&#39;</code></li>
</ol>
<blockquote>
<p>授权时可以使用 * 代表所有数据库或所有表，例如： test.* 表示 test数据库的所有表</p>
</blockquote>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote>
<p>函数指一段可以被另一个程序直接调用的程序或代码</p>
</blockquote>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CONCAT(S1,S2,S3….)</td>
<td>字符串拼接</td>
</tr>
<tr>
<td>LOWER(str)</td>
<td>字符串转小写</td>
</tr>
<tr>
<td>UPPER(str)</td>
<td>字符串转大写</td>
</tr>
<tr>
<td>LPAD(str,n,pad)</td>
<td>左填充，用字符串pad对str进行左填充，达到n个长度</td>
</tr>
<tr>
<td>RPAD(str,n,pad)</td>
<td>右填充，用字符串pad对str进行右填充，达到n个长度</td>
</tr>
<tr>
<td>TRIM(str)</td>
<td>去掉字符串首尾空格</td>
</tr>
<tr>
<td>SUBSTRING(str,start,len)</td>
<td>返回从str的start位置开始的len长度的子字符串</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(<span class="string">&#x27;14:&#x27;</span>,<span class="string">&#x27;4:&#x27;</span>,<span class="string">&#x27;514&#x27;</span>); <span class="comment">-- 14:4:514  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">select</span> <span class="built_in">lower</span>(<span class="string">&#x27;ABNHFKFK&#x27;</span>); <span class="comment">-- abnhfkfk  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">UPPER</span>(<span class="string">&#x27;fafafagag&#x27;</span>); <span class="comment">-- FAFAFAGAG  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">SELECT</span> RPAD(<span class="string">&#x27;kita&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;y&#x27;</span>); <span class="comment">-- kitayyyyyy  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">select</span> LPAD(<span class="string">&#x27;kita&#x27;</span>, <span class="number">10</span>, <span class="string">&#x27;-&#x27;</span>); <span class="comment">-- ------kita  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">select</span> <span class="built_in">TRIM</span>(<span class="string">&#x27; I P &#x27;</span>); <span class="comment">-- I P  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;ABCDEFG&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>); <span class="comment">-- BCDE 索引从1开始  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">select</span> concat(LPAD(<span class="string">&#x27;KITA&#x27;</span>, <span class="number">5</span>, <span class="string">&#x27;-&#x27;</span>), RPAD(<span class="string">&#x27;kita&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;y&#x27;</span>)); <span class="comment">-- -KITAkitayyyyyy</span></span><br></pre></td></tr></table></figure></div>

<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CEIL(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>FLOOR(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>MOD(x,y)</td>
<td>返回x&#x2F;y的模</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回0~1内的随机数</td>
</tr>
<tr>
<td>ROUND(x,y)</td>
<td>求参数x的四舍五入值，保留y为小数</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEIL</span>(<span class="number">2.3</span>); <span class="comment">-- 3  向上取整</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">2.3</span>); <span class="comment">-- 2 向下取整  </span></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> 取余运算  </span></span><br><span class="line"><span class="comment"> 例子:  </span></span><br><span class="line"><span class="comment">    MOD(20,12) 商为1 余数8, 所以MOD(20,12) = 8  </span></span><br><span class="line"><span class="comment">    MOD(6 ,12) 不能整除，值为 除数×(整商+1)-被除数 &gt; 12×(0 + 1)-6 = 6 </span></span><br><span class="line"><span class="comment">*/</span>   </span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MOD</span>(<span class="number">6</span>, <span class="number">12</span>); <span class="comment">-- 6  </span></span><br><span class="line"><span class="keyword">SELECT</span> RAND(); <span class="comment">-- 0到1之间的随机数  </span></span><br><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="number">1.114514</span>, <span class="number">2</span>) <span class="comment">-- 1.11 四舍五入，保留两位小数</span></span><br><span class="line"><span class="comment">-- 小应用</span></span><br><span class="line"><span class="keyword">SELECT</span> LPAD(ROUND(RAND() <span class="operator">*</span> <span class="number">1000000</span>, <span class="number">0</span>), <span class="number">6</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">-- 取六位随机数</span></span><br></pre></td></tr></table></figure></div>

<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CURDATE()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CURTIME()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>NOW()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>YEAR(date)</td>
<td>获取指定date的年份</td>
</tr>
<tr>
<td>MONTH(date)</td>
<td>获取指定date的月份</td>
</tr>
<tr>
<td>DAY(date)</td>
<td>获取指定date的日期</td>
</tr>
<tr>
<td>DATE_ADD(date, INTERVAL expr type)</td>
<td>返回指定日期&#x2F;时间date增加expr后的值</td>
</tr>
<tr>
<td>DATEDIFF(date1,date2)</td>
<td>返回date1和date2之间的间隔天数</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> curdate(); <span class="comment">-- 当前年月日  </span></span><br><span class="line"><span class="keyword">select</span> CURTIME(); <span class="comment">-- 当前时分秒  </span></span><br><span class="line"><span class="keyword">select</span> now();     <span class="comment">-- 当前年月日 是分娩  </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">year</span>(<span class="string">&#x27;2012-01-02&#x27;</span>); <span class="comment">-- 2012  </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">month</span>(<span class="string">&#x27;2021-01-10&#x27;</span>); <span class="comment">-- 1  </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">day</span>(now()); <span class="comment">-- 今天几号  </span></span><br><span class="line"><span class="keyword">select</span> DATE_ADD(NOW(), <span class="type">INTERVAL</span> <span class="number">70</span> <span class="keyword">DAY</span>); <span class="comment">-- 当前时间往后推70天  </span></span><br><span class="line"><span class="keyword">select</span> DATEDIFF(<span class="string">&#x27;2021-12-01&#x27;</span>, <span class="string">&#x27;2021-12-31&#x27;</span>); <span class="comment">-- 值为 -30 在计算时是第二个参数减去第一个参数</span></span><br></pre></td></tr></table></figure></div>

<h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>IF(value, t, f)</td>
<td>如果value为true返回t否则返回f</td>
</tr>
<tr>
<td>IFNULL(value1,value2)</td>
<td>如果value1不为空返回value1，否则返回value2</td>
</tr>
<tr>
<td>CASE WHEN [val] THEN [res1]… ELSE [DEFAULT] END</td>
<td>如果val为true返回res1…否则返回默认值</td>
</tr>
<tr>
<td>CASE [expr] WHEN [val] THEN [res1]… ELSE [DEFAULT] END</td>
<td>如果expr等于val返回res…否则返回默认值</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> if(<span class="literal">false</span>, <span class="string">&#x27;ok&#x27;</span>, <span class="string">&#x27;error&#x27;</span>); <span class="comment">-- error  </span></span><br><span class="line"><span class="keyword">select</span> ifnull((<span class="keyword">select</span> name <span class="keyword">from</span> emp <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">100</span>), <span class="string">&#x27;2&#x27;</span>); <span class="comment">-- 2  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> name <span class="keyword">when</span> <span class="string">&#x27;a13&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;先辈&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;田所&#x27;</span> <span class="keyword">end</span>,             <span class="comment">-- name = a13会被归类为 先辈，其余归类为田所  </span></span><br><span class="line">       <span class="keyword">case</span> address <span class="keyword">when</span> <span class="string">&#x27;野兽府邸7&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;下北泽&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;上北泽&#x27;</span> <span class="keyword">end</span>   <span class="comment">-- address = 野兽府邸7的数据会被归类为下北泽，其余的是上北泽  </span></span><br><span class="line"><span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></div>

<p><strong>运行结果如下</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/18/NYFnz7V8pJU4kXM.png"
                      alt="image.png"
                ></p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><blockquote>
<p>作用于表中字段上的规则，用于限制存储在表中的数据，保证数据库中数据的正确、有效、完成<br>对于约束</p>
</blockquote>
<h3 id="约束的分类"><a href="#约束的分类" class="headerlink" title="约束的分类"></a>约束的分类</h3><table>
<thead>
<tr>
<th>约束名称</th>
<th>功能描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>非空约束</td>
<td>保证列中数据不出现null</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证列中数据各不相同，唯一性</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>主键约束</td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td>PRIMARY KEY</td>
</tr>
<tr>
<td>默认约束</td>
<td>保存数据时,未指定就采用默认值</td>
<td>DEFAULT</td>
</tr>
<tr>
<td>外键约束</td>
<td>外键让两个表的数据之间建立连接，保证数据一致且完整</td>
<td>FOREIGN KEY</td>
</tr>
<tr>
<td>检查约束</td>
<td>保证字段满足某一条件(此约束为8.0.16版本之后新增)</td>
<td>CHECK</td>
</tr>
</tbody></table>
<h3 id="基础建表例子"><a href="#基础建表例子" class="headerlink" title="基础建表例子"></a>基础建表例子</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>  </span><br><span class="line">(  </span><br><span class="line">    id     <span class="type">int</span> <span class="keyword">primary</span> key auto_increment comment <span class="string">&#x27;主键&#x27;</span>,      <span class="comment">-- 主键且自增 </span></span><br><span class="line">    name   <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span> comment <span class="string">&#x27;姓名&#x27;</span>,         <span class="comment">-- 非空且唯一</span></span><br><span class="line">    age    <span class="type">int</span> <span class="keyword">check</span> ( age <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> age <span class="operator">&lt;=</span> <span class="number">120</span> ) comment <span class="string">&#x27;年龄&#x27;</span>, <span class="comment">-- 大于0小于等于120 </span></span><br><span class="line">    status <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="number">1</span> comment <span class="string">&#x27;状态&#x27;</span>,                   <span class="comment">-- 默认1</span></span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span> </span><br><span class="line">) comment <span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="外键约束例子"><a href="#外键约束例子" class="headerlink" title="外键约束例子"></a>外键约束例子</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>  </span><br><span class="line">(  </span><br><span class="line">    id       <span class="type">int</span> <span class="keyword">primary</span> key auto_increment comment <span class="string">&#x27;主键&#x27;</span>,  </span><br><span class="line">    name     <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span> comment <span class="string">&#x27;姓名&#x27;</span>,  </span><br><span class="line">    age      <span class="type">int</span> <span class="keyword">check</span> ( age <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> age <span class="operator">&lt;=</span> <span class="number">120</span> ) comment <span class="string">&#x27;年龄&#x27;</span>,  </span><br><span class="line">    status   <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="number">1</span> comment <span class="string">&#x27;状态&#x27;</span>,  </span><br><span class="line">    gender   <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span>,  </span><br><span class="line">    class_id <span class="type">int</span>, <span class="comment">-- 这里是分开的，不是跟外键语句一起 </span></span><br><span class="line">    <span class="keyword">constraint</span> fk_class_id <span class="keyword">foreign</span> key (class_id) <span class="keyword">references</span> class (id)  </span><br><span class="line">) comment <span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/18/YFutighQkLzOSU5.png"
                      alt="image.png"
                ></p>
<p><strong>删除外键</strong>：<code>ALTER TABLE user DROP FOREIGN KEY fk_class_id</code></p>
<blockquote>
<p>以上方的外键关联为例，<mark style="background: #FFB86CA6;">class 为父表 user 为子表</mark></p>
</blockquote>
<h3 id="外键删除更新行为"><a href="#外键删除更新行为" class="headerlink" title="外键删除更新行为"></a>外键删除更新行为</h3><ol>
<li>NO ACTION：当在父表中删除&#x2F;更新对应记录时，首先检查记录是否存在外键，如果有则不允许删除&#x2F;更新</li>
<li>RESTRICT：当在父表中删除&#x2F;更新对应记录时，首先检查是否有存在外键，如果有则不允许删除&#x2F;更新</li>
<li>CASCADE：当在父表中删除&#x2F;更新对应记录时，首先检查是否有存在外键，如果有，则也删除&#x2F;更新外键在子表中的记录</li>
<li>SET NULL：当在父表中删除对应记录时，首先检查是否有存在外键，存在则设置该外键为null（需要该外键字段允许为null）</li>
<li>SET DEFAULT：当父表有表更时，子表设置成一个默认值（Innodb引擎不支持）</li>
</ol>
<p>操作：<code>ALTER TABLE 表名 ADD CONSTRANINT 外键名 FOREIGN KEY(外键名) REFERENCES 关联表(主键名) [ON UPDATE 更新行为] [ON DELETE 删除行为]</code></p>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h4 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h4><h5 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h5><p>例如，用户表和用户信息表(不常用的信息)<br>实现方式: 在任意一方加入外键，关联另一方主键，并且设置外键为<strong>唯一</strong>(<strong>UNIQUE</strong>)，<mark style="background: #D2B3FFA6;">一般应用在单表拆分</mark></p>
<h5 id="一对多-多对一"><a href="#一对多-多对一" class="headerlink" title="一对多(多对一)"></a>一对多(多对一)</h5><p>例如：一个部门有多个员工，多个员工属于一个部门<br>实现方式：在<strong>多的一方</strong>添加一个外键，指向<strong>一的主键</strong>,例如 在员工表里添加一个部门ID外键，指向部门表的主键</p>
<h5 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h5><p>例如：商品和订单，一个订单多个商品，一个商品多个订单<br>实现方式：建立第三张中间表，中间表至少包含<strong>两个外键</strong>，分别关联两方主键</p>
<p><strong>订单表</strong></p>
<table>
<thead>
<tr>
<th>id</th>
<th>支付金额</th>
<th>支付方式</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>114514.0</td>
<td>WeChatPay</td>
<td>未支付</td>
</tr>
<tr>
<td>2</td>
<td>19198.0</td>
<td>AliPay</td>
<td>已支付</td>
</tr>
</tbody></table>
<p><strong>商品表</strong></p>
<table>
<thead>
<tr>
<th>id</th>
<th>商品名</th>
<th>价格</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>林檎</td>
<td>114514</td>
</tr>
<tr>
<td>2</td>
<td>迎宾酒</td>
<td>1919810</td>
</tr>
</tbody></table>
<p><strong>中间表</strong></p>
<table>
<thead>
<tr>
<th>id</th>
<th>订单id(外键)</th>
<th>商品id(外键)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
<p><strong>注解：以上方三表为例，中间表记录订单与商品的外键。两个订单id为1的数据代表着这个订单有两件商品</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 订单与商品关联例子</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> orders</span><br><span class="line">(</span><br><span class="line">    id      <span class="type">int</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    payment <span class="type">int</span>         <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    paytype <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    status  <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> goods</span><br><span class="line">(</span><br><span class="line">    id    <span class="type">int</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    name  <span class="type">varchar</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    price <span class="type">int</span>         <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tk_orders_goods</span><br><span class="line">(</span><br><span class="line">    id       <span class="type">int</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    order_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    good_id  <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tk_orders_goods <span class="keyword">add</span> <span class="keyword">constraint</span>  fk_order_id <span class="keyword">FOREIGN</span> KEY(order_id) <span class="keyword">REFERENCES</span> orders(id);</span><br><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tk_orders_goods <span class="keyword">add</span> <span class="keyword">constraint</span>  fk_good_id <span class="keyword">FOREIGN</span> KEY(good_id) <span class="keyword">REFERENCES</span> goods(id);</span><br></pre></td></tr></table></figure></div>

<h4 id="查询概述"><a href="#查询概述" class="headerlink" title="查询概述"></a>查询概述</h4><blockquote>
<p>从多张表中查询数据<br>笛卡尔积：笛卡尔乘积是指在数学中，两个集合A和B的所有组合情况。在多表查询中我们应消除无效的笛卡尔积</p>
</blockquote>
<ul>
<li>添加要查询的字段，以及添加查询条件，消除多余的，无效的笛卡尔积<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user.name, user.age, course.name  </span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span>,  </span><br><span class="line">     course  </span><br><span class="line"><span class="keyword">where</span> course.id <span class="operator">=</span> user.id;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><ul>
<li>相当于是查询两表的交集数据<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 隐式写法</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>, 表<span class="number">2.</span>.. <span class="keyword">WHERE</span> 条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示写法 INNER可以省略</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>假设有AB两表，AB做外连接查询时</p>
<ul>
<li>左外连接: 相当于查询A表所有数据和交集部分的数据</li>
<li>右外连接: 相当于查询B表所有数据和交集部分的数据</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 左外连接，OUTER 可以省略</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 右外连接，OUTER 可以省略</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件</span><br></pre></td></tr></table></figure></div>

<h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><ul>
<li>自连接<br><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件</code></li>
<li>右自连接<br><code>SELECT 字段列表 FROM 表A 别名A RIGHT JOIN 表A 别名B ON 条件</code></li>
<li>左自连接<br><code>SELECT 字段列表 FROM 表A 别名A LEFT JOIN 表A 别名B ON 条件</code></li>
</ul>
<p>当前表与自身的连接查询，<mark style="background: #BBFABBA6;">自连接必须取别名</mark>。例子如下，假设有一张表 <code>emp</code> 如下</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
<th>manageId</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>先辈</td>
<td>24</td>
<td>null</td>
</tr>
<tr>
<td>2</td>
<td>田所</td>
<td>24</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>远野</td>
<td>24</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>淳平</td>
<td>20</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>我修院</td>
<td>24</td>
<td>2</td>
</tr>
</tbody></table>
<p>表中有字段 <code>manageId</code> 其值指向这个员工的上级领导，因在本表中，<code>领导</code> 也是员工，只是岗位不一样。若想查询某个员工的上级领导。我们可以使用自连接。如下所示</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">在本例中，我们需要假设有两张表，通过manageId进行关联（当然实际表只有一张），其中分为</span></span><br><span class="line"><span class="comment">	user u1 代表普通员工表</span></span><br><span class="line"><span class="comment">	user u2 代表管理层员工表</span></span><br><span class="line"><span class="comment">通过自连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">	u1.name <span class="string">&#x27;员工&#x27;</span>, </span><br><span class="line">	u2.name <span class="string">&#x27;所属领导&#x27;</span> </span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span> u1 <span class="keyword">JOIN</span> <span class="keyword">user</span> u2 </span><br><span class="line"><span class="keyword">ON</span> u2.id <span class="operator">=</span> u1.manageId <span class="keyword">where</span> u1.id <span class="operator">=</span> <span class="number">2</span>; <span class="comment">-- 查询id为2的员工的上级领导</span></span><br></pre></td></tr></table></figure></div>

<h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><ul>
<li>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A...</span><br><span class="line"><span class="keyword">UNION</span>[<span class="keyword">ALL</span>] <span class="comment">-- 带ALL 不考虑合并后的去重。不带ALL，数据合并后去重</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表B...;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>对于联合查询的多张表列数必须保持一致，字段类型也需要保持一致</p>
</blockquote>
<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><ul>
<li>嵌套查询又称子查询，指SQL语句中嵌套 <code>SELECT</code> 语句，</li>
<li>针对子查询的结果不同分为：<ul>
<li>标量子查询 （子查询结果只有单个值）</li>
<li>列子查询 （子查询结果为一列）</li>
<li>行子查询 （子查询结果为一行）</li>
<li>表子查询 （子查询结果为多行多列）</li>
</ul>
</li>
<li>根据子查询位置分为：WHERE之后、 FROM之后、 SELECT之后</li>
</ul>
<p>例子：<code>SELECT * FROM user WHERE class_id = (其他的select语句)</code></p>
<h5 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h5><ul>
<li>子查询返回的结果是单个值（数字，字符串，日期等），最简单的形式</li>
<li>操作符：<code>=</code> <code>&lt;&gt;</code> <code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code></li>
</ul>
<p>例子：<br>查询 <code>下北泽高中3班</code> 有哪些学生</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="string">&#x27;学生&#x27;</span>  </span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span>  </span><br><span class="line"><span class="keyword">where</span> class_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> class <span class="keyword">where</span> className <span class="operator">=</span> <span class="string">&#x27;下北泽高中3班&#x27;</span>);</span><br><span class="line"><span class="comment">-- select name &#x27;学生&#x27; from user where class_id=4 返回相关学生名字</span></span><br><span class="line"><span class="comment">-- select id from class where className = &#x27;下北泽高中3班&#x27; 返回4</span></span><br></pre></td></tr></table></figure></div>
<p><strong>后面括号里的查询语句返回了一个 class_id ，最外层select语句根据这个class_id查询相关数据</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/18/5P3LsC7aqYuNtDr.png"
                      alt="~CJWI55TI3M5_T@@R@OPSIF.png"
                ></p>
<h5 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h5><ul>
<li>子查询结果是一列（可以是多行）</li>
<li>操作符：<code>IN</code> <code>NOT IN</code> <code>ANY</code> <code>SOME</code> <code>ALL</code></li>
</ul>
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>在指定集合范围内，多选一</td>
</tr>
<tr>
<td>NOT IN</td>
<td>不在指定集合内</td>
</tr>
<tr>
<td>ANY</td>
<td>子查询返回列表中，有任意一个满足即可</td>
</tr>
<tr>
<td>SOME</td>
<td>与ANY等同</td>
</tr>
<tr>
<td>ALL</td>
<td>子查询返回列表的所有值都必须满足</td>
</tr>
</tbody></table>
<h6 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h6><p>使用例</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name  </span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span>  </span><br><span class="line"><span class="keyword">where</span> class_id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> class <span class="keyword">where</span> className <span class="keyword">like</span> <span class="string">&#x27;下北泽%&#x27;</span>);</span><br></pre></td></tr></table></figure></div>
<p>在本例中，后面括号里的SELECT语句返回一个id列表(1，2)，然后这个结果作为前面SELECT语句的条件进行筛选</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/18/Bej2G6HOgTDFtaL.png"
                      alt="image.png"
                ><br>使用了操作符 <code>IN</code> 如果是 <code>NOT IN</code> 则会返回 <code>id</code> 不在 (1，2) 范围内的数据</p>
<h6 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h6><p><code>SELECT * FROM TABLE_NAME WHERE 字段 &gt; all()</code></p>
<p>使用例<br>查询成绩表里大于一班所有同学成绩的数据（即所有大于一班最大值的数据）</p>
<p>举例解析（人话）：假设成绩表里有一班和二班的英语成绩，其中一班成绩为 （10，20，30，40）. 二班成绩为 （10，30，45，50），那么结果是（45，50）ALL表示满足所有。例如45满足大于（10，20，30，40）的条件</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id <span class="keyword">from</span> score <span class="keyword">where</span> score.eng <span class="operator">&gt;</span> <span class="keyword">all</span>(<span class="keyword">select</span> eng  </span><br><span class="line"><span class="keyword">from</span> score  </span><br><span class="line"><span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> class_id<span class="operator">=</span><span class="number">1</span>))</span><br></pre></td></tr></table></figure></div>

<h6 id="ANY-amp-SOME"><a href="#ANY-amp-SOME" class="headerlink" title="ANY &amp; SOME"></a>ANY &amp; SOME</h6><p>使用例<br>查询英语成绩比一班任意一个同学高的数据（即表中所有大于一班最小值的数据）<br>还是以上面的例子解析，只要其他班的同学的成绩大于一班的任意一个同学的成绩即可。例如（15，22，32，41）都满足条件。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name  </span><br><span class="line"><span class="keyword">from</span> score  </span><br><span class="line"><span class="keyword">where</span> chiness <span class="operator">&gt;</span> <span class="keyword">any</span> (<span class="keyword">select</span> chiness <span class="keyword">from</span> score <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>);</span><br><span class="line"><span class="comment">-- any 也可以使用some 效果一样</span></span><br></pre></td></tr></table></figure></div>
<h5 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h5><ul>
<li>子查询结果是一行（可以是多列）<br>使用例<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (salary, manageId) <span class="operator">=</span> (<span class="keyword">select</span> salary, manageId <span class="keyword">from</span> emp <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>)</span><br></pre></td></tr></table></figure></div>
本例后方括号的子查询返回了一行两列的数据（10000，1）对应薪资与领导id<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/19/Ea8ZcBC53nrkmgl.png"
                      alt="image.png"
                ></li>
</ul>
<h5 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h5><ul>
<li>子查询返回的结果是多行多列</li>
<li>常用操作符: <code>IN</code></li>
</ul>
<p><strong>例一</strong><br>将表子查询返回的结果当作临时表与其他表进行联查操作<br>使用例</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询与先辈，远野入职时间相同且薪资相同的员工信息  </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (salary,joinDate) <span class="keyword">in</span> (<span class="keyword">select</span> salary,joinDate <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="keyword">in</span> (<span class="string">&#x27;先辈&#x27;</span>,<span class="string">&#x27;远野&#x27;</span>));</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/19/nwiQCy1F5KRxpT3.png"
                      alt="image.png"
                ></p>
<p><strong>例二</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询 指定日期后才入学的学生信息，以及对应的班级信息  </span></span><br><span class="line"><span class="keyword">select</span> user.<span class="operator">*</span>, c.className  </span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> joinDate <span class="operator">&gt;</span> <span class="string">&#x27;2003-01-01&#x27;</span>) <span class="keyword">user</span> <span class="keyword">left</span> <span class="keyword">join</span> class c <span class="keyword">on</span> c.id <span class="operator">=</span> user.class_id;</span><br></pre></td></tr></table></figure></div>
<p>在本例中，<code>from</code> 后面跟着表子查询，其结果当作临时表<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/19/vnyuA5MJNbXj7iw.png"
                      alt="image.png"
                ></p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote>
<p>事务是一组操作的集合，是不可分割的工作单位。事务会把所有操作作为一个整体向系统提交或撤销。这些操作要么同时成功，要么同时失败。</p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>mysql默认是提交事务的，每执行一条sql语句，就会把相关的更改提交，如果不想mysql自动提交，我们可以使用命令 <code>SET @@AUTOCOMMMIT=0;</code> 设置mysql的事务提交方式为 <code>手动提交</code>  如果设置成 <code>1</code> 则是自动提交。同时，我们可以使用命令 <code>SELECT @@AUTOCOMMMIT</code> 查看事务提交方式。若sql语句执行成功我们可以使用命令 <code>COMMIT;</code> 来提交事务，若执行过程中出错，我们可以使用 <code>ROLLBACK;</code> 进行事务回滚。<br>除了通过上述这种方式更改提交方式启用事务外，我们也可以使用下面这种方式开启事务。</p>
<p><strong>手动开启事务方式</strong></p>
<ul>
<li>事务开启：<code>START TRANSACTION</code> 或 <code>BEGIN</code></li>
<li>事务提交：<code>COMMIT</code></li>
<li>事务回滚：<code>ROLLBACK</code></li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 开启事务  </span></span><br><span class="line"><span class="keyword">start</span> transaction;  </span><br><span class="line"><span class="comment">-- 转账  </span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;李田所&#x27;</span>;  </span><br><span class="line">异常...  </span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;淳平&#x27;</span>;  </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account;  </span><br><span class="line"><span class="comment">-- 提交事务  </span></span><br><span class="line"><span class="keyword">commit</span>;  </span><br><span class="line"><span class="comment">-- 事务回滚  </span></span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>事务作用域是当前会话（连接）</p>
</blockquote>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li>
<li>一致性：事务完成后，必须使所有数据都保持一致状态，例如，事务完成后，不顾那是成功提交了还是失败回滚了。此时数据库的状态满足所有的完整性约束，就说该数据库是一致的</li>
<li>隔离性：数据库提供的隔离机制，保证事务在不受外部并外操纵影响的独立环境下运行</li>
<li>持久性：事务一旦提交或回滚。他对数据库的改变是永久的</li>
</ul>
<h3 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h3><blockquote>
<p>上述四个特性中，每个都缺一不可，不过原子性，一致性，持久性这三个较好理解。所以这里将重点记录隔离性。</p>
</blockquote>
<p>在实际开发中哦我们总会遇到并发问题，mysql的事务在并发情况下可能会出现以下几种问题，同时也是 <mark style="background: #ADCCFFA6;">事务隔离要解决的问题</mark></p>
<ul>
<li>脏读：一个事务读取到另一个事务还没有提交的数据</li>
<li>不可重复读：一个事务先后读取同样一条数据，但两次读取的数据不同</li>
<li>幻读：一个事务按照条件筛选数据时，没有对应的数据行，但在插入这条数据时，又发现这行数据已经存在了</li>
</ul>
<p>SQL定义了四种隔离级别，mysql全部支持，四种级别分别是</p>
<ol>
<li>Read uncommitted（读未提交）</li>
<li>Read committed（读提交）</li>
<li>Repeatable Read（可重复读，默认级别）</li>
<li>Serializable（串行化，操作时给事务加锁，性能最差）<br>这四种级别从上往下，隔离效果逐渐增强，但性能逐渐变差。采用哪种级别需根据实际业务而定</li>
</ol>
<table>
<thead>
<tr>
<th>级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>读提交</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>串行化</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<p>可以看出只有 <mark style="background: #FFB86CA6;">串行化</mark> 的隔离级别解决了全部这 3 个问题，其他的 3 个隔离级别都有缺陷</p>
<h4 id="隔离级别的使用"><a href="#隔离级别的使用" class="headerlink" title="隔离级别的使用"></a>隔离级别的使用</h4><p>查看事务隔离级别：<code>SELECT @@TRANSACTION_ISOLATION;</code><br>设置事务隔离级别：<code>SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL [隔离级别]</code><br>    GLOBAL：全局<br>    SESSION：当前会话</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置当前会话的事务隔离级别为 serializable</span></span><br><span class="line"><span class="keyword">set</span> session transaction isolation level serializable;</span><br></pre></td></tr></table></figure></div>
<h4 id="脏读，不可重复读，幻读的问题还原"><a href="#脏读，不可重复读，幻读的问题还原" class="headerlink" title="脏读，不可重复读，幻读的问题还原"></a>脏读，不可重复读，幻读的问题还原</h4><h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><p>A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据</p>
<table>
<thead>
<tr>
<th>SQL执行顺序</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td></td>
<td>开启事务</td>
</tr>
<tr>
<td>2</td>
<td>开启事务</td>
<td>查询数据为10</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>更改数据 -10，此时数据为0</td>
</tr>
<tr>
<td>4</td>
<td>查询数据为10（产生脏读）</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>后续操作报错，事务B回滚，数据变回10</td>
</tr>
<tr>
<td>6</td>
<td>更改数据 +10，此时数据为20（脏读数据+10）</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>提交事务</td>
<td></td>
</tr>
</tbody></table>
<h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><table>
<thead>
<tr>
<th>SQL执行顺序</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>第一次查询，结果为10</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>开启事务</td>
</tr>
<tr>
<td>4</td>
<td>其他操作</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>更改数据为20</td>
</tr>
<tr>
<td>6</td>
<td>第二次读取数据，结果为20（事务A查到了事务B提交的数据）</td>
<td>提交事务</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td></td>
</tr>
<tr>
<td>备注</td>
<td>在正常情况下，事务A两次查询都应该是10</td>
<td></td>
</tr>
</tbody></table>
<h5 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h5><table>
<thead>
<tr>
<th>SQL执行顺序</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>开启事务</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>查询id为3的数据，结果不存在</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>其他操作</td>
<td>开启事务</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>插入id为3的数据</td>
</tr>
<tr>
<td>5</td>
<td>也插入id为3的数据（报错，id重复）</td>
<td>提交事务</td>
</tr>
<tr>
<td>6</td>
<td>再次查询id为3的数据，<mark style="background: #FF5582A6;">结果显示为空</mark></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql笔记-数据库设计-多表查询</title>
    <url>/mysql-note/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>获取两表的交集数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 隐式写法</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>, 表<span class="number">2.</span>.. <span class="keyword">WHERE</span> 条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示写法</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件</span><br></pre></td></tr></table></figure></div>

<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>左外连接: 相当于查询A表所有数据和交集部分的数据</p>
<p>右外连接: 相当于查询B表所有数据和交集部分的数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 左外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 右外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件</span><br></pre></td></tr></table></figure></div>

<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>概念：查询中嵌套查询,根据查询结果不同，作用不同分为 <strong>单行单列，多行单列，多行多列</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 单行单列: 作为条件值 使用 = != &gt; &lt; 进行条件判断</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表 <span class="keyword">WHERE</span> 字段名 <span class="operator">=</span> (子查询语句);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多行单列: 作为条件值</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表 <span class="keyword">WHERE</span> 字段名 <span class="keyword">IN</span> (子查询语句);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多行多列: 作为虚拟表</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> (子查询语句) <span class="keyword">WHERE</span> 条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 例子 查询工资大于 蔡徐坤 的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> money <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> money <span class="keyword">FROM</span> infos <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;蔡徐坤&quot;);</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql笔记2</title>
    <url>/mysql-note/mysql%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h2 id="Mysql的体系结构"><a href="#Mysql的体系结构" class="headerlink" title="Mysql的体系结构"></a>Mysql的体系结构</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-static.segmentfault.com/704/443/704443246-60595802ee830"
                     
                ></p>
<ul>
<li>连接层：最上层时一些客户端和链接服务，主要完成连接处理，授权认证，以及相关的安全方案。回味安全连接的每个用户验证操作权限</li>
<li>服务层：服务层主要完成核心服务功能，如SQL接口，SQL分析和优化。缓存的查询，部分内置函数的执行等。所有跨存储引擎的功能也是在服务层实现的。如过程，函数等。</li>
<li>引擎层：存储引擎真正负责mysql中数据的存储和提取，服务器通过API和引擎通信。不同引擎有不同的功能。<mark style="background: #ADCCFFA6;">不同的引擎其索引结构也不同</mark></li>
<li>存储层：主要将数据存储在文件系统上，并与引擎进行交互</li>
</ul>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><blockquote>
<p>存储引擎就是<mark style="background: #FFF3A3A6;">存储数据</mark>、<mark style="background: #BBFABBA6;">建立索引</mark>、<mark style="background: #FFB86CA6;">更新&#x2F;查询数据</mark>等技术的实现方式。<mark style="background: #D2B3FFA6;">存储引擎是基于表的，而不是基于库的</mark>，所以存储引擎也可以被成为表的类型<br>mysql默认存储引擎是 <mark style="background: #ADCCFFA6;">InnoDB</mark></p>
</blockquote>
<p>创建表时指定存储引擎 <code>CREATE TABLE 表名(字段信息...) ENGINE=引擎名(默认InnoDB) 其他设置...</code><br>通过指令 <code>SHOW ENGINES;</code> 查看当前数据库支持的存储引擎，结果如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/20/9TqtFO13sbgy5Zf.png"
                      alt="image.png"
                ></p>
<h3 id="常见的三个引擎特点"><a href="#常见的三个引擎特点" class="headerlink" title="常见的三个引擎特点"></a>常见的三个引擎特点</h3><p><strong>mysql常见常用的存储引擎有三种，分别是</strong> <code>InnoDB</code> 、<code>MyISAM</code> <strong>和</strong> <code>MEMORY</code></p>
<h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><blockquote>
<p>是一种兼顾高可靠性和高性能的通用存储引擎</p>
</blockquote>
<ul>
<li>特点<ul>
<li>DML操作遵循ACID模型，支持事务</li>
<li>行级锁，提高并发访问性能</li>
<li>支持外键 <code>FOREIGN KEY</code> 约束，保证数据完整和正确</li>
</ul>
</li>
<li>文件<ul>
<li>xxx.ibd 其中xxx是表名，InnoDB的每一张表都会有对应的表空间文件来存储该表的表结构（frm、sdi）、数据和索引</li>
</ul>
</li>
</ul>
<h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><blockquote>
<p>mysql早期的默认存储引擎</p>
</blockquote>
<ul>
<li>特点<ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁，不支持行锁</li>
<li>访问速度快</li>
</ul>
</li>
<li>文件<ul>
<li>xxx.MYD：存放表中的数据</li>
<li>xxx.MYI：存储索引</li>
<li>xxx.sdi：存放表结构</li>
</ul>
</li>
</ul>
<h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><blockquote>
<p>表数据存储在内存中，但由于内存断电数据就没了，所以只能将这些表做临时表或缓存使用</p>
</blockquote>
<ul>
<li>特点<ul>
<li>数据存在内存中吗，访问速度最快</li>
<li>hash索引（默认）</li>
</ul>
</li>
<li>文件<ul>
<li>xxx.sdi：存放表结构</li>
</ul>
</li>
</ul>
<h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><blockquote>
<p>存储引擎并无好坏之分，我们应根据业务需求选择合适的存储引擎</p>
</blockquote>
<ul>
<li>InnoDB：如果业务<mark style="background: #BBFABBA6;">对事务的完整性有较高要求</mark>，在<mark style="background: #ADCCFFA6;">高并发场景下要求数据较高的一致性</mark>，<mark style="background: #FFF3A3A6;">数据操作包括增删改查</mark>，那么InnoDB存储引擎是比较合适的选择（现开发使用较多）</li>
<li>MyISAM：如果业务场景以读操作和插入操作为主，只有较少的更新和删除操作，并且对事务的完整性，并发性要求不高。那么MyISAM存储引擎是比较合适的。例如评论功能，购物车数据等对数据安全性要求不高的场景，偶尔丢一两条数据也不要紧的场景。（使用较少，现被nosql服务替代）</li>
<li>MEMORY：数据保存在内存中，访问速度快，通常用于临时表与缓存。但是表的大小有限制，太大太多的数据无法缓存在内存中，且无法保证数据的安全性。（使用较少，现被redis替代）</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p>索引（Index）是帮助mysql<mark style="background: #BBFABBA6;">高效获取数据</mark>的 <mark style="background: #FFF3A3A6;">数据结构（有序）</mark> </p>
<ul>
<li>优点<ol>
<li>提高数据检索效率，降低数据库IO成本（空间换时间）</li>
<li>通过索引列对数据进行排序，降低数据排序成本，降低CPU消耗</li>
</ol>
</li>
<li>缺点<ol>
<li>索引列需要占用存储空间（磁盘空间较便宜，占用大小基本可以忽视）</li>
<li>索引大大提高了查询效率，但同时也降低了更新表的速度，例如UPDATE、INSERT、DELETE的速度降低（一般情况下查询比例比例比增删改比例大得多）</li>
</ol>
</li>
</ul>
<h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p><strong>mysql的索引是由存储引擎实现的，不同的引擎由不同的索引结构，主要有以下几种</strong></p>
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>B+Tree索引</td>
<td>最常见的索引类型</td>
</tr>
<tr>
<td>Hash索引</td>
<td>底层数据结构用哈希表实现，只有精确匹配索引的查询才有效，不支持范围查询</td>
</tr>
<tr>
<td>R-Tree索引</td>
<td>空间索引数MyISAM引擎的一个特殊索引，主要用于地理空间数据类型，使用较少</td>
</tr>
<tr>
<td>Full-TEXT索引</td>
<td>通过建立倒排索引快速匹配文档的方式，类似Lucene，Solr，ES,使用较少</td>
</tr>
</tbody></table>
<p><strong>三种常见存储引擎的索引支持情况</strong></p>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>B+Tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-Tree索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-TEXT索引</td>
<td>5.6版本后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<blockquote>
<p>若没有特别指明，一般索引都是指 <mark style="background: #BBFABBA6;">B+Tree</mark> 结构</p>
</blockquote>
<h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h4><blockquote>
<p>BST（二叉查找树）和B-Tree（平衡多路查找树）相关查看 <a class="link"   href="https://blog.csdn.net/atwdy/article/details/119190011" >二叉树 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 <a class="link"   href="https://blog.csdn.net/weixin_54787921/article/details/116452743" >B-Tree <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>B+Tree是B-Tree的变种，MySQL普遍使用B+Tree实现索引结构。B+Tree与B-Tree的区别在于B+Tree所有数据都存在叶子节点，叶子节点形成一个单向链表。非叶子节点起到索引数据的作用</p>
<p><strong>经典B+Tree结构如下</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/20/B1mtrnyYHTWSZQG.png"
                      alt="image.png"
                ><br>B+树的每个节点（非叶子节点与叶子节点）都会存放在一页中（如下图橙色区块所示，一个磁盘块，一页的大小是固定的为 <code>16k</code>），B+树非叶子节点不存放数据，在有限的空间里能够存放更多的key和指针，在相同数据量情况下，树的层级会更少，层级少，检索速度较快些。而B树因为每个节点都会存放数据，所以单个节点能够存放的key和指针会更少，在相同数据量情况下，B树的层级会更多，层级多，检索速度就会较慢。</p>
<p><strong>mysql中的B+Tree索引</strong><br>mysql对B+Tree进行优化，在B+Tree原来的基础上增加了一个指向相邻叶子节点的链表指针，形成了带有顺序指针的B+Tree，提高区间访问的性能。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/20/tAVrYp7WgPxu3nw.png"
                      alt="屏幕截图 2023-03-20 153617.png"
                ></p>
<p>从上图可以看到，mysql在B+Tree的每个叶子节点之间增加了一个链表指针形成双向链表，方便范围搜索与排序</p>
<h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><ul>
<li>哈索索引是采用一定的Hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中</li>
<li>如果有两个（或以上）键值映射到了同一个槽位上，他们就产生了冲突（也叫hash碰撞），可以通过链表解决，如下图中的 <code>金庸</code> 和 <code>杨逍</code> 两键值都对应到槽位 005 上发生了冲突，此时可以让这两个键值形成一个链表解决此冲突，如果还有其他键值也是005槽位的，只要把这个键值加在链表后方即可</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/20/raWdfNLt4y5kKzR.png"
                      alt="image.png"
                ></p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>Hash索引只能用于等值比较（精确匹配，如 &#x3D; 和 in），不支持范围查询（例如， between，&gt;，&lt; …）</li>
<li>无法利用索引完成排序（hash运算的结果是无序的）</li>
<li>查询效率最高，通常只需一次检索就行，效率通常高于B+Tree索引（不出现hash碰撞的情况下）</li>
</ol>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><blockquote>
<p>InnoDB引擎选择B+Tree索引结构的原因</p>
</blockquote>
<ol>
<li>相对于二叉树，层级更少，搜索效率更高</li>
<li>对于B-Tree，无论是叶子节点，还是非叶子节点，都会存放数据。这样导致一页中存储的键值和指针减少，为了保存相同数据，只能增加B-Tree的高度，导致性能降低</li>
<li>相对于Hash索引，Hash索引只支持等值匹配，B+Tree同时还支持范围匹配和排序操作</li>
</ol>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><ul>
<li>主要分为以下四种</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对表中主键创建的索引</td>
<td><mark style="background: #FFB86CA6;">默认自动创建，只能有一个</mark></td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列的值重复</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td>
<td>可以有多个</td>
<td>FULL</td>
</tr>
</tbody></table>
<p>根据索引形式，又可以分为以下两种</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引 (Clustered Index)</td>
<td>将数据存储与索引放到了一块，索引结构的叶子节点保存行的数据</td>
<td>必须有，而且只有一个</td>
</tr>
<tr>
<td>二级索引 (Secondary Index)</td>
<td>将数据与索引分开存储吗，索引结构的叶子节点关联的是对应主键</td>
<td>可以存在多个</td>
</tr>
</tbody></table>
<p><strong>聚集索引的选取规则</strong></p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果主键不存在，将使用第一个唯一索引作为聚集索引</li>
<li>如果没有主键，也没有唯一索引，则InnoDB会自动生成一个rowId作为隐藏索引</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/20/dGUhZD73VXmWTzL.png"
                      alt="_LP8MQ4DFFSXEE_Q__V0ODY.png"
                ></p>
<p>聚集索引，数据与索引放到了一起，如上图在索引结构的叶子节点 索引 <code>id</code> 挂着的数据是对应的行数据，而二级索引的叶子节点则是的存放着对应行的聚集索引值也就 <code>id</code> 的值（以上图中的表为例）</p>
<p><strong>查询过程</strong><br>以下图中表为例，要查询 <code>name=Arm</code> 的行数据，我们给的是一个二级索引 <code>name</code>，数据库会根据二级索引查到对应的 <code>id</code> （主键或者叫聚集索引），然后再根据查到的聚集索引值去查询行数据。这个过程叫回表查询。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/20/bXtld4hJTY3OCrx.png"
                      alt="KGEECPKG_K_~S33D_ACPQLA.png"
                ></p>
<h4 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h4><ol>
<li>以下两个语句哪个执行效率高</li>
</ol>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--语句1</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">-- id为主键</span></span><br><span class="line"><span class="comment">--语句2</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>语句1在查询时通过id去查询B+Tree树，因为id是主键也就是聚集索引。索引可以直接查到行数据，所以效率较高</li>
<li>语句2在查询时通过name去查询，需要先查询name对应的id值，再根据id去查行数据。需要回表查询，所以查询效率较低</li>
</ul>
<h3 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h3><ul>
<li>创建索引：<code>CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name(表中字段名，可多个)</code></li>
<li>查看索引：<code>SHOW INDEX FROM table_name;</code></li>
<li>删除索引：<code>DROP INDEX index_name ON table_name</code></li>
</ul>
<h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h3><p>使用命令 <code>show global status like &#39;Com_______&#39;;</code> 查看服务器的操作情况，可以得到结果如下，我们可以根据输出结果查看哪些操作占比比较多，从而去优化相关的操作语句</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Com_binlog    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_commit    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_delete    <span class="operator">|</span> <span class="number">51</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_import    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_insert    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_repair    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_revoke    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_select    <span class="operator">|</span> <span class="number">18667</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_signal    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_update    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_xa_end    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br></pre></td></tr></table></figure></div>
<h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p>上述方法只能知道哪些操作占比较大，但具体是个哪个用户，哪个主机连接，用的哪个数据库，什么时候操作的都不知道。那怎么办？Mysql提供了一种日志记录 <code>慢查询日志</code> ，但默认是关闭的。我们可以通过修改配置文件 <code>my.cnf</code> 添加如下配置开启慢查询日志</p>
<div class="highlight-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># 开启慢查询日志</span><br><span class="line">slow_query_log = ON </span><br><span class="line"># 查询超时多久后记录，单位：秒</span><br><span class="line">long_query_time = 1</span><br></pre></td></tr></table></figure></div>
<p>添加完成后重启数据库服务。修改配置文件是永久性操作。如果不想永久开启，可以使用如下命令，效果是一样的，只不过命令开启服务器重启后就没了（此方法需要退出数据库，重新登录才会设置成功）</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- global 也可以换成 session</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 查看慢查询日志开启状态与日志文件路径</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query%&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h4><p>慢查询日志记录了执行时间超过指定时长的SQL语句，通过记录的信息，我们可以知道SQL的执行用户，此次操作的数据库等等。但有时候，有些SQL执行时长没有超时，但离超时就差几毫秒，此类SQL不会被慢查询记录，而且通过慢查询我们无法得知SQL执行过程的每一步耗时。若想查看这些SQL的详细执行时间我们可以使用Mysql的 <code>Profile</code><br>首先查看数据库是否支持 <code>profile</code>，使用命令 <code>select @@have_profiling</code> 得到如下结果</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@have</span>_profiling;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@have</span>_profiling <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> YES              <span class="operator">|</span> <span class="comment">-- YES 支持profile</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br></pre></td></tr></table></figure></div>
<p>profile默认是关闭的，可以使用 <code>set profiling =1;</code> 开启profile，然后随便执行几个sql操作后受用命令 <code>show profiles;</code>  查看SQL操作的开销</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profiles ;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> Query_ID <span class="operator">|</span> Duration   <span class="operator">|</span> Query                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span> <span class="number">0.00056875</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span> <span class="number">0.00014950</span> <span class="operator">|</span> <span class="keyword">set</span> profiling <span class="operator">=</span><span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">3</span> <span class="operator">|</span> <span class="number">0.00053650</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span> <span class="number">0.00055050</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">5</span> <span class="operator">|</span> <span class="number">0.00049625</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">6</span> <span class="operator">|</span> <span class="number">0.00052800</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+-------------------------+</span></span><br></pre></td></tr></table></figure></div>
<p>若想知道指定SQL执行前后的耗时，我们可以使用命令 <code>show profile for query Query_ID;</code> 来查看，结果大致如下</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profile <span class="keyword">for</span> query <span class="number">6</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Status                         <span class="operator">|</span> Duration <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> starting                       <span class="operator">|</span> <span class="number">0.000045</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Executing hook <span class="keyword">on</span> transaction  <span class="operator">|</span> <span class="number">0.000002</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> starting                       <span class="operator">|</span> <span class="number">0.000005</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> checking permissions           <span class="operator">|</span> <span class="number">0.000003</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Opening tables                 <span class="operator">|</span> <span class="number">0.000029</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> init                           <span class="operator">|</span> <span class="number">0.000003</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">System</span> lock                    <span class="operator">|</span> <span class="number">0.000004</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> optimizing                     <span class="operator">|</span> <span class="number">0.000003</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> statistics                     <span class="operator">|</span> <span class="number">0.000006</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> preparing                      <span class="operator">|</span> <span class="number">0.000010</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> executing                      <span class="operator">|</span> <span class="number">0.000044</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">end</span>                            <span class="operator">|</span> <span class="number">0.000001</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query <span class="keyword">end</span>                      <span class="operator">|</span> <span class="number">0.000002</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> waiting <span class="keyword">for</span> handler <span class="keyword">commit</span>     <span class="operator">|</span> <span class="number">0.000005</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> closing tables                 <span class="operator">|</span> <span class="number">0.000004</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> freeing items                  <span class="operator">|</span> <span class="number">0.000022</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> logging slow query             <span class="operator">|</span> <span class="number">0.000325</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cleaning up                    <span class="operator">|</span> <span class="number">0.000015</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br></pre></td></tr></table></figure></div>
<p>如果想知道SQL执行过程中CPU使用情况只需在 <code>show profile for query Query_ID;</code> 中加个 <code>cpu</code> 的参数即可变成 <code>show profile cpu for query Query_ID;</code></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+----------+------------+</span></span><br><span class="line"><span class="operator">|</span> Status                         <span class="operator">|</span> Duration <span class="operator">|</span> CPU_user <span class="operator">|</span> CPU_system <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+----------+------------+</span></span><br><span class="line"><span class="operator">|</span> starting                       <span class="operator">|</span> <span class="number">0.000045</span> <span class="operator">|</span> <span class="number">0.000044</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Executing hook <span class="keyword">on</span> transaction  <span class="operator">|</span> <span class="number">0.000002</span> <span class="operator">|</span> <span class="number">0.000002</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> starting                       <span class="operator">|</span> <span class="number">0.000005</span> <span class="operator">|</span> <span class="number">0.000005</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> checking permissions           <span class="operator">|</span> <span class="number">0.000003</span> <span class="operator">|</span> <span class="number">0.000003</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Opening tables                 <span class="operator">|</span> <span class="number">0.000029</span> <span class="operator">|</span> <span class="number">0.000029</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> init                           <span class="operator">|</span> <span class="number">0.000003</span> <span class="operator">|</span> <span class="number">0.000003</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">System</span> lock                    <span class="operator">|</span> <span class="number">0.000004</span> <span class="operator">|</span> <span class="number">0.000004</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> optimizing                     <span class="operator">|</span> <span class="number">0.000003</span> <span class="operator">|</span> <span class="number">0.000003</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> statistics                     <span class="operator">|</span> <span class="number">0.000006</span> <span class="operator">|</span> <span class="number">0.000007</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> preparing                      <span class="operator">|</span> <span class="number">0.000010</span> <span class="operator">|</span> <span class="number">0.000009</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> executing                      <span class="operator">|</span> <span class="number">0.000044</span> <span class="operator">|</span> <span class="number">0.000045</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">end</span>                            <span class="operator">|</span> <span class="number">0.000001</span> <span class="operator">|</span> <span class="number">0.000001</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query <span class="keyword">end</span>                      <span class="operator">|</span> <span class="number">0.000002</span> <span class="operator">|</span> <span class="number">0.000002</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> waiting <span class="keyword">for</span> handler <span class="keyword">commit</span>     <span class="operator">|</span> <span class="number">0.000005</span> <span class="operator">|</span> <span class="number">0.000004</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> closing tables                 <span class="operator">|</span> <span class="number">0.000004</span> <span class="operator">|</span> <span class="number">0.000004</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> freeing items                  <span class="operator">|</span> <span class="number">0.000022</span> <span class="operator">|</span> <span class="number">0.000022</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> logging slow query             <span class="operator">|</span> <span class="number">0.000325</span> <span class="operator">|</span> <span class="number">0.000058</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cleaning up                    <span class="operator">|</span> <span class="number">0.000015</span> <span class="operator">|</span> <span class="number">0.000015</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+----------+------------+</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>上述三种方式可以查看SQL的执行频率与执行时间，根据频率与执行时间，我们可以大概推断SQL的性能。但这种方式只是粗略地判定，并不能真正判定一条SQL的性能。要想真正SQL的执行性能，我们需要使用 <code>Explain</code></p>
</blockquote>
<h4 id="Explain执行计划"><a href="#Explain执行计划" class="headerlink" title="Explain执行计划"></a>Explain执行计划</h4><p><strong>使用</strong>：只需在SQL语句最前面添加 <code>explain</code> 或 <code>desc</code> 即可，例如下面这个例子</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> name <span class="keyword">from</span> course <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> uc.courseId <span class="keyword">from</span> user_course uc <span class="keyword">where</span> userId <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> class_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> class <span class="keyword">where</span> className<span class="operator">=</span><span class="string">&#x27;class1&#x27;</span>)));</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+--------+---------------------+-------------+---------+------------------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys       <span class="operator">|</span> key         <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>              <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+--------+---------------------+-------------+---------+------------------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> <span class="keyword">user</span>   <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>    <span class="operator">|</span> <span class="keyword">PRIMARY</span>,fk_class_id <span class="operator">|</span> fk_class_id <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> const            <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index; <span class="keyword">Start</span> temporary  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> uc     <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>                <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span>    <span class="number">7</span> <span class="operator">|</span>    <span class="number">14.29</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">join</span> buffer (hash <span class="keyword">join</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> course <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>             <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> test.uc.courseId <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">End</span> temporary                              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> SUBQUERY    <span class="operator">|</span> class  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> const  <span class="operator">|</span> className           <span class="operator">|</span> className   <span class="operator">|</span> <span class="number">50</span>      <span class="operator">|</span> const            <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index                                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+--------+---------------------+-------------+---------+------------------+------+----------+--------------------------------------------+</span></span><br></pre></td></tr></table></figure></div>

<p><strong>返回结果每列的解析</strong></p>
<ul>
<li>id：select查询语句的序列号，表示查询中执行select子句或者操作表的顺序。若id一样，则表的执行顺序是从上往下，若id不一样则id越大越先执行</li>
<li>select_type：查询的类型<ul>
<li>SIMPLE：简单表，不做表连接或子查询</li>
<li>PRIMARY：主查询，即外层的查询</li>
<li>UNION：union中的第二个或者后面的查询语句</li>
<li>SUBQUERY：select和where之后包含的子查询</li>
</ul>
</li>
<li><mark style="background: #BBFABBA6;">type：连接类型，性能由好到差分别为NULL，SYSTEM，CONST，EQ_REF，REF，INDEX，ALL</mark></li>
<li><mark style="background: #FFF3A3A6;">possible_keys：SQL操做的表可能用到的索引</mark></li>
<li><mark style="background: #FFB86CA6;">key：实际用到的索引</mark></li>
<li><mark style="background: #FFB8EBA6;">key_len：使用到的索引字节数，为索引字段最大可能值，非实际长度</mark></li>
<li>ref：非唯一索引查询</li>
<li>rows：执行查询的行数，预估值</li>
<li>filtered：查询返回行数占读取行数的百分比，值越大越好</li>
<li><mark style="background: #ABF7F7A6;">extr：额外显示的信息</mark><br>高亮的部分表示需要重点关注的内容</li>
</ul>
<h3 id="索引使用-1"><a href="#索引使用-1" class="headerlink" title="索引使用"></a>索引使用</h3><h4 id="索引使用检验"><a href="#索引使用检验" class="headerlink" title="索引使用检验"></a>索引使用检验</h4><p>假设有一张存放千万数据的表，在没有建立索引的情况下（除主键外，mysql默认会为主键建立索引）我们<mark style="background: #ADCCFFA6;">根据非主键字段查询数据</mark>，耗时会很久，例如下面这样</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku <span class="keyword">where</span> sn<span class="operator">=</span><span class="string">&#x27;100000003145001&#x27;</span>\G; <span class="comment">-- \G表示查询结果以列形式展示</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">data......</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">37.02</span> sec) <span class="comment">-- 查询用时 37秒</span></span><br></pre></td></tr></table></figure></div>
<p>我们可以看到从没建立索引的千万数据的表查询数据要花费2分钟多，这不是我们想要的结果，解决方式也很简单。只需给对应字段建立索引即可，如下所示，建立索引的时间与表中数据量挂钩</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> index ids_sku_sn <span class="keyword">on</span> tb_sku(sn);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">1</span> min <span class="number">5.47</span> sec) <span class="comment">-- 1000w数据建立索引花费了 1分5秒</span></span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure></div>
<p>索引建立完成后我们使用相同的查询语句再次查询</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku <span class="keyword">where</span> sn<span class="operator">=</span><span class="string">&#x27;100000003145001&#x27;</span>\G; <span class="comment">-- \G表示查询结果以列形式展示</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">data......</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec) <span class="comment">-- 查询用时 小于1秒，这个速度与使用主键查询差不多快</span></span><br></pre></td></tr></table></figure></div>

<h4 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h4><h5 id="最左前缀法则-联合索引"><a href="#最左前缀法则-联合索引" class="headerlink" title="最左前缀法则(联合索引)"></a>最左前缀法则(联合索引)</h5><ul>
<li>主要针对于联合索引（一个索引关联了多个字段）使用联合需要遵守最左前缀法则。最左前缀法则指查询从索引的最左列开始，且不跳过索引中的列。如果跳过了某列，索引将部分失效（跳过后的字段索引失效）如以下例子，假设有一张表有索引 <code>idx_user_age_gender_status</code> 关联了字段 <code>age</code> <code>gender</code> <code>status</code></li>
<li>使用 <code>explain</code> 查看查询使用了那些索引<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age<span class="operator">=</span><span class="number">24</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> gender<span class="operator">=</span><span class="string">&#x27;man&#x27;</span>\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: <span class="keyword">user</span></span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: <span class="keyword">ref</span></span><br><span class="line">possible_keys: idx_user_age_gender_status <span class="comment">-- 使用了联合索引</span></span><br><span class="line">          key: idx_user_age_gender_status</span><br><span class="line">      key_len: <span class="number">5</span></span><br><span class="line">          <span class="keyword">ref</span>: const</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">6</span></span><br><span class="line">     filtered: <span class="number">16.67</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> index <span class="keyword">condition</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">2</span> warnings (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------</span></span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age<span class="operator">=</span><span class="number">24</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="number">1</span>\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: <span class="keyword">user</span></span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: <span class="keyword">ref</span></span><br><span class="line">possible_keys: idx_user_age_gender_status <span class="comment">-- 虽然只使用了两个字段条件，但查询还是使用了索引（符合最左原则，从最左边的age开始）</span></span><br><span class="line">          key: idx_user_age_gender_status</span><br><span class="line">      key_len: <span class="number">5</span></span><br><span class="line">          <span class="keyword">ref</span>: const</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">6</span></span><br><span class="line">     filtered: <span class="number">16.67</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> index <span class="keyword">condition</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">2</span> warnings (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------</span></span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> status<span class="operator">=</span><span class="number">1</span>\G; <span class="comment">-- 此次查询跳过了age，联合索引idx_user_age_gender_status，最左边的字段age没出现，故索引失效</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: <span class="keyword">user</span></span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: <span class="keyword">ALL</span>    <span class="comment">-- 全表查询</span></span><br><span class="line">possible_keys: <span class="keyword">NULL</span>   <span class="comment">-- 没有使用索引</span></span><br><span class="line">          key: <span class="keyword">NULL</span></span><br><span class="line">      key_len: <span class="keyword">NULL</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">6</span></span><br><span class="line">     filtered: <span class="number">16.67</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">2</span> warnings (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></div></li>
</ul>
<blockquote>
<p>关联字段必须存在，无顺序要求。</p>
</blockquote>
<h5 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h5><ul>
<li>在联合索引中，出现范围查询（&gt;，&lt; ）范围查询右侧的索引失效</li>
<li>在开发中，若业务允许应尽量使用 (&gt;&#x3D; 和 &lt;&#x3D;)<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--                                  age使用范围查询，所以age右侧的gender的索引失效</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;jack&#x27;</span> <span class="keyword">and</span> age <span class="operator">&gt;</span> <span class="number">23</span> <span class="keyword">and</span> gender<span class="operator">=</span><span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h5 id="索引列运算"><a href="#索引列运算" class="headerlink" title="索引列运算"></a>索引列运算</h5><ul>
<li>不要在索引列上进行运算操作，否则索引将失效<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--                                  对索引age进行函数运算，索引失效</span></span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="built_in">substring</span>(age, <span class="number">2</span>)<span class="operator">=</span><span class="number">4</span>\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: <span class="keyword">user</span></span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: <span class="keyword">ALL</span></span><br><span class="line">possible_keys: <span class="keyword">NULL</span>  </span><br><span class="line">          key: <span class="keyword">NULL</span>  <span class="comment">-- 没有使用索引</span></span><br><span class="line">      key_len: <span class="keyword">NULL</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">6</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h5 id="字符串不加单引号"><a href="#字符串不加单引号" class="headerlink" title="字符串不加单引号"></a>字符串不加单引号</h5><p>如果字符串类型的字段在查询时没有添加单引号，索引将会失效，例如</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在该表中 phone字段是 char类型，查询时应该加上单引号，否则索引将失效</span></span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> phone<span class="operator">=</span><span class="number">13456789001</span>\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: <span class="keyword">user</span></span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: <span class="keyword">ALL</span></span><br><span class="line">possible_keys: idx_phone <span class="comment">-- 可能用到的索引</span></span><br><span class="line">          key: <span class="keyword">NULL</span>      <span class="comment">-- 实际没有用到，因为发生了隐式类型转换</span></span><br><span class="line">      key_len: <span class="keyword">NULL</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">6</span></span><br><span class="line">     filtered: <span class="number">16.67</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br></pre></td></tr></table></figure></div>
<h5 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h5><p>在使用模糊查询时，如果 <code>%</code> 添加在尾部，那么索引不会失效，但如果是添加在头部，索引将会失效</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 通配符添加在最前面，索引失效</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> phone <span class="keyword">like</span> <span class="string">&#x27;%56789001&#x27;</span>;</span><br><span class="line"><span class="comment">-- 通配符添加在尾部，索引不会失效</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> phone <span class="keyword">like</span> <span class="string">&#x27;134%&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="or连接"><a href="#or连接" class="headerlink" title="or连接"></a>or连接</h5><p>用 <code>or</code> 分隔开的条件，如果 <code>or</code> 前的条件中的字段有索引，而后面的字段没有索引，那么涉及的索引都不会被用到，只有 <code>or</code> 两侧的字段都有索引时，索引才会生效 </p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 本表中 phone有建立索引，name则没有建立索引，此次查询将不会用到索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> phone<span class="operator">=</span><span class="string">&#x27;13456789001&#x27;</span> <span class="keyword">or</span> name<span class="operator">=</span><span class="string">&#x27;jack&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- id 跟 phone 都有索引，此次查询使用了索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> phone<span class="operator">=</span><span class="string">&#x27;13456789001&#x27;</span> <span class="keyword">or</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="数据分布影响"><a href="#数据分布影响" class="headerlink" title="数据分布影响"></a>数据分布影响</h5><p>如果mysql评估使用索引比全表扫描慢，那么将不使用索引。当表中数据绝大部分满足查询条件时，mysql便会放弃索引使用全表扫描。<br>例如，一张用户表中有70%的用户数据的年龄大于20，这时，如果我们查找年龄大于20的数据时，mysql会放弃索引（年龄字段建立了索引），使用全表扫描，因为mysql评估得到查询的结果占全表的绝大部分。而如果是查询年龄小于20的才会使用索引。</p>
<blockquote>
<p>是否用索引是根据表中数据分布情况来决定的，<mark style="background: #FF5582A6;">当查询的数据占表数据的绝大部分就会放弃使用索引，反之使用索引</mark></p>
</blockquote>
<h5 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h5><p>在SQL语句中加入一些提示来达成优化操作的目的。</p>
<ol>
<li>use index：建议使用指定索引，实际使用哪个由mysql评估，不一定使用</li>
<li>ignore index：忽略指定索引</li>
<li>force index：强制使用指定索引</li>
</ol>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询表 table_name 时 建议使用索引 index_name</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name use index(index_name);</span><br><span class="line"><span class="comment">-- 查询表时忽略指定索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name ignore index(index_name);</span><br><span class="line"><span class="comment">-- 查询表时强制使用指定索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name force index(index_name);</span><br></pre></td></tr></table></figure></div>

<h5 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h5><p>查询过程中使用了索引，且此次查询需要返回的数据所对应的字段在该索引中已经全部找到</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 本表username与password建立了联合索引 idx_username_password</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 本条SQL查询到的结果在索引中已全部找到，不需要回表查询</span></span><br><span class="line"><span class="keyword">select</span> id,username,password <span class="keyword">from</span> account <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;kita&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 本条SQL查询到的结果只有 id, username, password在索引中找到</span></span><br><span class="line"><span class="keyword">select</span> id,username,password,age,address <span class="keyword">from</span> account <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;kita&#x27;</span>; <span class="comment">-- 不适用覆盖索引，因为联合索引idx_username_password不全覆盖select选择的的字段 age和address。这两个的值还是需要根据叶子节点挂的id进行回表查询</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>当二级索引中的数据包含了查询所需要的数据时将直接返回，就不在聚集索引（主键）再找一遍了。<br>需要注意的是：当索引不全覆盖select选择的字段以及where条件中对索引进行like等操作时，此次查询不使用覆盖索引。</p>
</blockquote>
<h5 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h5><p>当字段类型为字符串（varchar，text等）时，有时候字符串很长，建立索引会让索引变得很大。查询时浪费磁盘IO，影响效率，此时我们可以把字符串的一部分前缀抽出出来建立索引从而节省索引空间，提高查询效率。<br>使用： <code>CREATE INDEX index_name ON table_name(COLUMN(截取长度))</code> 建立前缀索引<br>前缀长度根据索引的选择性来决定。选择性指不重复的索引值与表中数据的比（不重复的值 &#x2F; 总数据）索引值越高查询效率越高，若字段有唯一约束则选择性为1，是最好的索引选择性，性能最好。索引的选择性可以使用公式计算</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 可以多次尝试此公式查看结果选择一个结果最接近1，且截取长度较低的值</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(<span class="number">1</span>, 截取长度)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>
<p><strong>前缀索引查询流程</strong><br>假设下列语句中 <code>comment</code> 关联了前缀索引</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> comment<span class="operator">=</span><span class="string">&#x27;传入的字符串内容&#x27;</span></span><br></pre></td></tr></table></figure></div>
<p>上述SQL先查询二级索引取聚集索引值，再去聚集索引取<code>行数据A</code>，然后从<code>行数据A</code>拿出 <code>comment</code> 字段值与传递进来的 <code>传入的字符串内容</code> 匹配。然后通过叶子节点链表查下一<code>行数据B</code>再匹配 <code>comment</code> 如果匹配不成功则返回<code>行数据A</code>如果行数据B也匹配成功则再拿下一行的数据再匹配，直到下一行数据匹配失败，再组装所有行数据并返回</p>
<h5 id="单列索引与联合索引的选择"><a href="#单列索引与联合索引的选择" class="headerlink" title="单列索引与联合索引的选择"></a>单列索引与联合索引的选择</h5><ul>
<li>单列索引：一个索引只关联了一个字段（列）</li>
<li>联合索引：一个索引关联了多个字段（列）</li>
</ul>
<p>单列索引和联合索引的选择应根据业务场景决定。例如：有张表学生表记录学生信息有字段<code>name</code> <code>age</code>。在一般情况下，<code>name</code> 的数据重复度会较低，而 <code>age</code> 的重复度会较高。现有查询语句 <code>select * from students where name=&#39;jack&#39; and age=18;</code> 则</p>
<ul>
<li>name和age单独建立索引：一般来说，mysql会选择其中一个，name的可能性会较大。因为mysql会统计每个索引上的重复度，优先选用低重复读的字段。而且为了维护索引的开销，此时 age 字段的索引可以不用创建</li>
<li>name和age创建了联合索引：切合度最好，mysql会直接选用这个索引，但索引维护成本较大一些。索引占用的存储空间也会大些</li>
</ul>
<p>在业务场景中，如果存在多个查询条件，建议使用联合索引</p>
<h3 id="索引创建的原则"><a href="#索引创建的原则" class="headerlink" title="索引创建的原则"></a>索引创建的原则</h3><ol>
<li>针对与数据量较大，且查询频率比较频繁的表建立索引</li>
<li>针对常作为 查询条件(where) 、分组(group by)、排序(order by) 操作的字段建立索引</li>
<li>尽量选择区分度高的字段建立索引，尽量建立唯一索引，区分度越高，索引效率越高</li>
<li>如果是字符串类型的字段，建议使用前缀索引</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，提高查询效率，避免回表。</li>
<li>要控制索引数量，索引不是越多越好，索引越多，维护索引结构的代价也越大，会影响增删改的效率</li>
<li>如果索引字段不能存储null值，应该在建表时对该字段使用 not null 约束。当优化器知道每个字段是否包含null值时。可以更好确定使用哪个索引效率更高。</li>
</ol>
<h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="插入数据优化"><a href="#插入数据优化" class="headerlink" title="插入数据优化"></a>插入数据优化</h3><ul>
<li><p>批量插入：通常的数据插入方法是 <code>INSERT INTO table_name (字段名...) values (对应的值...)</code>。这是单次插入数据。每一次的插入操作都需要建立网络连接，数据库IO操作，SQL语句的解析。很明显这样效率与性能是很低的。面对大量的数据，应该使用批量插入 <code>INSERT INTO table_name (字段名...) values (对应的值1),(对应的值2)...</code> 当然批量插入的数据量也不应该太大，可以将其分割开分次插入。每次插入500到1000条数据。每次不建议超过1000条。</p>
</li>
<li><p>手动事务提交：建议手动提交事务。mysql默认是自动提交事务的，这样做会在数据插入时频繁地开启事务，建议在执行完插入语句全部完成后再统一提交事务</p>
</li>
<li><p>主键顺序插入：在执行插入语句时，<mark style="background: #FFB86CA6;">主键顺序插入性能高于乱序插入</mark>。建议按主键的顺序插入数据。</p>
</li>
<li><p>大批量的数据插入：如果一次性需要插入大量的数据，使用 <code>INSERT</code> 插入性能较低。此时可以使用 <code>LOAD</code> 指令进行插入</p>
</li>
</ul>
<p>假设有本地数据文件，其内容如下</p>
<div class="highlight-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">1,jack1,24,班级名称</span><br><span class="line">2,jack2,24,班级名称</span><br><span class="line">3,jack3,24,班级名称</span><br><span class="line">4,jack4,24,班级名称</span><br><span class="line">....</span><br></pre></td></tr></table></figure></div>
<p>有张表，其结构如下</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> age <span class="operator">|</span> classname <span class="operator">|</span></span><br></pre></td></tr></table></figure></div>
<p>mysql加载此文件导入文件内容到数据库</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在客户端连接mysql时加上参数 --local--infine</span></span><br><span class="line"><span class="comment">-- 开启从本地加载文件导入数据</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infine<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 加载文件数据到mysql</span></span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;要加载的本地数据文件路径&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> `tb_sku` fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>fields terminated by &#39;,&#39;</code> ：表示加载的每行数据，其字段使用 <code>,</code> 分隔</li>
<li><code>lines terminated by &#39;\n&#39;;</code>：表示每行数据使用 <code>\n</code> 分割，也就是换行分隔</li>
</ul>
<h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p>在InnoDB存储引擎中，表数据都是根据<mark style="background: #ADCCFFA6;">主键顺序</mark>组织存放的，这种存储方式的表成为存储组织表(Index organized table IOT)， <a href="/mysql-note/mysql%E7%AC%94%E8%AE%B02/../#%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">查看InnoDB的逻辑存储结构</a></p>
<h4 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h4><ul>
<li><p>按主键顺序插入数据时，页的情况如下图<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/22/kQvb3GMrU16wtSy.png"
                      alt="顺序插入流程.png"
                ></p>
</li>
<li><p>当非顺序插入时，因叶子节点是有序的。所以会开辟一个新的页<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/22/DNg3t7ICrcEke8K.png"
                     
                ><br>开辟新空间后，会将原本要入的页的50%取出，再跟传值一起插入新页中<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/22/cL25e4OaKhtSDz9.png"
                     
                ><br>这种现象称为页分裂，会比较消耗性能</p>
</li>
</ul>
<h4 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h4><p>当删除一行数据记录时，实际上并没有被物理删除，只是被标记(flaged) 为删除，同时允许其他记录使用该空间。当页中的标记删除记录超过 <code>MERGE_THRESHOLD</code> (默认为页的50%)时，InnoDB就会开始寻找相邻的两个页。查看是否满足合并的条件。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/22/djlzIMOEHypLv7g.png"
                      alt="="
                ><br>当满足合并的条件时，InnoDB就会合并符合条件的表，如上图，会将3号页的数据移动到2号页</p>
<h4 id="主键的设计原则"><a href="#主键的设计原则" class="headerlink" title="主键的设计原则"></a>主键的设计原则</h4><ul>
<li>在满足业务需求的情况下，我们尽量降低主键的长度。因为虽然主键只有且只能有一个，其叶子节点挂着的是行数据，但二级索引有多个，而二级索引叶子节点挂着的是主键数据。</li>
<li>插入数据时，尽量使用顺序插入，选择使用 <code>AUTO_INCREMENT</code> 自增主键。</li>
<li>尽量不要使用UUID或自然字段做主键。此类字段值多为无序且长度长，如身份证号</li>
<li>在业务操作时，尽量避免对主键进行修改（修改逐渐需要更改索引结构，代价大）</li>
</ul>
<h3 id="order-by-优化"><a href="#order-by-优化" class="headerlink" title="order by 优化"></a>order by 优化</h3><ol>
<li>using filesort：通过表的索引，或全表扫描读取满足条件的数据行，然后在排行缓冲区SortBuffer中完成排序操作。所有不是通过索引直接返回的排序结果都叫 FileSort 排序</li>
<li>using index：通过有序索引顺序扫描直接返回有序数据，不需要额外的排序操作，效率较高。</li>
</ol>
<p>在使用order by排序时应尽量优化成 <code>using index</code>，优化方式为<mark style="background: #BBFABBA6;">给对应字段添加索引</mark>即可</p>
<p><strong>注意事项</strong></p>
<ul>
<li>若使用了联合索引，需保证所用索引排序方式都为 <code>asc</code> 升序（默认），否则在排序时非升序索引会再排序一次。如果想一个升序一个降序，可以再创建一个联合索引 <code>create index idx_f1_f2_ad on table_name(f1 asc, f2 desc);</code> 在创建索引时指定索引的排序方式。</li>
<li>排序若多字段使用了联合索引，也应该遵循 <code>左前缀法则</code></li>
<li>尽量使用覆盖索引，避免 <code>select *</code></li>
<li>如果不可避免地出现了 <code>using filesort</code> 即此次排序还是要到排序缓冲区中操作。那我们可以适当增加缓冲区 <code>sort_buffer_size</code> (默认256k)的大小</li>
</ul>
<h3 id="group-by-优化"><a href="#group-by-优化" class="headerlink" title="group by 优化"></a>group by 优化</h3><ul>
<li>分组操作时，索引的使用也需要遵循最左前缀法则</li>
<li>若没有使用索引进行分组，会使用到临时表。</li>
</ul>
<h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p>在分页查询数据时，如果数据量特别大，有千万级别，那么使用<br><code>select * from tb_name limit 9000000,10;</code> 耗时会很长，且使用此方法需要mysql排序前9000010条的记录，但只是返回 9000000 - 9000010的记录，其他记录丢弃，代价是非常大的。<br>所以我们一般在分页查询时，可以创建覆盖索引提高性能。同时使用覆盖索引加子查询的形式进行优化。如下</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sku.<span class="operator">*</span> <span class="keyword">from</span> tb_sku sku, (<span class="keyword">select</span> id <span class="keyword">from</span> tb_sku <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">9000000</span>,<span class="number">10</span>) a <span class="keyword">where</span> sku.id<span class="operator">=</span>a.id;</span><br></pre></td></tr></table></figure></div>
<p>在本例中，先查询9000000后10条数据的主键id（括号里的，查询结果作为临时表进行多表联查），然后再根据这些id去查详细数据。在建立索引的情况下，耗时只用了4秒（本人的开发环境下），而使用 传统的 <code>select * from tb_name limit 9000000,10;</code> 方法则用了快一分钟。所以在实际开发中，若数据量特大，应尽量使用覆盖索引加子查询的方式进行分页查询。</p>
<h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><ul>
<li>MyISAM引擎会把表的总行数记录在磁盘上，执行<code>count(*)</code>时直接放回这个数。前提是查询时没有where条件。</li>
<li>InnoDB引擎在进行 <code>count(*)</code> 操作时，会把数据一行一行读出来然后进行累计计数，在特大数据量的情况下很明显是非常耗时不高效的。对于 <code>count</code> 的优化。<blockquote>
<p>优化方式：自己计数，自己维护一个值，增删时更改这个值。</p>
</blockquote>
</li>
</ul>
<p>COUNT的几种用法</p>
<ul>
<li>COUNT(主键)：InnoDB引擎会遍历整张表，把每一行的主键id值取出来，然后服务层进行累加</li>
<li>COUNT(字段)：<ul>
<li>not null：InnoDB会遍历表去每一行的字段值，服务层再进行累加</li>
<li>null：InnoDB会遍历表去每一行的字段值，服务层判断是否为null，非null再累加</li>
</ul>
</li>
<li>COUNT(1)：InnoDB遍历整张表，但不取值。服务层对于返回的每一行。放一个数字 <code>1</code> 进去，直接按行进行累加。</li>
<li>COUNT(*)： InnoDB不会把每一行值全部字段都取出来，会进行优化，不取值。服务层直接按行累加</li>
</ul>
<p>按照效率对上述用法排序的话由高到低分别是 COUNT(*) ~&#x3D; COUNT(1) &gt; COUNT(主键) &gt; COUNT(字段)，在开发中应尽量使用  <code>COUNT(*)</code></p>
<h3 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h3><p>InnoDB的行锁时真多索引加的锁，不是针对记录的。若索引失效，或不存在，行锁就会升级成表锁。<br>所以在执行 <code>UPDATE</code> 语句时应使用索引作为更新的条件，否则会导致 <mark style="background: #FFF3A3A6;">行锁</mark> 升级为 <mark style="background: #FFB86CA6;">表锁</mark>。锁住整张表。</p>
<h2 id="视图-x2F-存储过程-x2F-触发器"><a href="#视图-x2F-存储过程-x2F-触发器" class="headerlink" title="视图&#x2F;存储过程&#x2F;触发器"></a>视图&#x2F;存储过程&#x2F;触发器</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><blockquote>
<p>视图是一种虚拟存在的表，视图中的数据并不存在与数据库中，行和列来自 <mark style="background: #FFB86CA6;">定义视图的查询中使用的表</mark>。且是使用时动态生成。<br>简单地说就是，视图只保存查询SQL的逻辑。不保存查询结果</p>
</blockquote>
<ul>
<li>创建视图：<code>CREATE [OR REPLACE] VIEW view_name AS SELECT语句 [WITH[CASCADED|LOCAL] CHECK OPTION]</code></li>
<li>查询视图<ul>
<li>查看视图创建语句：<code>SHOW CREATE VIEW view_name;</code></li>
<li>查询视图数据：视图是一种虚拟存在的表，所以和查询表一样使用 select 即可</li>
</ul>
</li>
<li>修改视图：与创建视图语句一样，只不过必须带上 <code>OR REPLACE</code></li>
<li>删除视图：<code>DROP VIEW [IF EXISTS] view_name....</code></li>
</ul>
<h4 id="检查选项-CASCADED"><a href="#检查选项-CASCADED" class="headerlink" title="检查选项(CASCADED)"></a>检查选项(CASCADED)</h4><ul>
<li>当创建视图时添加 <code>WITH CHECK OPTION</code> 子句，Mysql会通过视图检查正在更改的每个行，例如插入，更新，删除，使其符合视图的定义。例如：使用语句 <code>CREATE OR REPLACE VIEW user_v AS SELECT id,name,age FROM user WHERE age &gt; 24 WITH CASCADED CHECK OPTION;</code>创建视图。如果我们往这个视图插入数据 <code>INSERT INTO user_v values(10,&#39;jack&#39;,30);</code> 此时会插入失败，因为values的 <code>age</code> 字段值大于24，超出了视图 <code>user_v</code> 的定义。 </li>
<li>视图的创建是可以套娃的，一个视图可以基于另一个视图创建，例如<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name_2 <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> view_name_1 <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">WITH</span> <span class="keyword">CASCADED</span> <span class="keyword">CHECK</span> OPTION;</span><br></pre></td></tr></table></figure></div>
前面说过对进行增删改操作时，mysql会判断是否符合视图的定义。同时也会检查依赖视图（view_name_1）的规则。为了去顶检查范围。mysql提供了两个选项 <code>CASCADED</code> 和 <code>LOCAL</code><ul>
<li><code>CASCADED</code>：为默认值，表示更新视图时要满足所有相关视图和表的条件</li>
<li><code>LOCAL</code>：表示更新视图时满足该视图本身定义的条件即可</li>
</ul>
</li>
</ul>
<h4 id="作用和特点"><a href="#作用和特点" class="headerlink" title="作用和特点"></a>作用和特点</h4><ul>
<li><p>视图的列可以来自不同的表，是表的抽象和逻辑意义上建立的新关系</p>
</li>
<li><p>视图是由基本表（实表）产生的表（虚表）</p>
</li>
<li><p>视图的建立和删除不影响基本表</p>
</li>
<li><p>对视图内容的更新（增删改）直接影响基本表</p>
</li>
<li><p>当视图来自多个基本表，不允许添加和删除数据</p>
</li>
<li><p>表的安全：数据库可以授权，但不能授权到表中的特定列和行。通过视图可以让用户只能查询修改他们所能见到的数据。</p>
</li>
<li><p>数据独立：视图可以帮助用户屏蔽真实表的结构变化带来的影响</p>
</li>
<li><p>例子</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 定义一个视图，查询学生与选课信息，三表联查。</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> view_user_course <span class="keyword">as</span> <span class="keyword">select</span> u.name <span class="string">&#x27;学生&#x27;</span>, c.name <span class="string">&#x27;选修的课&#x27;</span> <span class="keyword">from</span> <span class="keyword">user</span> u, course c, user_course uc <span class="keyword">where</span> uc.userId <span class="operator">=</span> u.id <span class="keyword">and</span> uc.courseId <span class="operator">=</span> c.id;  </span><br><span class="line"><span class="comment">-- 定义视图之后，我们直接使用下面这个语句就可以了，就不用写三表联查的语句了</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> view_user_course;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<blockquote>
<p>个人觉得有点像现在很多app都有的青少年模式，限制一些功能给其他人用，想修改数据就必须遵守视图的规则</p>
</blockquote>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>存储过程时实现经过编译并存储在数据库中的一段SQL语句集合，我们可以直接调用这个存储过程以简化开发人员的工作。减少数据在数据库与应用服务器之间的传输。简单地说就是SQL语句的封装与重用。</p>
<ul>
<li>特点：SQL封装与复用，且可以传入参数与返回参数，减少网络交互，效率提升。</li>
</ul>
<blockquote>
<p>类似Java的封装</p>
</blockquote>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> getUser(userId <span class="type">INT</span>)  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> userId;  </span><br><span class="line"><span class="keyword">END</span>;  </span><br><span class="line"><span class="comment">-- 使用  </span></span><br><span class="line"><span class="keyword">CALL</span> getUser(<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 查看指定表有哪些存储过程  </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema..ROUTINES <span class="keyword">WHERE</span> ROUTINE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;要查看的表名&#x27;</span>；  </span><br><span class="line"><span class="comment">-- 查看创建语句  </span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_user_course;  </span><br><span class="line"><span class="comment">-- 删除存储过程  </span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span> procedure_name;</span><br></pre></td></tr></table></figure></div>

<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当前会话的系统变量  </span></span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES;  </span><br><span class="line"><span class="comment">-- 查看以auto开头的全局系统变量，  </span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;auto%&#x27;</span>;  </span><br><span class="line"><span class="comment">-- 精准查看全局变量 autocommit</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.autocommit;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置当前会话的系统变量  </span></span><br><span class="line"><span class="keyword">SET</span> SESSION 系统变量名<span class="operator">=</span>值</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用户变量赋值</span></span><br><span class="line"><span class="keyword">SET</span> @变量名<span class="operator">=</span>值...;  <span class="comment">-- 可以一次性设置多个变量</span></span><br><span class="line"><span class="keyword">SET</span> @变量名 :<span class="operator">=</span> 值;  </span><br><span class="line"><span class="keyword">SELECT</span> @变量名 :<span class="operator">=</span> 值;  </span><br><span class="line"><span class="comment">-- 将查询结果赋值给变量  </span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">INTO</span> @变量名 <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="comment">-- 使用</span></span><br><span class="line"><span class="keyword">SELECT</span> @变量名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 局部变量，访问前需要用DECLARE声明。可作为存储过程和输入参数，其作用域在定义变量的存储过程中</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p1()  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line">    <span class="comment">-- DECLARE 变量名 变量类型 DEFAULT 默认值；  </span></span><br><span class="line">    <span class="keyword">DECLARE</span> a <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;  </span><br><span class="line">    <span class="comment">-- 赋值,赋值与用户变量赋值一样  </span></span><br><span class="line">    <span class="keyword">SET</span> a <span class="operator">=</span> <span class="number">2</span>;  </span><br><span class="line">    <span class="comment">-- 局部变量的作用与为存储过程p1里，超出p1就失效  </span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><p>if判断没啥好说的</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p2()  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line">    IF 条件<span class="number">1</span> <span class="keyword">THEN</span>  </span><br><span class="line">        <span class="comment">-- SQL语句  </span></span><br><span class="line">    ELSEIF 条件<span class="number">2</span> <span class="keyword">THEN</span>  </span><br><span class="line">        <span class="comment">-- SQL语句  </span></span><br><span class="line">    <span class="keyword">ELSE</span>  </span><br><span class="line">        <span class="comment">-- SQL语句  </span></span><br><span class="line">    <span class="keyword">END</span> IF;  </span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>设置时若没有指定 SESSION 或 GLOBAL 默认将会是 SESSION<br>mysql重启后所有设置的系统变量将失效，若想永久有效 可更改 my.cnf 文件</p>
</blockquote>
<h4 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h4><p>用户变量不用提前声明，在用的时候使用 <code>@变量名</code> 即可。其作用域为当前会话连接</p>
<h4 id="存储过程的参数"><a href="#存储过程的参数" class="headerlink" title="存储过程的参数"></a>存储过程的参数</h4><p>存储过程的参数除了数值类型外，还有一个参数类型</p>
<ul>
<li>IN：传入参数，调用时需要传入（默认）</li>
<li>OUT：该参数可以作为返回值</li>
<li>INOUT：该参数既是传入参数也可以做返回值</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p3([<span class="keyword">IN</span><span class="operator">/</span><span class="keyword">OUT</span><span class="operator">/</span><span class="keyword">INOUT</span>] arg INT...)  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line">    <span class="comment">-- SQL逻辑  </span></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p3(<span class="keyword">IN</span> arg1 <span class="type">INT</span>, <span class="keyword">OUT</span> arg2 <span class="type">VARCHAR</span>(<span class="number">10</span>))  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line">	IF arg1 <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">THEN</span></span><br><span class="line">		<span class="keyword">SET</span> arg2 <span class="operator">=</span><span class="string">&#x27;返回值&#x27;</span>;</span><br><span class="line">	<span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="comment">-- 调用</span></span><br><span class="line"><span class="keyword">CALL</span> p3(<span class="number">11</span>, <span class="variable">@RESULT</span>); <span class="comment">-- @RESULT 接受p3返回结果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@RESULT</span> <span class="comment">-- 查看结果</span></span><br></pre></td></tr></table></figure></div>

<h4 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h4><blockquote>
<p>类似Java的 <code>switch</code></p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p4(<span class="keyword">month</span> <span class="type">int</span>)  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>);  </span><br><span class="line">    <span class="keyword">CASE</span></span><br><span class="line">	    <span class="keyword">WHEN</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="keyword">SET</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;一月&#x27;</span>;  </span><br><span class="line">        <span class="keyword">WHEN</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="keyword">SET</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;二月&#x27;</span>;  </span><br><span class="line">        <span class="keyword">WHEN</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="number">3</span> <span class="keyword">THEN</span> <span class="keyword">SET</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;三月&#x27;</span>;</span><br><span class="line">        <span class="keyword">ELSE</span> <span class="keyword">SET</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;输入错误&#x27;</span>; <span class="comment">-- switch的default</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p>存储函数是<mark style="background: #FFF3A3A6;">有返回值的存储过程</mark> 存储函数的参数只能是 <code>IN</code> 类型的。语法如下</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> function_name (参数列表)  </span><br><span class="line"><span class="keyword">RETURNS</span> return_type [characteristic...]   <span class="comment">-- 返回类型  </span></span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line">    <span class="comment">-- SQL 语句  </span></span><br><span class="line">    <span class="keyword">RETURN</span> 返回值  </span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></div>

<p>characteristic（返回值特性）说明</p>
<ul>
<li>DETERMINISTIC：相同的输入参数总是产生相同的结果</li>
<li>NO SQL：不包含SQL语句</li>
<li>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句</li>
</ul>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><blockquote>
<p>与数据库表有关的数据库对象，在INSERT&#x2F;UPDATE&#x2F;DELETE之前或之后触发并执行触发器中定义的SQL语句集合。可以协助应用在数据端确保数据完整性，日志记录，数据校验等操作。</p>
</blockquote>
<ul>
<li>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容。触发器支支持行级触发，不支持语句触发（指一个SQL操作影响了5行数据，那么将触发5次）</li>
</ul>
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>NEW和OLD</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT触发器</td>
<td>NEW 表示新增数据</td>
</tr>
<tr>
<td>UPDATE触发器</td>
<td>OLD表示修改前的数据，NEW表示将要修改或修改后的数据</td>
</tr>
<tr>
<td>DELETE触发器</td>
<td>OLD表示将要删除或已删除的数据</td>
</tr>
</tbody></table>
<ul>
<li>创建触发器<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- user 插入数据前触发 BEFORE操作前触发 AFTER操作后触发。INSERT 可换UPDATE, DELETE</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="keyword">user</span> <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span>  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line">    <span class="comment">-- 触发器逻辑，当user插入新数据时，将插入数据的id与name字段保存到user_log表中</span></span><br><span class="line">    <span class="comment">-- NEW指插入user表的那行数据，因为这个是插入型触发器，UPDATE与DELETE的OLD同理</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_log <span class="keyword">VALUES</span> (NEW.id, NEW.name); </span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><blockquote>
<p>数据库里面的锁是基于索引实现的，在Innodb中我们的锁都是作用在索引上面的，当我们的SQL命中索引时，那么锁住的就是命中条件内的索引节点(行锁)，如果没有命中索引的话，那我们锁的就是整个索引树（表锁）</p>
</blockquote>
<ul>
<li>加锁：<code>LOCK TABLES 表名... READ/WRITE;</code></li>
<li>解锁：<code>UNLOCK TABLES / 客户端断开链接</code></li>
</ul>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><blockquote>
<p>锁定整个数据库中的所有表，<mark style="background: #FFB8EBA6;">加锁后mysql处于只读状态</mark>。对于DML&#x2F;DDL以及事务提交的操作都会被阻塞。一般用于数据库的全局备份</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 加全局锁（mysql命令行下）</span></span><br><span class="line">FLUSH TABLES <span class="keyword">WITH</span> READ LOCK;</span><br><span class="line"><span class="comment">-- 备份数据库，这个命令不是mysql的，用终端运行</span></span><br><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p密码 要备份的数据库名 <span class="operator">&gt;</span> 备份保存路径</span><br><span class="line"><span class="comment">-- 解锁 （mysql命令行下）</span></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>全局锁会导致增删改操作的阻塞。如果数据库设置了主从同步。我们备份是要在从库上进行（主库增删改，从库查询），但<mark style="background: #FFB86CA6;">备份期间是无法进行主从复制的</mark>，会导致主从延迟。</li>
<li>在InnoDB引擎中，我们可以在备份时附加参数 <code>--single-transaction</code> 来完成不加锁的一致性数据备份</li>
</ul>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><ul>
<li>共享锁又称读锁。当一个事务给数据加上读锁之后，其他事务只能对数据加读锁，不能对数据加写锁，直到所有读锁释放后才能加写锁<br>共享锁的作用是用于并发时的数据读取，读取数据时不允许修改。加锁期间任何操作只能读不能改</li>
</ul>
<h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><ul>
<li>排他锁又称写锁。当一个事务给数据加上写锁后，其他事务就不能添加任何锁，直到写锁释放。<br>排他锁的作用是在修改数据时不允许同时修改，也不允许读取。避免出现脏读和脏数据的问题。</li>
</ul>
<h3 id="元数据锁（Meta-Data-Lock，MDL）"><a href="#元数据锁（Meta-Data-Lock，MDL）" class="headerlink" title="元数据锁（Meta Data Lock，MDL）"></a>元数据锁（Meta Data Lock，MDL）</h3><p>MDL加锁过程是系统自动控制的，无需显示使用，在访问一张表时会自动加上。MDL锁的主要作用时维护表元数据（表结构）的一致性。在表有活动事务时，不可以对元数据进行更改操作。简单地说就是锁表的结构，当有客户端在增删改查表的时候，禁止修改表结构（添加删除字段等）</p>
<table>
<thead>
<tr>
<th>对应操作SQL</th>
<th>锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LOCK TABLES table_name READ&#x2F;WRITE</td>
<td>SHARED_READ_ONLY&#x2F;SHARED_NO_READ_ONLY</td>
<td></td>
</tr>
<tr>
<td>SELECT,SELECT …LOCK IN SHARE MODE</td>
<td>SHARED_READ</td>
<td>与EXCLUSIVE互斥</td>
</tr>
<tr>
<td>INSERT,UPDATE,DELETE,SELECT …FOR UPDATE</td>
<td>SHARED_WRITE</td>
<td>与EXCLUSIVE互斥</td>
</tr>
<tr>
<td>ALTER TABLE</td>
<td>EXCLUSIVE</td>
<td>与其他MDL互斥</td>
</tr>
</tbody></table>
<blockquote>
<p>SHARED_READ 和 SHARED_WRITE 是互相兼容的</p>
</blockquote>
<ul>
<li>查看表的元数据锁，通过此语句可以查看当前mysql有哪些元数据锁<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> OBJECT_TYPE,OBJECT_SCHEMA,OBJECT_NAME,LOCK_TYPE,LOCK_DURATION <span class="keyword">FROM</span> performance_schema.metadata_locks;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------------+----------------+---------------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> OBJECT_TYPE <span class="operator">|</span> OBJECT_SCHEMA      <span class="operator">|</span> OBJECT_NAME    <span class="operator">|</span> LOCK_TYPE           <span class="operator">|</span> LOCK_DURATION <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------------+----------------+---------------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">TABLE</span>       <span class="operator">|</span> test               <span class="operator">|</span> <span class="keyword">user</span>           <span class="operator">|</span> SHARED_WRITE        <span class="operator">|</span> TRANSACTION   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCHEMA      <span class="operator">|</span> test               <span class="operator">|</span> <span class="keyword">NULL</span>           <span class="operator">|</span> INTENTION_EXCLUSIVE <span class="operator">|</span> TRANSACTION   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">TABLE</span>       <span class="operator">|</span> test               <span class="operator">|</span> class          <span class="operator">|</span> SHARED_READ         <span class="operator">|</span> TRANSACTION   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">TABLE</span>       <span class="operator">|</span> performance_schema <span class="operator">|</span> metadata_locks <span class="operator">|</span> SHARED_READ         <span class="operator">|</span> TRANSACTION   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------------+----------------+---------------------+---------------+</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><ul>
<li>指上锁时锁住整张表，即锁住整个索引树。当其他事务访问该表时，必须等待加锁的事务释放锁。<mark style="background: #BBFABBA6;">加锁粒度大，但容易冲突</mark></li>
</ul>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><ul>
<li>指上锁时锁住表的某一行或某几行记录。其他事务访问表时，只有加锁的几行记录不能访问，其他是可以访问的。加锁粒度小，不容易冲突，相比表锁支持的并发要高些</li>
</ul>
<table>
<thead>
<tr>
<th>SQL操作</th>
<th>行锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>UPDATE</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>DELETE</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>SELECT</td>
<td>不加锁</td>
<td></td>
</tr>
<tr>
<td>SELECT…LOCK IN SHARE MODE</td>
<td>共享锁</td>
<td>手动加锁，添加LOCK IN SHARE MODE</td>
</tr>
<tr>
<td>SELECT…FOR UPDATE</td>
<td>排他锁</td>
<td>手动枷锁，添加FOR UPDATE</td>
</tr>
</tbody></table>
<ul>
<li>因为InnoDB是根据索引来加锁的，如果SQL语句 WHERE 后面的条件没有使用索引字段，那么行锁就会升级成表锁。例如下面这样<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 如果name有关联字段那么mysql会给name=lily这行加锁，如果name没有关联字段，那么mysql就会给user表加表锁</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;jack&#x27;</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;lily&#x27;</span>;</span><br><span class="line"><span class="comment">-- 此时如果有其它事务操作 user表，操作其他的行数据，那么这个操作会被阻塞。</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;taka&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">-- 操作会被阻塞</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h3><ul>
<li>记录锁是行锁的一种，只不过其加锁范围是表中的某一条数据(只锁一条)，粒度精确条件命中，命中条件是唯一索引。<br>例如：<code>UPDATE user SET name=&#39;jack&#39; WHERE id=1;</code><br>记录所的作用是：加锁的数据可以避免数据在查询时被修改的重复读问题，也避免了脏读</li>
</ul>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><ul>
<li>间隙锁也是行锁的一种，其<mark style="background: #BBFABBA6;">锁定范围是表的某一个区间</mark>。当表的相邻id之间出现空隙就会形成一个区间，遵循左开右闭原则。例如表中有数据ID为 <code>1，3，5，7</code> 会形成以下区间 <code>(-infinity,1]</code> <code>(1,3]</code> <code>(3,5]</code> <code>(5,7]</code> <code>(7,infinity]</code></li>
<li>触发条件是范围查询且未命中，查询条件必须使用索引，例如 <code>SELECT * FROM user WHERE id &gt; 1 AND id &lt; 3 FOR UPDATE;</code> 很明显表中并没有满足条件的数据，这时就会使用间隙锁。间隙锁作用是解决在隔离等级为 <code>Repeatable Read(可重复读)</code> 级别下的幻读问题。</li>
<li>简单地所就是操作时给区间内不存在的数据加锁，防止其他事务插入数据到这些区间中出现幻读。</li>
</ul>
<h3 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h3><ul>
<li>临键锁也属于行锁的一种，是InnoDB的行锁默认算法，是记录锁和间隙锁的组合。锁的范围是行数据与区间</li>
<li>触发条件：范围查询且命中，查询使用了索引。例如 &#96;SELECT * FROM user WHERE id &gt; 5 AND id &lt;&#x3D; 7 FOR UPDATE;</li>
<li>作用：避免了在范围查询时出现脏读、重复读、幻读问题。加了临键锁之后，在范围区间内数据不允许被修改和插入</li>
<li>如果查询条件没有命中索引，那么临建锁会退化成间隙锁</li>
</ul>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><ul>
<li>在开发中我们会遇到这种情况，客户端A开启事务对表 <code>user</code> 执行 <code>UPDATE</code> 操作，此时mysql会自动给涉及的数据行添加 <code>行锁</code> 。此时事务还未提交，客户端B要给表 <code>user</code> 添加了表锁。这时候mysql会检查表的每一行，查看是否有行锁以及锁类型，这样效率明显是不高的。为了避免DML在执行时，加的行锁与表锁冲突。InnoDB引入了 <code>意向锁</code> 使表不用检查每行数据是否加锁，以此来减少对表的检查</li>
<li>意向共同共享锁（IS）：由语句SELECT … LOCK IN SHARE MODE</li>
<li>意向排他锁（IX）：由INSERT, UPDATE, DELETE, SELECT … FOR UPDATE添加</li>
<li><mark style="background: #ADCCFFA6;">描述是否可以对一个表进行加锁</mark></li>
</ul>
<p>举个栗子，假设行锁和表锁能够共存，事务A锁住了表中某一行，而事务B锁住了整张表。但这时你就会发现问题。事务A锁住了某一行，代表着其他事务不能修改这一行。而事务B锁住了表，代表着事务B能任意修改表中的任意一行。这与事务A的行锁发生了冲突。这是在没有意向锁的情况下。<br>那有意向锁了后，前面栗子中的事务A在申请行锁之前，mysql就会自动先给事务A申请表的意向排他锁。当事务B去申请表的写锁时就会失败被阻塞。<br>所以意向锁的作用是，当有一个事务申请给数据加锁时，如果</p>
<h2 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h2><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><p>InnoDB存储结构如下图<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/24/VlFQhOdW3TmkERn.png"
                      alt="a.png"
                ></p>
<blockquote>
<p>如上图所示，页中存储的是行数据，页可以为空，可以只填一部分，当然也可以全部填满。每个页包含了 <code>2-n</code> 行数据，根据据主键排列。</p>
</blockquote>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>InnoDB架构图如下<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://dev.mysql.com/doc/refman/8.0/en/images/innodb-architecture-8-0.png"
                     
                ></p>
<h4 id="内存结构（左侧）"><a href="#内存结构（左侧）" class="headerlink" title="内存结构（左侧）"></a>内存结构（左侧）</h4><h5 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h5><p>缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查时，先操作缓冲池中的数据（若缓冲池没有，就从磁盘加载并缓存）。然后再以一定频率刷新到磁盘，减少磁盘IO。<br>缓冲池以 <code>页（Page）</code> 为单位，底层采用链表数据结构管理Page。根据状态可分为三种类型</p>
<ul>
<li>free page：空闲page，未被使用</li>
<li>clean page：被使用page，数据没有被修改过</li>
<li>dirty page：脏页，被使用page，数据被修改过，且和磁盘中的数据不一致。</li>
</ul>
<h5 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h5><p>更改缓冲区（针对非唯一的二级索引页）在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据的变更存在更改缓冲区Change Buffer中。在未来读取数据时再将数据合并到BuffPool中，然后把合并后的数据刷入磁盘。</p>
<blockquote>
<p>Change Buffer的意义：与聚集索引不同，二级索引通常是非唯一，且是以相对随机的顺序插入的。同时删除和更新可能影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO浪费。而有了Change Buffer后就可以在缓冲池中进行合并处理再写入磁盘。减少IO</p>
</blockquote>
<h5 id="Log-Buffer"><a href="#Log-Buffer" class="headerlink" title="Log Buffer"></a>Log Buffer</h5><p>日志缓冲区：用来保存要写入磁盘中的log日志数据（redo log， undo log）。默认大小为 <code>16m</code>。日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入、删除许多行的事务，增加日志缓冲区的大小可以节省磁盘IO<br><code>innodn_log_buffer_size</code>：日志缓冲区大小<br><code>innodb_flush_log_at_trx_commit</code>：日志刷新到磁盘的时机<br>            - 值可选 <code>1</code> <code>0</code> <code>2</code><br>            - 1：日志在每次事务提交时写入并刷新磁盘<br>            - 0：每秒将日志写入并刷新到磁盘一次<br>            - 2：日志在每次事务提交后写入，并每秒刷新到磁盘一次</p>
<h5 id="Adaptive-Hash-Index"><a href="#Adaptive-Hash-Index" class="headerlink" title="Adaptive Hash Index"></a>Adaptive Hash Index</h5><p>自适应索引，用于优化对 <code>Buffer Pool</code> 数据的查询，InnoDB会监控表上各索引页的查询，如果观察到hash索引可以提升速度，则会自动建立hash索引。InnoDB根据情况自动完成</p>
<h4 id="磁盘结构（右侧）"><a href="#磁盘结构（右侧）" class="headerlink" title="磁盘结构（右侧）"></a>磁盘结构（右侧）</h4><h5 id="System-Tablespace"><a href="#System-Tablespace" class="headerlink" title="System Tablespace"></a>System Tablespace</h5><p>系统表空间是更改缓存区的存储区域。如果表是在系统表空间而不是每张表文件或通用表空间中创建的，它也可能包含表和索引的数据</p>
<ul>
<li>参数 <code>innodb_data_file_path</code>：指定innodb tablespace文件（.ibd）</li>
</ul>
<h5 id="File-Per-Table-Tablespaces"><a href="#File-Per-Table-Tablespaces" class="headerlink" title="File-Per-Table- Tablespaces"></a>File-Per-Table- Tablespaces</h5><p>每张表的独立表空间（默认开启），每个表的文件表空间包含单个InnoDB表的数据结构和索引，并存储在文件系统上的单个数据文件中</p>
<ul>
<li>参数 <code>innodb_file_per_table</code></li>
</ul>
<h5 id="General-Tablespaces"><a href="#General-Tablespaces" class="headerlink" title="General Tablespaces"></a>General Tablespaces</h5><p>通用表空间，需要通过 <code>CREATE TABLESPACE xxxx ADD DATAFILE &#39;file_name&#39; ENGINE=&#39;engine_name&#39;</code> 创建通用表空间，在创建表时可以指定该表空间 <code>CREATE TABLE xxx... TABLESPACE table_space_name;</code> 指定表空间后，这个表的数据就会存储在这个表空间中。</p>
<h5 id="Undo-Tablespaces"><a href="#Undo-Tablespaces" class="headerlink" title="Undo Tablespaces"></a>Undo Tablespaces</h5><p>撤销表空间：mysql在初始化时会自动创建两个默认的undo表空间（初始大小16m）用于存储undo log日志</p>
<h5 id="Temporary-Tablespaces"><a href="#Temporary-Tablespaces" class="headerlink" title="Temporary Tablespaces"></a>Temporary Tablespaces</h5><p>临时表空间，InnoDB使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p>
<h5 id="Doublewrite-Buffer-Files"><a href="#Doublewrite-Buffer-Files" class="headerlink" title="Doublewrite Buffer Files"></a>Doublewrite Buffer Files</h5><p>双写缓冲区，InnoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。磁盘文件为 <code>#ib_16384_0.dblwr</code> 和 <code>#ib_16384_1.dblwr</code></p>
<h5 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h5><p>重做日志，是用来实现事务的持久性。该日志由两部分组成。</p>
<ol>
<li>重做日志缓冲（redo log buffer）在内存中</li>
<li>重做日志文件（redo log）在磁盘中<br>当事务提交之后就会把所有修改信息都存到该日志中，用于在刷新脏页和磁盘时发生错误时，进行数据恢复。涉及的文件 <code>ib_logfile0</code> 和 <code>ib_logfile1</code></li>
</ol>
<h5 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h5><p>作用是在合适的时机，将缓冲池的数据刷入磁盘</p>
<h6 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h6><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中，保持数据一致性。也包括脏页刷新，合并插入缓存，undo页的回收</p>
<h6 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h6><p>InnoDB大量使用了AIO（Async IO 异步非阻塞IO）来处理IO请求。而IO Thread主要负责这些IO请求的回调</p>
<table>
<thead>
<tr>
<th>线程类型</th>
<th>默认数量</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Read Thread</td>
<td>4</td>
<td>负责读操作</td>
</tr>
<tr>
<td>Write Thread</td>
<td>4</td>
<td>负责写操作</td>
</tr>
<tr>
<td>Log Thread</td>
<td>1</td>
<td>负责将日志缓冲区刷新到磁盘</td>
</tr>
<tr>
<td>Insert Buffer Thread</td>
<td>1</td>
<td>负责将写缓冲区刷新到磁盘</td>
</tr>
</tbody></table>
<h6 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h6><p>主要用于回收事务已提交的undo log，事务提交后，undo log可能不用了，所以此线程就回收掉</p>
<h6 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h6><p>协助Master Thread刷新脏页到磁盘的线程，减轻Master Thread的压力，减少阻塞</p>
<h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h3><blockquote>
<p>事务有四大特性： 原子性，一致性，持久性，隔离性。其中原子性，一致性，持久性是由 <code>redo log</code> 和 <code>undo log</code> 来实现的。而隔离性是通过 <code>锁</code> 和 <code>mvcc(多版本并发控制)</code> 来实现的<br>原子性：undo log<br>持久性：redo log<br>一致性：undo log + redo log<br>隔离性：mvcc + 锁</p>
</blockquote>
<h4 id="Redo-Log-1"><a href="#Redo-Log-1" class="headerlink" title="Redo Log"></a>Redo Log</h4><p>重做日志记录的是事务提交时的物理修改，是<mark style="background: #ABF7F7A6;">用来实现事务持久性</mark>的。该日志文件由两部分组成：重做日志缓冲（redo log buffer）和重做日志文件（redo log file），前者在内存中，后者在磁盘中。当事务提交后会把所有的修改信息都存到日志文件中</p>
<h4 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h4><ul>
<li>回滚日志，用于记录数据被修改前的信息。作用：<mark style="background: #BBFABBA6;">提供回滚</mark> and <mark style="background: #BBFABBA6;">MVCC</mark><br>undo log 和 redo log记录物理日志不一样，它是逻辑日志。例如：当你执行完一条DELETE语句删除一条数据后，undo log会记录一条对应的INSERT记录。就是与你操作相反的记录。当执行回滚时，就可以从undo log里读取相应记录并回滚。</li>
<li>undo log销毁：在事务执行时产生，事务提交后不会立刻删除，会检查undo log的记录是否涉及到mvcc（具体查看下方mvcc）</li>
<li>undo log存储：undo log采用段的方式进行管理和记录。存放在 rollback segment 回滚段中，内部包含 1024 个undo log segment</li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><ul>
<li><p>当前读：读取的记录是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录加锁。如：select … lock in share mode(共享锁)，select… for update，insert，update，delete(排他锁)都是一种当前读</p>
</li>
<li><p>快照读：正常的select（不加锁）就是快照读，读取的是记录数据的可见版本，有可能额是历史数据。不加锁，所以是非阻塞读。</p>
<ul>
<li>Read committed：每次select都生成一个快照读</li>
<li>Repeatable read：开启事务后第一个select语句才是快照读</li>
<li>Serializable：快照读会退化为当前读</li>
</ul>
</li>
<li><p>MVCC：多版本并发控制。指维护一个数据的多个版本，是的读写操作没冲突，快照读为mysql实现mvcc提供了非阻塞功能。具体实现依赖于：三个隐式字段，undo log日志、readView</p>
</li>
<li><p>三个隐藏字段：我们创建表的时候除了我们自己的业务字段，InnoDB还会添加三个隐式字段，分别是 <code>DB_TRX_ID</code> <code>DB_ROLL_PTR</code> <code>DB_ROW_ID</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>DB_TRX_ID</td>
<td>最近修改事务ID，最后一次修改此记录的事务ID</td>
</tr>
<tr>
<td>DB_ROLL_PTR</td>
<td>回滚指针，指向这条记录的上一个版本，用于配合undo log</td>
</tr>
<tr>
<td>DB_ROW_ID</td>
<td>隐藏主键，若用户没有指定主键，则会生成这个隐藏字段当主键</td>
</tr>
</tbody></table>
<h5 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h5><p>前面讲到，undo log的作用是操作发生错误时能够进行数据回滚。<br>当INSERT时，产生的undo log只在回滚时需要，事务提交后可以立刻删除<br>而当UPDATE，DELETE时，产生的undo log日志不仅在回滚时需要，在快照读时也需要。所以不会立刻被删除</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/24/CWXGHETSdtfqzgV.png"
                      alt="image.png"
                ></p>
<h5 id="read-view"><a href="#read-view" class="headerlink" title="read view"></a>read view</h5><p>读视图，是快照读SQL执行时MVCC数据提取的依据，记录并维护系统当前活跃事务（未提交的）的ID</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>m_ids</td>
<td>当前活跃事务的ID集合</td>
</tr>
<tr>
<td>min_trx_id</td>
<td>最小活跃事务ID</td>
</tr>
<tr>
<td>max_trx_id</td>
<td>预分配事务ID, 当前最大事务ID+1</td>
</tr>
<tr>
<td>creator_trx_id</td>
<td>ReadView创建者的事务ID</td>
</tr>
</tbody></table>
<ul>
<li>版本访问规则<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/24/5Duo2kKPCUjfLv9.png"
                     
                ></li>
</ul>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-MyBatis-Plus</title>
    <url>/myBatis-Plus/Mybatis-Plus/</url>
    <content><![CDATA[<h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a><strong>快速使用</strong></h2><p>​	MybatisPlus为我们提供了非常强大的接口来供我们对数据库进行增删改查操作,我们无需写sql语句,只需调用对应接口即可.</p>
<h3 id="引入maven坐标"><a href="#引入maven坐标" class="headerlink" title="引入maven坐标"></a>引入maven坐标</h3><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="编写实体类"><a href="#编写实体类" class="headerlink" title="编写实体类"></a>编写实体类</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">//@TableName  指定这个实体类在操作时影响哪张表</span></span><br><span class="line"><span class="meta">@TableName(&quot;tb_users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEntity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> telephone;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> duties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="编写Mapper接口"><a href="#编写Mapper接口" class="headerlink" title="编写Mapper接口"></a>编写Mapper接口</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;UserEntity&gt; &#123;</span><br><span class="line">    <span class="comment">//只需要让我们的Mapper接口继承 BaseMapper并给他对应实体类即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTestData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">UserEntity</span> <span class="variable">ue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserEntity</span>();</span><br><span class="line">    ue.setUsername(<span class="string">&quot;eoezora&quot;</span>);</span><br><span class="line">    ue.setPassword(<span class="string">&quot;a-test-password&quot;</span>);</span><br><span class="line">    ue.setAge(<span class="number">24</span>);</span><br><span class="line">    ue.setTelephone(<span class="number">1145141919</span>);</span><br><span class="line">    ue.setDuties(<span class="number">1</span>);</span><br><span class="line">    userMapper.insert(ue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserEntity&gt; <span class="title function_">getAllData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="分页功能简单例子"><a href="#分页功能简单例子" class="headerlink" title="分页功能简单例子"></a>分页功能简单例子</h3><p>先配置MybatisPlus的分页拦截器, 定义一个配置Bean然后添加拦截器即可</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">mpI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        mpI.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> mpI;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>分页代码的实现</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPageData</span><span class="params">(<span class="type">int</span> pageIndex, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="comment">//创建Page对象储存获取到的分页数据pageIndex 第几页 count 一页几个</span></span><br><span class="line">    <span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(pageIndex, count);</span><br><span class="line">    userMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//page.getRecords()获取分页查询的数据</span></span><br><span class="line">    <span class="comment">//其他接口方法请看MybatisPlus的文档</span></span><br><span class="line">    System.out.println(page.getRecords());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="DQL编程控制"><a href="#DQL编程控制" class="headerlink" title="DQL编程控制"></a>DQL编程控制</h2><blockquote>
<p>有关条件构造器的更多文档请看 <a class="link"   href="https://baomidou.com/pages/10c804/" >https://baomidou.com/pages/10c804/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<h3 id="按条件查询简单例子"><a href="#按条件查询简单例子" class="headerlink" title="按条件查询简单例子"></a>按条件查询简单例子</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个查询条件(常规模式)</span></span><br><span class="line"><span class="type">QueryWrapper</span> <span class="variable">queryWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line"><span class="comment">//age 是表中的字段名</span></span><br><span class="line"><span class="comment">//下面两行代表 查询 age 这个字段值大于25小于55的数据</span></span><br><span class="line">queryWrapper.ge(<span class="string">&quot;age&quot;</span>, <span class="number">25</span>);</span><br><span class="line">queryWrapper.lt(<span class="string">&quot;age&quot;</span>, <span class="number">55</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式编程格式</span></span><br><span class="line">LambdaQueryWrapper&lt;UserEntity&gt; qw= <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//大于10 或 小于25</span></span><br><span class="line">qw.lt(UserEntity::getId, <span class="number">10</span>).or().gt(UserEntity::getId, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(pageIndex, count);</span><br><span class="line"><span class="comment">//查询条件给BaseMapper里的方法</span></span><br><span class="line">userMapper.selectPage(page, qw);</span><br><span class="line">System.out.println(page.getRecords());</span><br></pre></td></tr></table></figure></div>

<h3 id="NULL判定"><a href="#NULL判定" class="headerlink" title="NULL判定"></a>NULL判定</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">QueryWrapper</span> <span class="variable">qw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line"><span class="comment">//当user.getAge()为null时 下面这样不参加条件判断</span></span><br><span class="line">qw.lt(<span class="literal">null</span> != user.getAge(), UserEntity::getId, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//支持链式编程</span></span><br></pre></td></tr></table></figure></div>

<p>上述代码中, 当<strong>user.getAge()<strong>为</strong>null</strong>时,  则<strong>该条件语句不会参与到本次查询的条件参数里</strong></p>
<h3 id="查询投影"><a href="#查询投影" class="headerlink" title="查询投影"></a>查询投影</h3><p>介绍:  在查询时不返回全部数据，只返回某些列的数据，这种操作称为投影查询。一般使用SELECT 列1, 列2, 列3 FROM &lt;表名&gt; WHERE &lt;条件&gt;</p>
<p>MybatisPlus使用查询投影</p>
<p>一般方式</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">QueryWrapper&lt;UserEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">queryWrapper.select(<span class="string">&quot;列1&quot;</span>,<span class="string">&quot;列2&quot;</span>, <span class="string">&quot;列3&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>Lambda形式</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;UserEntity&gt; qw= <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">qw.select(UserEntity::getId, UserEntity::getAge, UserEntity::getPassword);</span><br></pre></td></tr></table></figure></div>



<h3 id="字段映射与表名映射"><a href="#字段映射与表名映射" class="headerlink" title="字段映射与表名映射"></a>字段映射与表名映射</h3><blockquote>
<p>有关注解的属性请查看源码文档</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//映射字段</span></span><br><span class="line"><span class="meta">@TableField(&quot;pwd&quot;)</span> <span class="comment">//这里的是数据库表里的字段名</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="comment">//映射表名</span></span><br><span class="line"><span class="meta">@TableName(&quot;tb_users&quot;)</span> <span class="comment">//这里的是数据库表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEntity</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>MyBatis</tag>
        <tag>MyBatis-Plus</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql笔记-单表查询</title>
    <url>/mysql-note/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>       <span class="comment">-- 4</span></span><br><span class="line"><span class="comment">-- 	字段列表</span></span><br><span class="line"><span class="keyword">FROM</span>         <span class="comment">-- 1</span></span><br><span class="line"><span class="comment">-- 	表名列表</span></span><br><span class="line"><span class="keyword">WHERE</span>        <span class="comment">-- 2</span></span><br><span class="line"><span class="comment">-- 	条件列表</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>     <span class="comment">-- 3</span></span><br><span class="line"><span class="comment">-- 	分组列表</span></span><br><span class="line"><span class="keyword">HAVING</span>       <span class="comment">-- 分组条件后执行</span></span><br><span class="line"><span class="comment">-- 	分组后条件</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>     <span class="comment">-- 5</span></span><br><span class="line"><span class="comment">-- 	排序字段</span></span><br><span class="line">LIMIT        <span class="comment">-- 6</span></span><br><span class="line"><span class="comment">-- 	限制查询返回数据的数量，用于分页限制</span></span><br></pre></td></tr></table></figure></div>

<h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a><strong>条件查询</strong></h2><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询表里许所有数据,不建议使用</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询名字</span></span><br><span class="line"><span class="comment">-- DISTINCT 去除重复</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name <span class="keyword">FROM</span> users;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询名字，性别，年龄</span></span><br><span class="line"><span class="comment">-- 可以使用 sex as 性别 的方式对列起别名,也可以写成 sex 性别 省略as 但字段名跟别名之间要有空格隔开</span></span><br><span class="line"><span class="keyword">SELECT</span> name, sex <span class="keyword">as</span> 性别, age <span class="keyword">as</span> 年龄 <span class="keyword">FROM</span> users;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 条件查询符号, NULL值比较使用 IS NOT NULL 跟 IS NULL </span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">17</span>; <span class="comment">-- 查询age数值大于17的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">7</span> <span class="keyword">AND</span> age <span class="operator">&lt;=</span> <span class="number">50</span>; <span class="comment">-- 查询age数值在7跟50之间的数值(写法一)</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">7</span> <span class="keyword">AND</span> <span class="number">50</span>; <span class="comment">-- 查询age数值在7跟50之间的数值(写法二)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询brith_day数值在&#x27;2000-01-01&#x27;跟&#x27;2000-04-01&#x27;之间的数值(写法二)</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> brith_day <span class="keyword">BETWEEN</span> <span class="string">&#x27;2000-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2000-04-01&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">17</span>; <span class="comment">-- 查询age数值等于17的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">!=</span> <span class="number">17</span>; <span class="comment">-- 查询age数值不等于17的数据(写法一)</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&lt;&gt;</span> <span class="number">17</span>; <span class="comment">-- 查询age数值不等于17的数据(写法二)</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">17</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">18</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">22</span>;<span class="comment">-- 查询age数值等于17或18或22的数据(写法一)</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="keyword">IN</span> (<span class="number">17</span>，<span class="number">18</span>，<span class="number">22</span>); <span class="comment">-- 查询age数值等于17或18或22的数据(写法二)</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NULL</span>; <span class="comment">-- 查询age数值为null的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>; <span class="comment">-- 查询age数值不为null的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="comment">-- 查询age数值为null的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	通配符</span></span><br><span class="line"><span class="comment">	_ 下划线代表单个字符</span></span><br><span class="line"><span class="comment">	% 百分号代表任意个数字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">-- 查询姓为 蔡 的名字信息</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">like</span> <span class="string">&#x27;蔡%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查询名字 第二个字是 徐 的名字信息</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">like</span> <span class="string">&#x27;_徐%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查询名字中包含坤的名字信息</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">like</span> <span class="string">&#x27;%坤%&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h2><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 排序查询语法</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序字段名<span class="number">1</span> [排序方式<span class="number">1</span>]，排序字段名<span class="number">2</span> [排序方式<span class="number">2</span>]...;</span><br><span class="line"><span class="comment">-- 排序方式</span></span><br><span class="line"><span class="comment">-- ASC 升序排列[默认]</span></span><br><span class="line"><span class="comment">-- DESC 降序排列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 升序排序例子</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 降序排序例子</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多字段降序排序例子</span></span><br><span class="line"><span class="comment">-- 如果年龄一样，则按工资升序排序</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>, money <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 聚合函数查询</span></span><br><span class="line"><span class="built_in">count</span>(列名) <span class="comment">-- 统计数量</span></span><br><span class="line"><span class="built_in">max</span>(列名)   <span class="comment">-- 最大值</span></span><br><span class="line"><span class="built_in">min</span>(列名)   <span class="comment">-- 最小值</span></span><br><span class="line"><span class="built_in">sum</span>(列名)   <span class="comment">-- 求和</span></span><br><span class="line"><span class="built_in">avg</span>(列名)   <span class="comment">-- 求平均值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 聚合函数查询语法 SELECT 聚合函数(列名)... FROM users;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(name) <span class="keyword">FROM</span> users; <span class="comment">-- 统计name有几个，不能为空，不会统计null值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(age) <span class="keyword">FROM</span> users； <span class="comment">-- 求年龄最大的</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(age) <span class="keyword">FROM</span> users； <span class="comment">-- 求年龄最小的</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(money) <span class="keyword">FROM</span> users； <span class="comment">-- 求一整列的 money 和</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(money) <span class="keyword">FROM</span> users； <span class="comment">-- 求一整列的 money 的平均值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分组查询</span></span><br><span class="line"><span class="comment">-- 根据性别分组查询平均工资</span></span><br><span class="line"><span class="keyword">SELECT</span> sex, <span class="built_in">avg</span>(money) <span class="keyword">FROM</span> users <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br><span class="line"><span class="comment">-- 根据性别分组查询平均工资，只计算工资高于5000的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> sex, <span class="built_in">avg</span>(money) <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> money <span class="operator">&gt;</span> <span class="number">5000</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 根据性别分组查询平均工资，只计算工资高于5000的数据, 且数据大于2条</span></span><br><span class="line"><span class="keyword">SELECT</span> sex, <span class="built_in">avg</span>(money) <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> money <span class="operator">&gt;</span> <span class="number">5000</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>where 是对分组前进行过滤，不支持聚合函数<br>having 是对分组后的数据进行过滤，支持聚合函数，一般查询的字段是聚合函数和分组字段<br>执行顺序：where &gt; 聚合函数 &gt; having</p>
</blockquote>
<h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users LIMIT 起始索引，查询数目量;</span><br><span class="line"><span class="comment">-- 从0开始查，查询3条数据</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users LIMIT <span class="number">0</span>，<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分页查询</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users LIMIT (当前页面 <span class="number">-1</span>) <span class="operator">*</span> 每页显示条目数，每页显示条目数;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(2)</title>
    <url>/redis/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%202%20)/</url>
    <content><![CDATA[<blockquote>
<p>本章笔记记录SpringDataRedis和Redisson的使用，高并发下的线程安全问题，普通锁与分布式锁的使用，以及Redisson锁的原理</p>
</blockquote>
<h3 id="并发线程安全问题"><a href="#并发线程安全问题" class="headerlink" title="并发线程安全问题"></a>并发线程安全问题</h3><blockquote>
<p>在并发访问数据库时，总会存在线程安全问题。为了解决该问题，我们一般使用加锁解决。而对于 <mark style="background: #ADCCFFA6;">上锁与否的态度</mark> 分为 <code>悲观锁</code> 和 <code>乐观锁</code>。这里将使用 <code>乐观锁</code> 进行演示</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用myBatis-plus, 等价于 -&gt; set stock = stock - 1 where item_id = ? and stock &gt; 0</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> itemService  </span><br><span class="line">        .update()  </span><br><span class="line">        .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)  </span><br><span class="line">        .eq(<span class="string">&quot;item_id&quot;</span>, itemId)</span><br><span class="line">        <span class="comment">//判断stock是否大于0</span></span><br><span class="line">        .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        .update();</span><br><span class="line"><span class="comment">//等价于-&gt; set stock = stock - 1 where item_id = ? and stock = ?</span></span><br><span class="line"><span class="comment">//boolean res = itemService  </span></span><br><span class="line"><span class="comment">//      .update()  </span></span><br><span class="line"><span class="comment">//      .setSql(&quot;stock = stock - 1&quot;)  </span></span><br><span class="line"><span class="comment">//      .eq(&quot;item_id&quot;, itemId)  </span></span><br><span class="line"><span class="comment">//       eq(&quot;stock&quot;, itemStock)</span></span><br><span class="line"><span class="comment">//      .update();</span></span><br><span class="line"><span class="keyword">if</span> (!res) &#123;</span><br><span class="line">	<span class="comment">//乐观锁的失败率会更大，所以一般更新失败，会重试</span></span><br><span class="line">	<span class="comment">//...重试逻辑</span></span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上方的代码实现了一个简单的CAS乐观锁。需要注意的是，因为乐观锁失败几率更大，为了不让用户感知到失败，这里的业务只要stock大于0就可更新。减少锁的粒度。实际开发应根据业务选择和修改。</p>
<h3 id="一人一单问题（也是线程安全问题）"><a href="#一人一单问题（也是线程安全问题）" class="headerlink" title="一人一单问题（也是线程安全问题）"></a>一人一单问题（也是线程安全问题）</h3><p>有时候在做业务时，我们想限制用户在同个活动里只能购买一个商品，或者电商系统防止出现超卖。这时可以给业务代码加锁，让线程串行执行。而对于单机系统与分布式系统，则有如下几种方案。</p>
<h4 id="单机系统"><a href="#单机系统" class="headerlink" title="单机系统"></a>单机系统</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>  </span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;  <span class="comment">//创建优惠券订单</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserLocal.getUser().getId();  </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query()  </span><br><span class="line">            .eq(<span class="string">&quot;user_id&quot;</span>, userId)  </span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)  </span><br><span class="line">            .count();  </span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;购买失败，只允许购买一次&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//用户第一次购买</span></span><br><span class="line">    <span class="comment">//减少库存 - 具体下单业务代码</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">orderNow</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//商品信息获取</span></span><br><span class="line">	<span class="comment">//库存判断，活动时间判断逻辑</span></span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//加锁，一人一单</span></span><br><span class="line">	<span class="keyword">synchronized</span> (userId.toString().intern()) &#123;<span class="comment">//使用用户Id加锁</span></span><br><span class="line">	    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<span class="comment">//获取当前代理对象</span></span><br><span class="line">	    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId); <span class="comment">//代理对象调用保证事务生效</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>上面代码，在单机系统下，通过 <code>synchronized</code> 加锁，实现了一人一单的功能。但仅限单机系统可用，若是 <mark style="background: #FFB8EBA6;">分布式系统还是会出现线程并发安全</mark></p>
<h4 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h4><blockquote>
<p>分布式一般由若干个单机系统的集合，通过代理转发请求到各个单机应用。 从而达到负载均衡，缓解单个单机应用压力，处理高并发数据的功能。</p>
</blockquote>
<p>在单机系统，我们想做一人一单功能的话，只需使用 <code>synchronized</code> 加锁即可。可在分布式系统这个方法行不通。因为分布式是多个单机系统的集合。每个单机系统都有自己的jvm（已Java的Spring为例）。多个jvm之间并不共享锁的信息。可用分布式锁解决此问题</p>
<h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><p>简介：满足分布式锁系统或者集群模式下多进程可见并且互斥的锁<br>要求：多进程可见，互斥，高可用，高性能，安全性，</p>
<h4 id="基于Redis命令SETNX的分布式锁"><a href="#基于Redis命令SETNX的分布式锁" class="headerlink" title="基于Redis命令SETNX的分布式锁"></a>基于Redis命令SETNX的分布式锁</h4><p>使用Redis的 <code>SETNX</code> 实现互斥锁，并添加过期时间作为兜底方案，防止服务宕机造成的死锁</p>
<h6 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h6><p>使用redis的 <code>SETNX</code> 命令实现互斥，具体实现如下，其中可以用 <code>uuid + 线程Id</code> 来当锁的值</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(Long expire)</span> &#123;<span class="comment">//尝试加锁，并设置一个超时时间作为兜底方案</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> PREFIX + LOCK_KEY + <span class="string">&quot;&quot;</span>;<span class="comment">//锁的key，一般由一个前缀加业务名，或业务相关的值拼接而成，但不能加随机值，如用户Id之类的，保证每次SETNX时是同个key</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">res</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()  </span><br><span class="line">            .setIfAbsent(lockKey, LOCK_VALUE, expire, TimeUnit.SECONDS);  </span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(res);<span class="comment">//res是包装类型，自动拆箱可能会空指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h6 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h6><p>根据锁的key来获取值，为了防止锁的误删，需要判断获取到的reids锁的值是否与锁对象中的值是否一致，一致再删除。这样就能实现一个简单的分布式锁</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//根据锁的key拿值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockValue</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOCK_KEY);  </span><br><span class="line">    <span class="comment">//值存在</span></span><br><span class="line">    <span class="keyword">if</span> (lockValue.equals(LOCK_VALUE)) &#123; <span class="comment">//值的内容是否一致</span></span><br><span class="line">        stringRedisTemplate.delete(PREFIX + LOCK_KEY);<span class="comment">//一致则删除该记录，以达到释放锁 </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h6 id="锁的误删与原子性操作"><a href="#锁的误删与原子性操作" class="headerlink" title="锁的误删与原子性操作"></a>锁的误删与原子性操作</h6><p>在高并发的情况下，可能会出现极端情况，例如线程A拿到锁，执行完业务准备释放锁，判断锁是自己后，准备释放锁时，<code>jvm</code> GC机制触发或其他一些原因导致当前线程A被阻塞。如果阻塞时间超过了锁的存在时间。时间一到，锁被释放。在这一刻如果恰好线程B来拿锁，那线程B就会获取锁成功。而这时线程A阻塞完毕，开始解锁。因为在阻塞前已经判断锁是线程A的了。所以此时线程A会删掉线程B的锁。导致锁的误删。<br>为了解决这一问题，需要保证锁的判断与删除的 <mark style="background: #BBFABBA6;">原子性</mark>。可以使用Redis的 <mark style="background: #FFB86CA6;">Lua脚本</mark> 来确保命令执行的原子性。</p>
<p><strong>Lua脚本如下</strong></p>
<div class="highlight-container" data-rel="Lua"><figure class="iseeu highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- lua数组下标从1开始</span></span><br><span class="line"><span class="comment">-- KEYS是key数组 ARGS是参数数组,redis.call由redis提供，使用redis命令 -&gt; EVAL </span></span><br><span class="line"><span class="comment">-- 判断获取到的值是否与传入值一致  </span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGS[<span class="number">1</span>]) <span class="keyword">then</span>  </span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<p><strong>Java代码部分</strong><br>使用RedisTemplate调用Lua脚本，调用 <code>RedisTemplate</code> 的方法 <code>execute</code> 即可，此方法参数与命令 <code>EVAL</code> 差不多</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化RedisScript</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> DefaultRedisScript&lt;Long&gt; unlockScript;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    unlockScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    unlockScript.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;lua/lock.lua&quot;</span>));  </span><br><span class="line">    unlockScript.setResultType(Long.class);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span> &#123;</span><br><span class="line">    stringRedisTemplate.execute(  </span><br><span class="line">            unlockScript,  </span><br><span class="line">            Collections.singletonList(PREFIX + LOCK_KEY),  </span><br><span class="line">            LOCK_VALUE  </span><br><span class="line">    );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>通过lua脚本，我们让判断与删除锁在一行代码里执行完，保证了操作的原子性。</p>
</blockquote>
<h6 id="SETNX分布锁的问题与总结"><a href="#SETNX分布锁的问题与总结" class="headerlink" title="SETNX分布锁的问题与总结"></a>SETNX分布锁的问题与总结</h6><p><strong>总结</strong><br>对于一些消费系统，钱包系统，一人一旦的秒杀活动等业务场景，为了防止高并发场景下因多个线程之间同步访问操作一个资源，造成数据不一致，数据损失等问题。例如前面提到的三个系统，如果没有使用锁，就会出现消费系统超卖，钱包支出金额超过了存款，秒杀活动一人下了多单等问题。</p>
<ol>
<li>在单机系统下，我们可以使用由JVM实现的 <code>synchronized</code> 和 JDK提供的 <code>Lock</code> 对数据操作的业务逻辑代码加锁，让并发线程串行执行，防止出现问题。</li>
<li>在分布式或系统下，我们可以使用Redis的 <code>SETNX</code> 实现互斥锁。 <code>SETNX</code> 意思就是 set if not exist，如果 <code>key</code> 不存在则写入返回 1 如果存在则返回非1，代表其他线程已经设置过了。同时给这个 <code>key</code> 添加一个过期时间，防止出现因业务崩溃，没人解锁导致死锁的问题。需要注意的是应该在设置 key 的时候就添加过期时间，而不是先设置key。在添加过期时间，用一行代码完成加锁，保证操作原子性。</li>
</ol>
<p><strong>存在的问题</strong></p>
<ol>
<li>不可重入：同一个线程无法获取多把锁</li>
<li>不可重试：获取锁只尝试一次，不成功就返回false，没有重试机制</li>
<li>超时释放：超时释放可以避免死锁问题，但如果业务代码执行时间超过锁的超时时间，也会导致锁的释放，存在安全隐患</li>
<li>主从一致性：如果redis提供主从集群，主从同步存在延迟，当 <mark style="background: #FFB86CA6;">主节点</mark> 宕机时， <mark style="background: #BBFABBA6;">从节点</mark> 来不及同步 <mark style="background: #FFB86CA6;">主节点</mark> 的锁数据，就会出现锁数据的丢失</li>
</ol>
<h4 id="Redisson的锁"><a href="#Redisson的锁" class="headerlink" title="Redisson的锁"></a>Redisson的锁</h4><blockquote>
<p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格。它不仅提供了一系列分布式的Java常用对象，还提供了许多分布式服务</p>
</blockquote>
<p><strong>使用Redisson的分布式锁</strong></p>
<ul>
<li><p>配置redisson，这里使用配置类形式，也可以写application.yml里</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();  </span><br><span class="line">        config.useSingleServer()  </span><br><span class="line">                .setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>)  </span><br><span class="line">                .setPassword(<span class="string">&quot;12345678&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>锁的使用</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span>  </span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:order:&quot;</span> + userId + <span class="string">&quot;:&quot;</span> + voucherId;  </span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);  </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">//这里也可以使用无参的tryLock方法，无参方法默认不等待，超时时间30秒</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">2L</span>, <span class="number">30L</span>, TimeUnit.SECONDS);  </span><br><span class="line">    <span class="keyword">if</span> (!isLock) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//.....业务代码 </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">    lock.unlock();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h5 id="Redisson锁可重入流程"><a href="#Redisson锁可重入流程" class="headerlink" title="Redisson锁可重入流程"></a>Redisson锁可重入流程</h5><blockquote>
<p>为确保操作原子性，应用Lua脚本来操作</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/13/JafH4EzQ2YPgkrn.png"
                      alt="重入锁流程.png"
                ></p>
<p>原理：利用Hash结构记录线程标识与获取锁的次数实现同一线程多次获取锁，当获取锁的线程标识与记录的线程标识一致时，锁的次数+1，否则获取锁失败。解锁时也判断一次线程标识是否一致，一致就把锁的次数-1，当锁的次数等于0时才真正释放锁，删掉这个hash结构。其他线程才能获取到锁。</p>
<h5 id="Redisson锁重试流程"><a href="#Redisson锁重试流程" class="headerlink" title="Redisson锁重试流程"></a>Redisson锁重试流程</h5><p><strong>获取锁流程</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/13/xodmHp4PIA9CYLi.png"
                      alt="锁重试原理.png"
                ></p>
<p><strong>释放锁流程</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/13/ak4hbrdz7N2yLXx.png"
                      alt="无标题流程图 _1_.png"
                ></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li>可重入：利用hash结构记录线程id和重入次数（当前线程获取锁的次数）每一次获取锁成功，重入次数+1，释放锁重入次数-1，当记录的重入次数为0时就删除该hash释放线程锁</li>
<li>可重试：利用信号量和PubSub功能实现等待，唤醒，获取锁失败的重试机制。在第一次获取锁失败后，等待释放锁的消息。当得到锁释放的消息后重试获取锁，继续失败，继续等待。如果超过了等待时间，则不会再重试。</li>
<li>超时续约：利用WatchDog，每隔一段时间重置锁的超时时间，这个时间间隔，是你提交的超时时间的三分之一。</li>
</ol>
<h5 id="Redisson锁的主从一致性-multiLock"><a href="#Redisson锁的主从一致性-multiLock" class="headerlink" title="Redisson锁的主从一致性(multiLock)"></a>Redisson锁的主从一致性(multiLock)</h5><blockquote>
<p>为了提高服务高可用，我们会选择搭建redis主从集群，增删改操作由主节点完成，读操作由从节点完成。当增删改操作到达主节点，主节点操作完成后会跟从节点进行同步。主节点宕机后，会从其余从节点选一个当主节点</p>
</blockquote>
<p>问题分析：如果一个Java应用提交了一个锁的数据到主节点。但主节点操作完后准备同步时发生不可避免地错误或意外宕机了。这时redis哨兵会选择新的主节点。但已宕机的主节点数据还未同步，锁的数据丢失。这时如果有其他线程的请求进来获取锁还是会成功。并发安全问题又一次发生。</p>
<p>Redisson解决方案：Redisson会把锁的信息写入到每个redis节点。获取锁时需要从所有节点获取锁成功才算成功，这样如果有一个节点意外宕机，剩下的节点也不会出现锁信息丢失的情况。这些节点可以是单独的节点，也可以是主从关系的节点。</p>
<p><strong>简单使用</strong><br>需在配置文件配置好多个redis节点</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义多个锁对象，每个锁对象代表独立的redis节点</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> redissonClient1.getLock(lockKey); <span class="comment">//节点1</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock2</span> <span class="operator">=</span> redissonClient2.getLock(lockKey); <span class="comment">//节点2</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock3</span> <span class="operator">=</span> redissonClient3.getLock(lockKey); <span class="comment">//节点3</span></span><br><span class="line"><span class="comment">//获取一个联锁</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">multiLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonMultiLock</span>(lock1, lock2, lock3);<span class="comment">//获取联锁，</span></span><br><span class="line"><span class="comment">//使用一样</span></span><br><span class="line">multiLock.tryLock();</span><br><span class="line">multiLock.unLock();</span><br></pre></td></tr></table></figure></div>

<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><blockquote>
<p>消息队列（Message Queue） 字面意思就是存放消息的队列。最简单的消息队列模型包含三个角色<br>消息队列：存储和管理消息，也被称为消息代理<br>生产者：发送消息到消息队列<br>消费者：从消息队列获取消息并处理消息</p>
</blockquote>
<h4 id="PubSub"><a href="#PubSub" class="headerlink" title="PubSub"></a>PubSub</h4><p>pubsub是Redis2.0版本引入的消息传递类型。顾名思义，消费者可以订阅一个或者多个channel，生产者向对应channel发送消息后，所有订阅者都能收到消息。</p>
<p><strong>命令使用</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">SUBSCRIBE [channel....] <span class="comment"># 订阅一个或多个频道</span></span><br><span class="line">PUBLISH channel msg <span class="comment"># 向一个频道发送消息</span></span><br><span class="line">PSUBSCRIBE [pattern] <span class="comment"># 订阅符合 pattern 的所有频道</span></span><br></pre></td></tr></table></figure></div>

<p>优点：</p>
<ul>
<li>采用发布订阅模型，支持多生产，多消费<br>缺点：</li>
<li>不支持消息持久化</li>
<li>无法避免消息丢失</li>
<li>消息有堆积上限，超时数据丢失</li>
</ul>
<h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><blockquote>
<p>Stream是redis 5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p>
</blockquote>
<h5 id="单消费模式"><a href="#单消费模式" class="headerlink" title="单消费模式"></a>单消费模式</h5><h6 id="添加消息-XADD"><a href="#添加消息-XADD" class="headerlink" title="添加消息(XADD)"></a>添加消息(XADD)</h6><p><strong>命令使用</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">XADD key [NOMKSTREAM] [&lt;MAXLEN | MINID&gt; [= | ~] threshold [LIMIT count]] &lt;* | <span class="built_in">id</span>&gt; [field value ...]</span><br></pre></td></tr></table></figure></div>

<p><strong>参数解释</strong></p>
<ul>
<li>NOMKSTREAM： 如果队列不存在，是否自动创建队列。默认自动创建</li>
<li>&lt;MAXLEN | MINID&gt; [&#x3D; | ~] threshold [LIMIT count]： 设置消息队列的最大消息量</li>
<li><ul>
<li>| id： 消息的唯一 Id， * 代表由redis自动生成。格式是 <code>时间戳-递增数字</code> 例如 <code>1526919030474-55</code></li>
</ul>
</li>
<li>field value：  键值对Entry，存到消息队列中的消息</li>
</ul>
<p><strong>使用例</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 users: &#123;name: senpai, age:24&#125;</span></span><br><span class="line">XADD <span class="built_in">users</span> * name senpai age 24</span><br></pre></td></tr></table></figure></div>

<h6 id="读取消息-XREAD"><a href="#读取消息-XREAD" class="headerlink" title="读取消息(XREAD)"></a>读取消息(XREAD)</h6><p><strong>命令</strong></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">XREAD [COUNT count] [BLOCK milliseconds] STREAMS [key ...] [<span class="built_in">id</span> ...]</span><br></pre></td></tr></table></figure></div>

<p><strong>参数解释</strong></p>
<ul>
<li>COUNT count： 每次读取消息的数量</li>
<li>BLOCK milliseconds： 当没有消息时，是否阻塞，以及阻塞时长</li>
<li>STREAMS key … ： 要从哪个消息队列读消息， key为队列名</li>
<li>id…  ：起始Id，只返回大于这个Id的消息，0 表示从第一个消息开始 $ 表示读最新的一条消息</li>
</ul>
<h6 id="单消费优缺点"><a href="#单消费优缺点" class="headerlink" title="单消费优缺点"></a>单消费优缺点</h6><p><strong>优点</strong></p>
<ul>
<li>消息可回溯</li>
<li>一个消息可被多个消费者读取</li>
<li>可以阻塞读取<br><strong>缺点</strong></li>
<li>有消息漏读风险</li>
</ul>
<h5 id="Stream消费者组"><a href="#Stream消费者组" class="headerlink" title="Stream消费者组"></a>Stream消费者组</h5><p>消费者组：将多个消费者划分到一个组中，监听同一个队列<br>具备以下特点：</p>
<ul>
<li>消息分流：队列中会分流给组内的不同消费者，而不是重复消费。加快消息处理速度</li>
<li>消息标识：消费者组会维护一个标识，记录最后一个被处理的消息。哪怕消费者宕机重启，还会读取标识后的消息，确保每个消息都被消费掉</li>
<li>消息确认：消费者获取消息后，消息处于 <code>Pending</code> 状态，并存入一个pending-list。当处理完成后会通过 <code>xack</code> 来确认消息。标记消息已处理。才会从 pending-list 移除</li>
</ul>
<h6 id="创建消费者组"><a href="#创建消费者组" class="headerlink" title="创建消费者组"></a>创建消费者组</h6><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">XGROUP CREATE KEY GROUP_NAME ID [MKSTREAM]</span><br></pre></td></tr></table></figure></div>
<p>参数解析</p>
<ul>
<li>key：队列名称</li>
<li>group_name：消费者组名称</li>
<li>id：起始id， $ 代表最新一个消息。0 代表队列中第一个消息</li>
</ul>
<h6 id="删除消费者组"><a href="#删除消费者组" class="headerlink" title="删除消费者组"></a>删除消费者组</h6><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">XGROUP DESTROY KEY GROUP_NAME</span><br></pre></td></tr></table></figure></div>
<p>参数解析</p>
<ul>
<li>key：队列名称</li>
<li>group_name：消费者组名称</li>
</ul>
<h6 id="从消费者组读取消息"><a href="#从消费者组读取消息" class="headerlink" title="从消费者组读取消息"></a>从消费者组读取消息</h6><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP GROUP_NAME CONSUMER [COUNT] [BLOCK] [NOACK] STREAMS KEY... ID...</span><br></pre></td></tr></table></figure></div>
<p>参数解析</p>
<ul>
<li>GROUP_NAME：消费者组名称</li>
<li>CONSUMER：消费者名称，如果没有，则会自动创建</li>
<li>COUNT：本次查询最大数量， count 20 查20条</li>
<li>BLOCK：没有消息时阻塞，以及阻塞时间 block 2000 阻塞两秒</li>
<li>NOACK：获取到消息后自动确认(不建议)</li>
<li>STREAMS KEY：指定队列名称</li>
<li>ID：获取消息的起始Id<ul>
<li><code>&gt;</code> ：从下一个未消费的消息开始</li>
<li>其他：根据指定id，从pengding-list里获取已消费单未确认的消息。</li>
</ul>
</li>
</ul>
<h6 id="消费者组特点"><a href="#消费者组特点" class="headerlink" title="消费者组特点"></a>消费者组特点</h6><ul>
<li>消息可回溯</li>
<li>可以多消费者消费消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消息漏读风险</li>
<li>有消息确认机制，保证消息被消费一次</li>
</ul>
<h3 id="Feed流"><a href="#Feed流" class="headerlink" title="Feed流"></a>Feed流</h3><p>Feed流产品有两种常见模式</p>
<ul>
<li>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈<ul>
<li>优点：信息全面，不会有缺失。实现相对简单</li>
<li>缺点：信息噪音较多。用户不一定感兴趣，内容获取率较低</li>
</ul>
</li>
<li>智能排序：利用算法屏蔽违规的，用户不感兴趣的。推送用户感兴趣的内容吸引用户<ul>
<li>优点：投喂用户感兴趣信息，用户黏度高，容易沉迷</li>
<li>缺点：如果算法不精准，可能起到反作用</li>
</ul>
</li>
</ul>
<h4 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h4><blockquote>
<p>假设我们要实现朋友圈功能，用户发送一个新的动态后，动态信息会存到发送箱里，而他的粉丝将有一个收件箱接受消息</p>
</blockquote>
<h5 id="拉模式"><a href="#拉模式" class="headerlink" title="拉模式"></a>拉模式</h5><p>拉模式也叫读扩散，数据只存一份（存发送箱里），每次读的时候，都从发送箱拉取。写操作较低，读操作较多，读取延迟可能较大，一般很少使用</p>
<h5 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h5><p>推模式也叫写扩散，直接将消息推送到收件箱，写操作较高，读操作较低，读取延迟较低。在用户量少时使用</p>
<h5 id="推拉模式"><a href="#推拉模式" class="headerlink" title="推拉模式"></a>推拉模式</h5><p>推拉模式也叫读写混合，兼具推和拉两种模式的优点。例如可以根据 <mark style="background: #FFB86CA6;">接收者的活跃情况</mark> 来判断使用 <code>推</code> 还是 <code>拉</code>。举例：一个粉丝有百万的博主在发布新的动态时。可以对该博主粉丝活跃情况进行分级，天天活跃的粉丝使用推模式，偶尔活跃的粉丝和不活跃的粉丝则使用拉模式。而对于粉丝不多的普通账号，则可以直接使用推模式。</p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>reids</tag>
        <tag>Spring-data-redis</tag>
        <tag>分布式锁</tag>
        <tag>redisson</tag>
      </tags>
  </entry>
  <entry>
    <title>并发安全问题</title>
    <url>/mysql-note/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>无论是存在硬盘里的数据还是存在内存中的数据，只要不是像Redis那样只支持单线程访问，就都存在线程安全问题。通常，在代码中，面对线程安全问题的态度，分为[ 悲观锁 ]和[ 乐观锁 ]</p>
</blockquote>
<p>悲观锁：认为线程安全一定发生，操作数据时认为一定有另一个线程正在使用这个数据。为确保线程安全，都要先获取锁串行运行。例如：<code>Synchornized</code> <code>Lock</code> 都属于悲观锁<br>乐观锁：认为线程安全不一定发生，操作数据时没有其他线程在使用这个数据，因此不加锁，只在更新数据时去判断有没有其他线程对数据做了修改。如果数据没有修改则认为自己的操作是安全的，才更新数据。如果数据已经被其他线程修改了，说明发生安全问题，此时会重试或者报错。</p>
<blockquote>
<p>需要注意的是，<mark style="background: #BBFABBA6;">悲观锁和乐观锁并不是真正的锁，而是一种锁的设计理念</mark>。</p>
</blockquote>
<p>悲观锁的实现相对乐观锁较简单，每次操作都尝试获取锁串行执行相关操作即可。</p>
<p>乐观锁的实现，常见的方式有两种</p>
<ol>
<li><p>版本号法：给数据添加一个版本 <code>version</code> 属性，然后判断版本属性有无变化，根据判断结果执行相关操作</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 假设这里储存了旧值oldVersion = 1</span></span><br><span class="line"><span class="keyword">set</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span>, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">114</span> <span class="keyword">and</span> stock <span class="operator">=</span> <span class="number">1</span>, version <span class="operator">=</span> oldVersion</span><br><span class="line"><span class="comment">-- 当id 114 这条数据的version还是等于1时才会更新</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>CAS法：Compare And Swap(比较并且交换)，是一种能让线程不需要通过阻塞就能够避免多线程安全问题的一种算法，也是乐观锁的技术。它可以不使用锁而保证多线程安全。所以CAS也是一种无锁算法，CAS包含三个参数 CAS（V,E,N）。V表示要更新的变量，E表示预期的值，N表示新值。仅当V值等于E值时，才会将V的值设置成N，否则什么都不做。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 假设这里储存了旧值oldStock = 1</span></span><br><span class="line"><span class="keyword">set</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">114</span> <span class="keyword">and</span> stock <span class="operator">=</span> oldStock</span><br><span class="line"><span class="comment">-- 当id 114这行的数据 stock值还是等于1时才会更新</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>悲观锁</tag>
        <tag>乐观锁</tag>
      </tags>
  </entry>
  <entry>
    <title>redis学习笔记</title>
    <url>/redis/redis%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="SQL与NOSQL区别"><a href="#SQL与NOSQL区别" class="headerlink" title="SQL与NOSQL区别"></a>SQL与NOSQL区别</h2><table>
<thead>
<tr>
<th></th>
<th>SQL</th>
<th>NOSQL</th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>结构化</td>
<td>非结构化</td>
</tr>
<tr>
<td>查询方式</td>
<td>SQL查询</td>
<td>无关联的</td>
</tr>
<tr>
<td>事务特性</td>
<td>ACID</td>
<td>BASE</td>
</tr>
<tr>
<td>存储方式</td>
<td>磁盘</td>
<td>内存</td>
</tr>
<tr>
<td>扩展性</td>
<td>垂直</td>
<td>水平</td>
</tr>
<tr>
<td>使用场景</td>
<td>数据结构固定<br>业务对数据安全性一致性较高的场景</td>
<td>数据结构不固定<br>对一致性安全性要求不高的场景<br>有高性能要求的场景</td>
</tr>
</tbody></table>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Redis存储的时key-value结构的数据, 其中key是字符串类型, value有常用的5种数据类型</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>字符串</td>
<td>普通字符串</td>
</tr>
<tr>
<td>hash</td>
<td>哈希</td>
<td>适合存储对象</td>
</tr>
<tr>
<td>list</td>
<td>列表</td>
<td>按照插入顺序排序, 可以重复</td>
</tr>
<tr>
<td>set</td>
<td>集合</td>
<td>无序集合, 没有重复元素</td>
</tr>
<tr>
<td>sorted set</td>
<td>有序集合</td>
<td>有序集合, 没有重复元素</td>
</tr>
</tbody></table>
<h2 id="Key结构"><a href="#Key结构" class="headerlink" title="Key结构"></a>Key结构</h2><p>redis的key允许有多个单词形成层级结构, 用 <code>:</code> 隔开 。格式例如: <code>项目名:业务名:id</code><br>上述格式并非固定写法，可以根据业务需求而定<br>例如</p>
<ul>
<li>user 相关的key: <code>kita:user:114</code></li>
<li>product 相关的key: <code>kita:product:1919</code></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/06/suJFbprzIHMCkQD.png"
                      alt="key层级结构.png"
                ></p>
<h2 id="简介与常用命令"><a href="#简介与常用命令" class="headerlink" title="简介与常用命令"></a>简介与常用命令</h2><h3 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串(string)"></a>字符串(string)</h3><p><code>String</code> 类型是Redis中最简单的存储类型, 其value是字符串. 根据字符串的格式不同. 又可分三类</p>
<ol>
<li>string: 普通字符串</li>
<li>int: 整数类型, 可以自增自减</li>
<li>float: 浮点类型, 可以自增自减</li>
</ol>
<blockquote>
<p>不管哪种格式  <mark style="background: #BBFABBA6;">底层都是字节数组形式存储</mark> 编码方式不同. 且字符串类型最大空间不能超过512m</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">SET [key] [value] <span class="comment"># 设置指定key的值</span></span><br><span class="line">GET [key] <span class="comment"># 获取指定key的值</span></span><br><span class="line">SETEX [key] [seconds] [value] <span class="comment">#  设置指定key的值, 并设置过期时间 seconds 秒</span></span><br><span class="line">SETNX [key] [value] <span class="comment"># 只有key不存在时设置key的值</span></span><br><span class="line">MSET</span><br><span class="line">MGET</span><br></pre></td></tr></table></figure></div>

<h3 id="哈希-hash"><a href="#哈希-hash" class="headerlink" title="哈希(hash)"></a>哈希(hash)</h3><blockquote>
<p>Hash类型，也叫散列，其value是一个无序字典，类似Java中的HashMap结构</p>
</blockquote>
<p>String结构时将对象序列化成JSON字符串后存储, 但当要修改某个值时很不方便</p>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>kita:user:114</td>
<td>{name:’先辈’, age:24}</td>
</tr>
<tr>
<td>kita:user:524</td>
<td>{name:’远野’, age:24}</td>
</tr>
</tbody></table>
<p><strong>如上所示, String结构要更新某个属性时, 需要删掉再重新设置</strong></p>
<blockquote>
<p>Hash结构可以把对象中的每个字段单独存储，可以针对某字段进行CRUD</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/06/1K2lkX57SrGJfLT.png"
                      alt="屏幕截图 2023-03-06 105936.png"
                ></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">HSET [key] [field] [value] <span class="comment"># 设置哈希表 key 中的 field 的值为value</span></span><br><span class="line">HGET [key] [field] <span class="comment"># 获取哈希表中指定字段[field]的值</span></span><br><span class="line">HDEL [key] [field] <span class="comment"># 删除哈希表中的指定字段</span></span><br><span class="line">HKEYS [key] <span class="comment"># 获取哈希表所有字段</span></span><br><span class="line">HVALS [key] <span class="comment"># 获取哈希表中所有值</span></span><br><span class="line">HGETALL [key] <span class="comment"># 获取哈希表中所有字段跟值</span></span><br></pre></td></tr></table></figure></div>

<h3 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h3><p>Redis中的 <code>List</code> 类型与Java中的 <code>LinkedList</code> 类似，可以看做时一个双向链表结构，既可以正向检索，也可以反向检索<br>特征与LinkedList类似</p>
<ul>
<li>有序</li>
<li>元素可重复</li>
<li>插入和删除快</li>
<li>查询速度一般<br>一般来保存对顺序有要求的数据，例如朋友圈点赞列表，评论列表等</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">LPUSH [key] [value...] <span class="comment"># 从列表左边插入一个或多个元素</span></span><br><span class="line">RPUSH [key] [value...] <span class="comment"># 从列表右边插入一个或多个元素</span></span><br><span class="line">LRANGE [key] [startIndex] [stopIndex] <span class="comment"># 获取指定范围内的元素</span></span><br><span class="line">LPOP [key] <span class="comment"># 移除并获取列表左侧第一个元素, 没有就返回nil</span></span><br><span class="line">RPOP [key] <span class="comment"># 移除并获取列表右侧第一个元素, 没有就返回nil</span></span><br><span class="line">LLEN [key] <span class="comment"># 获取列表长度</span></span><br><span class="line">BLPOP/BRPOP [key1] [key2] [TIMEOUT] <span class="comment"># 移除并获取列表左边/右边第一个元素, 如果列表没有元素, 则阻塞列表直到等待超时, 或发现可弹出元素为止</span></span><br></pre></td></tr></table></figure></div>

<h3 id="集合-set"><a href="#集合-set" class="headerlink" title="集合(set)"></a>集合(set)</h3><p>Redis的 <code>Set</code> 结构与Java中的 <code>HashSet</code> 类似, 可以看作是一个value为null的HashMap, 也是一个hash表，与HashSet类似的特征</p>
<ul>
<li>无序</li>
<li>元素不可重复</li>
<li>查找快</li>
<li>支持交集，并集，差集</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">SADD [key] [member...] <span class="comment"># 向集合添加一个或多个成员</span></span><br><span class="line">SMEMBERS [key] <span class="comment"># 返回集合中的所有成员</span></span><br><span class="line">SCARD [key] <span class="comment"># 获取集合成员数</span></span><br><span class="line">SINTER [key...]<span class="comment"># 返回给定所有集合交集</span></span><br><span class="line">SUNION [key...] <span class="comment"># 返回给定所有集合并集</span></span><br><span class="line">SDIFF [key...]. <span class="comment"># 返回给定所有集合差集</span></span><br><span class="line">SREM [key] [member1] [member2] <span class="comment"># 移除集合中的一个或多个成员</span></span><br></pre></td></tr></table></figure></div>

<h3 id="有序集合-sorted-set"><a href="#有序集合-sorted-set" class="headerlink" title="有序集合(sorted set)"></a>有序集合(sorted set)</h3><p>Redis的 <code>SortedSet</code> 是一个可排序的集合, <code>SortedSet</code> 中的每一个元素都带有一个 <code>score</code> 属性，根据这个属性对元素进行排序，底层的实现是一个 <mark style="background: #ADCCFFA6;">跳表 (SkipList)</mark> 加 <mark style="background: #FFB86CA6;">hash表</mark><br>特性</p>
<ol>
<li>可排序</li>
<li>不重复</li>
<li>查询快</li>
</ol>
<blockquote>
<p>因其特性经常被拿来实现排行榜这样的功能</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ZADD [key] [score1] [member1] [score2] [member2]... <span class="comment">#向有序集合添加/更新一个或多个成员及分数</span></span><br><span class="line">ZRANGE [key] [startIndex] [stopIndex] [withsScores] <span class="comment"># 通过索引区间返回有序集合中指定区间内的成员</span></span><br><span class="line">ZINCRBY [key] increment [menber] <span class="comment"># 有序集合中对指定成员的分数加上增量 increment</span></span><br><span class="line">ZREM [key] [member...] <span class="comment"># 移除有序集合中的一个或多个成员</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Geo"><a href="#Geo" class="headerlink" title="Geo"></a>Geo</h3><p>GEO是GeoLocation的简写，代表地理坐标。在redis3.2后加入。允许存储地理坐标，帮助我们根据经纬度来检索数据。</p>
<h4 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h4><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">GEOADD <span class="comment"># 添加一个地理空间信息，包含：经度(Longitude)，维度(Latitude)，值(Member)</span></span><br><span class="line">GEODIST <span class="comment"># 计算指定的两点之间的距离并返回</span></span><br><span class="line">GEOHASH <span class="comment"># 将指定member的坐标转化为Hash字符出形式并返回</span></span><br><span class="line">GEOPOS <span class="comment"># 返回指定member的坐标</span></span><br><span class="line">GEORADIUS <span class="comment"># 指定圆心，半径，找到该圆内的所有member</span></span><br><span class="line">GEOSEARCH <span class="comment"># 指定范围内搜索member，并按照与指定点之间的距离排序后并返回。可以是圆形或矩形</span></span><br><span class="line">GEOSEARCHSTORE <span class="comment"># 与GEOSEACH功能一致，不过把结果存储到一个指定key</span></span><br></pre></td></tr></table></figure></div>

<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>我们可以是用Geo数据结构来计算两个坐标之间的距离，一个范围内有哪些坐标点。通常使用在 <code>附近</code> 业务，可以以用户为中心，查找附近的店铺，附近的其他用户等</p>
<h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>如果我们需要记录某一用户在一年中每天是否有登录我们的系统这一需求该如何完成呢？如果使用KV存储，每个用户需要记录365个，当用户量上亿时，这所需要的存储空间是惊人的。<br>Redis 为我们提供了Bitmap（位图）这一数据结构，把每一个bit位对应当月的每一天。用 0 和 1 标识业务状态。<br><strong>Redis中利用String类型数据结构实现Bitmap，最大上限是512M，2 ^32个比特位</strong></p>
<h4 id="常见命令-1"><a href="#常见命令-1" class="headerlink" title="常见命令"></a>常见命令</h4><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">SETBIT <span class="comment"># 向指定位置(offset)存入一个 0 or 1</span></span><br><span class="line">GETBIT <span class="comment"># 获取指定位置(offset)的bit值</span></span><br><span class="line">BITCOUNT <span class="comment"># 统计BitMap中值为 1 的数量</span></span><br><span class="line">BITFIELD <span class="comment"># 操作BitMap中bit数组中指定位置(offset)的值</span></span><br><span class="line">BITFIELD_RO <span class="comment"># 获取BitMap中bit数组，以10进制返回</span></span><br><span class="line">BITOP <span class="comment"># 将多个BitMap的结果做位运算(与，或，异)</span></span><br><span class="line">BITPOS <span class="comment"># 查找bit数组中指定范围内第一个出现 0 or 1 的位置</span></span><br></pre></td></tr></table></figure></div>

<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>显示用户某个月的签到次数和首次签到时间</li>
<li>统计连续签到 N 天的用户总数</li>
</ul>
<h4 id="简单的签到功能实现"><a href="#简单的签到功能实现" class="headerlink" title="简单的签到功能实现"></a>简单的签到功能实现</h4><ul>
<li><p>签到</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserLocal.getUser().getId();  </span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();  </span><br><span class="line">    <span class="type">String</span> <span class="variable">datePrefix</span> <span class="operator">=</span> localDate.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMM&quot;</span>));  </span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + <span class="string">&quot;:&quot;</span> + datePrefix;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> localDate.getDayOfMonth();  </span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);  </span><br><span class="line">    <span class="keyword">if</span> (BooleanUtil.isFalse(success)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;签到失败&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> Result.ok();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>签到统计<br>从今天开始往前算，统计连续签到的天数，例如用户A的签到BitMap为  <code>00100111100111</code> 而今天是14号，则BitMap从右往左数，统计连续签到天数为 <code>3</code></p>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计今天之前的连续签到天数，并不是统计最大连续签到天数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserLocal.getUser().getId();  </span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();  </span><br><span class="line">    <span class="type">String</span> <span class="variable">datePrefix</span> <span class="operator">=</span> localDate.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMM&quot;</span>));  </span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + <span class="string">&quot;:&quot;</span> + datePrefix;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> LocalDate.now().getDayOfMonth();  </span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(key, BitFieldSubCommands.create()  </span><br><span class="line">            .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth))  </span><br><span class="line">            .valueAt(<span class="number">0</span>)  </span><br><span class="line">    );  </span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) <span class="keyword">return</span> Result.ok(<span class="number">0</span>);  </span><br><span class="line">    <span class="type">Long</span> <span class="variable">value</span> <span class="operator">=</span> result.get(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span> || value == <span class="number">0</span>) <span class="keyword">return</span> Result.ok(<span class="number">0</span>);  </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> ((value &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;<span class="comment">//与运算，判断是否签到, 0 未签到， 1 已签到  </span></span><br><span class="line">        count++;  </span><br><span class="line">        <span class="comment">//为 1 比特位右移一位， 为0则结束循环  </span></span><br><span class="line">        value &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><blockquote>
<p>首先搞清两个概念<br>UV：全称Unique Visitor ，也叫独立访客量，是指通过互联网访问，浏览这个网页的自然人。1天同一个用户多次访问只记录一次<br>PV：全称Page View，也叫页面访问量或者点击量。用户访问一个页面记录一个PV，用户多次打开页面，则记录多次PV</p>
</blockquote>
<p>HyperLogLog (HLL) 是LogLog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。Redis中的HLL是基于String结构实现。单个HLL 的内存永远小于 16kb。但是会有小于 0.81%的误差</p>
<h4 id="常见命令-2"><a href="#常见命令-2" class="headerlink" title="常见命令"></a>常见命令</h4><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">PFADD <span class="comment"># 添加元素到指定key</span></span><br><span class="line">PFCOUNT <span class="comment"># 统计指定key的元素量，基于概率有误差</span></span><br><span class="line">PFMERGE <span class="comment"># 合并其他key</span></span><br></pre></td></tr></table></figure></div>

<h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>一般用于UV统计</p>
<h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">KEYS [正则表达式] <span class="comment"># 查找符合给定表达式的key, 因redis事件处理是单线程的, 所以不建议在生产环境使用</span></span><br><span class="line">EXISTS [key] <span class="comment"># 检查给定key是否存在</span></span><br><span class="line">TYPE [key] <span class="comment"># 返回给定key所存储值的类型</span></span><br><span class="line">TTL [key] <span class="comment"># 返回给定key的剩余生存时间, 单位: 秒</span></span><br><span class="line">DEL [key] <span class="comment"># 当给定key 存在时删除key</span></span><br><span class="line">EXPIRE [key] [seconds] <span class="comment"># 给一个key设置有效期, 有效期结束会自动删除该key</span></span><br><span class="line">TTL [key] <span class="comment"># 查看一个key的剩余有效期</span></span><br></pre></td></tr></table></figure></div>


<h2 id="Java客户端"><a href="#Java客户端" class="headerlink" title="Java客户端"></a>Java客户端</h2><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p>简介：以Redis命令作为方法名称，学习成本较低，简单实用但是Jedis实例是线程不安全的，多线程环境下需要基于连接池使用</p>
<h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>简介：Redisson是一个基于Redis实现的分布式，可伸缩的Java数据结构集合。包含了诸如Map，Queue，Lock，Semaohore，AtomicLong等功能</p>
<h3 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h3><p>简介： Lettuce是基于Netty实现的，支持同步，异步和响应式编程。并且是线程安全的。支持Redis的哨兵模式，集群模式和管道模式</p>
<h2 id="Jedis-1"><a href="#Jedis-1" class="headerlink" title="Jedis"></a>Jedis</h2><h3 id="Jedis入门"><a href="#Jedis入门" class="headerlink" title="Jedis入门"></a>Jedis入门</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@BeforeEach</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;<span class="comment">//初始化链接</span></span><br><span class="line">        jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);  </span><br><span class="line">        jedis.auth(<span class="string">&quot;zora@5774&quot;</span>);  </span><br><span class="line">        jedis.select(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;kita:user:114&quot;</span>, <span class="string">&quot;先辈&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;结果: &quot;</span> + result);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">getResult</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;kita:user:114&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;获取的值: &quot;</span> + getResult);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;  </span><br><span class="line">        jedis.hset(<span class="string">&quot;kita:user:154&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;先辈&quot;</span>);  </span><br><span class="line">        jedis.hset(<span class="string">&quot;kita:user:154&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;24&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.hget(<span class="string">&quot;kita:user:154&quot;</span>, <span class="string">&quot;name&quot;</span>);  </span><br><span class="line">        System.out.println(name);  </span><br><span class="line">  </span><br><span class="line">        Map&lt;String, String&gt; stringMap = jedis.hgetAll(<span class="string">&quot;kita:user:154&quot;</span>);  </span><br><span class="line">        System.out.println(stringMap);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@AfterEach</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutDown</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;  </span><br><span class="line">            jedis.close();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h3><blockquote>
<p>因为Jedis本身线程不安全，再加上如果频繁创建和销毁链接会有性能损耗，因此使用连接池代替直连</p>
</blockquote>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连接工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectFactory</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> JedisPool jedisPool;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();  </span><br><span class="line">        <span class="comment">//池里最大链接数  </span></span><br><span class="line">        config.setMaxTotal(<span class="number">10</span>);  </span><br><span class="line">        <span class="comment">//池里最大空闲连接数  </span></span><br><span class="line">        config.setMaxIdle(<span class="number">10</span>);  </span><br><span class="line">        <span class="comment">//池里最小空闲连接数  </span></span><br><span class="line">        config.setMinIdle(<span class="number">1</span>);  </span><br><span class="line">        <span class="comment">//最大等待时间  </span></span><br><span class="line">        config.setMaxWait(Duration.ofSeconds(<span class="number">1000</span>));  </span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(config, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;password&quot;</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;  </span><br><span class="line">    <span class="meta">@BeforeEach</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;<span class="comment">//池里拿连接</span></span><br><span class="line">	    jedis = JedisConnectFactory.getJedis();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//redis操作与上面直连一致</span></span><br><span class="line">    <span class="meta">@AfterEach</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutDown</span><span class="params">()</span> &#123;  </span><br><span class="line">	    <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">	        <span class="comment">//这里的close并非关闭连接而是把连接还给连接池</span></span><br><span class="line">	        jedis.close();  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<h2 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h2><blockquote>
<p>SpringData是Spring中数据操模块，针对各种数据库的集成，其中对Redis的集成模块叫SpringDataRedis</p>
</blockquote>
<p>简介</p>
<ul>
<li>提供了对不同redis客户端的集成(Lettuce和Jedis)</li>
<li>提供了RedisTemplate统一API操作</li>
<li>支持Redis的发布订阅模型</li>
<li>支持Redis哨兵和Redis集群</li>
<li>支持Lettuce的响应式编程</li>
<li>支持基于JDK, JSON, 字符串, Spring对象的数据序列化和反数列话</li>
<li>支持基于Redis的JDKCollection实现</li>
</ul>
<h3 id="在SpringBoot使用"><a href="#在SpringBoot使用" class="headerlink" title="在SpringBoot使用"></a>在SpringBoot使用</h3><p>除了引入 <code>spring-boot-starter-data-redis</code> 外还需引入连接池 <code>commons-pool2</code><br>然后在 <code>application.yaml</code> 配置文件配置如下信息</p>
<blockquote>
<p>需要注意的是: <mark style="background: #BBFABBA6;">spring-boot-starter-data-redis 3.0.3 版本</mark>需要加上 data<br>而且地址信息是 <mark style="background: #FFF3A3A6;">host</mark> <mark style="background: #FF5582A6;">不是 url 不是 url 不是 url</mark></p>
</blockquote>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="comment"># spring-boot-starter-data-redis 3.0.3版本需要加上 data</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="comment"># 是host而不是 url</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  </span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span>  </span><br><span class="line">      <span class="attr">password:</span> <span class="number">12345678</span></span><br><span class="line">      <span class="comment"># 默认使用lettuce, 如果要使用jedis 需额外引入相关maven依赖</span></span><br><span class="line">      <span class="comment"># 需要手动配置 pool 才会生效</span></span><br><span class="line">      <span class="attr">lettuce:</span>  </span><br><span class="line">        <span class="attr">pool:</span>  </span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">10</span>  </span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">10</span>  </span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">1</span>  </span><br><span class="line">          <span class="attr">max-wait:</span> <span class="number">200</span></span><br></pre></td></tr></table></figure></div>

<h4 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h4><p>SpringDataRedis中提供了一个高度封装的类: RedisTemplate, 针对jedis客户端中大量api进行归类封装, 将同一类型操作封装成operation接口, 具体如下</p>
<ul>
<li>ValueOperations: 简单的K-V 操作</li>
<li>SetOperations: set类型数据操作</li>
<li>ZSetOperations: zset类型数据操作</li>
<li>HashOperations: 针对map类型的数据操作</li>
<li>ListOperations: 针对list类型的数据操作</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"><span class="comment">//通过redisTemplate.opsForXxxx()的方式获取操作对象</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testRedis</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//获取ValueOperations并存值</span></span><br><span class="line">       redisTemplate.opsForValue().set(<span class="string">&quot;test:123&quot;</span>, <span class="string">&quot;测试数据&quot;</span>);</span><br><span class="line">       <span class="comment">//取值</span></span><br><span class="line">       <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;test:123&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p><code>RedisTemplate</code> 可以接受任意 <code>Object</code> 作为值写入Redis，只不过写入前会把 <code>Object</code> 序列化成字节形式，<mark style="background: #FF5582A6;">默认是JDK序列化</mark> 得到的结果类似下面这种</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/06/bxf4E6h1zvw5BdW.png"
                      alt="屏幕截图 2023-03-06 203510.png"
                ></p>
<p><strong>这种不仅可读性差，内存占用还较大</strong> 我们可以自定义RedisTemplate的序列化形式，操作如下</p>
<ol>
<li>定义RedisConfig类，并设置key跟value的序列化器</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;  </span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();  </span><br><span class="line">        <span class="comment">//设置连接工厂  </span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);  </span><br><span class="line">        <span class="comment">//创建JSON序列化工具  </span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();  </span><br><span class="line">        <span class="comment">//设置key序列化  </span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());  </span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());  </span><br><span class="line">        <span class="comment">//设置value序列化  </span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);  </span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);  </span><br><span class="line">        <span class="keyword">return</span> template;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>使用的地方 <code>redisTemplate</code> 添加泛型</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>使用自定义序列化后的结果如下</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/06/XUnRFNEL24G6mgT.png"
                      alt="image.png"
                ></p>
<p>如上图所示，redisTemplate会自动帮我们把对象序列化成json，获取时再把JOSN转成对象。让我们的开发体验更加友好。但是此方法依然存在一些问题，如上图所示，json文本多了一个 <code>@class</code> 这个是<mark style="background: #D2B3FFA6;">JSON转对象</mark> 时要用到的对象类型，会一起写进redis里带来额外的内存开销</p>
<p>为了节省内存空间，我们不使用JSON序列化器来处理value，而是统一使用 String序列化器 <code>StringRedisTemplate</code> 只存String类型的key和value，手动完成对象的序列化和反序列化</p>
<h4 id="关于序列化的小总结"><a href="#关于序列化的小总结" class="headerlink" title="关于序列化的小总结"></a>关于序列化的小总结</h4><blockquote>
<p>RedisTemplate的两种序列化方案</p>
</blockquote>
<ul>
<li><p><strong>方案一</strong><br>自定义RedisTemplate<br>修改RedisTemplate的序列化器为 <code>GenericJackson2JsonRedisSerializer</code><br>缺点: 因需要保存反序列化的对象类名，会占用额外内存空间</p>
</li>
<li><p><strong>方案二</strong><br>使用StringRedisTemplate，不用自己定义<br>不会占用额外内存空间<br>缺点: 读写redis时，需要手动进行序列化和反序列化</p>
</li>
</ul>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>reids</tag>
        <tag>Spring-data-redis</tag>
        <tag>jedis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring同步锁导致事务失效问题</title>
    <url>/spring/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="同步锁导致事务失效"><a href="#同步锁导致事务失效" class="headerlink" title="同步锁导致事务失效"></a>同步锁导致事务失效</h3><p>有些时候我们需要保证一个用户只能在某张表中插入一条数据，例如钱包表，优惠活动一人一单的订单表。通常会在 <code>Service</code> 里使用 <code>synchronize</code> 锁和插入前的数据存在与否判断。但这么做在高并发情况下，短时间内还是会出现插入了多条数据的情况。这与Spring事务执行流程有关。</p>
<h4 id="Spring事务执行流程"><a href="#Spring事务执行流程" class="headerlink" title="Spring事务执行流程"></a>Spring事务执行流程</h4><p>在上述的业务中，代码执行流程大致如下:<br>流程：开启事务 &gt; 上锁 &gt; 执行业务 &gt; 解锁 &gt; 提交事务<br><strong>琐失效的原因：在第一个线程执行完业务解锁的时候，第二个线程开启事务，但这个时候第一个线程的事务还未提交。第二个线程读取到的数据库数据还是旧的，因此造成了业务出错，插入了多条数据。</strong></p>
<blockquote>
<p>需要注意的是，Spring事务提交是AOP生成一个代理对象，在代理对象执行前开启事务，执行完成后提交事务。而这两个操作并不在 synchronized 的锁定范围。所以锁和事务失效了。</p>
</blockquote>
<p>例如下面代码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单机系统下</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createOrder</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserLocal.getUser().getId();  </span><br><span class="line">    <span class="comment">//上锁  </span></span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern()) &#123; <span class="comment">//synchronized放代码块，或者方法上都可以。这里是用用户Id加锁</span></span><br><span class="line">        <span class="comment">//判断是否已经下过单  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query()  </span><br><span class="line">                .eq(<span class="string">&quot;user_id&quot;</span>, userId)  </span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)  </span><br><span class="line">                .count();  </span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;购买失败，只允许购买一次&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//第一次购买，减少库存  </span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> seckillVoucherService  </span><br><span class="line">                .update()  </span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)  </span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)  </span><br><span class="line">                .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)  </span><br><span class="line">                .update();  </span><br><span class="line">        <span class="keyword">if</span> (!res) &#123;  </span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//具体下单业务代码 </span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;<span class="comment">//代码执行到这里的时候，解锁，但还没提交事务</span></span><br><span class="line">&#125; <span class="comment">//解锁后才会开始事务提交，但高并发情况下，就可能在这极短暂的瞬间出现业务异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分布式</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertByRedisLock</span><span class="params">(<span class="type">int</span> index)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">	<span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock_key&quot;</span>);</span><br><span class="line">	lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//....跟上面类似的业务逻辑</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">// 运行结果与上面差不多，但情况会好点</span></span><br></pre></td></tr></table></figure></div>

<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>既然事务里不能使用锁，那可以把锁跟事务分开。让锁包含事务，例如</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserLocal.getUser().getId();  </span><br><span class="line"><span class="comment">//一人一单  </span></span><br><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">	<span class="comment">//Spring非事务方法调用事务方法，事务不生效，但我们可以获取代理对象调用</span></span><br><span class="line">    <span class="type">IOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IOrderService) AopContext.currentProxy();  </span><br><span class="line">    <span class="keyword">return</span> proxy.createOrder(Id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上述代码用在用锁包含了事务方法。让事务开启与提交也在锁内</p>
<blockquote>
<p>Spring非事务方法调用事务方法，事务不生效，但我们可以获取代理对象调用</p>
</blockquote>
<h3 id="同一个类中调用方法导致失效"><a href="#同一个类中调用方法导致失效" class="headerlink" title="同一个类中调用方法导致失效"></a>同一个类中调用方法导致失效</h3><p>开发中难免会对用一个类里的方法进行调用，如果一个没有添加注解 <code>@Transactional</code> 的方法调用了添加注解 <code>@Transactional</code> 的方法，此时事务不会生效。如下所示</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testA</span><span class="params">()</span> &#123; <span class="comment">//没注解</span></span><br><span class="line">	<span class="built_in">this</span>.testB(); <span class="comment">//当前类调用testB，事务并不会生效</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">//有注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>造成这样的原因是，<code>@Transactional</code> 事务是由AOP实现的。只有事务方法被当成类以外的代码调用时，才会由AOP生成的代理对象来管理。</p>
<h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>使用动态代理机制，让代理对象来调用此方法。例如下面这样</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testA</span><span class="params">()</span> &#123; <span class="comment">//没注解</span></span><br><span class="line">	<span class="comment">//获取当前的代理对象</span></span><br><span class="line">	<span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> (Test)AopContext.currentProxy();</span><br><span class="line">	<span class="comment">//由代理对象调用</span></span><br><span class="line">	test.testB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">//有注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>同时还需添加注解 <code>@EnableAspectJAutoProxy(exposeProxy = true)</code> 启用</strong></p>
]]></content>
      <categories>
        <category>note</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>spring</tag>
        <tag>transactional</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-Spring-AOP</title>
    <url>/spring/spring-AOP%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AOP: 面向切面编程, 一种编程范式,指导开发者如何组织程序结构</p>
<p>作用: 在不惊动原始设计的基础上进行功能增强</p>
<p>Spring理念: 无入侵式\无侵入式 编程</p>
<p><strong>代理(Proxy): 本质是采用代理模式实现</strong></p>
<p><strong>切入点(PointCut): 匹配连接点的式子, 可以理解成共性功能的方法描述</strong></p>
<p><strong>连接点(JoinPoint): 可以被增强的方法, 可以理解成任意方法</strong></p>
<p><strong>通知(Advice): 要添加的功能, 共性功能,</strong></p>
<p><strong>切面(Aspect): 把通知应用到切入点的过程</strong></p>
<p><strong>目标对象(Target): 被代理的原始对象的目标对象</strong></p>
<h2 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h2><p>Spring自带aop相关依赖,这里只需要导入Aspectj即可</p>
<h4 id="导入Maven坐标"><a href="#导入Maven坐标" class="headerlink" title="导入Maven坐标"></a>导入Maven坐标</h4><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--aspectj坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="通知类"><a href="#通知类" class="headerlink" title="通知类"></a>通知类</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通知类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Aspect</span> 告诉Spring这是个AOP增强</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个 &lt;切入点&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Pointcut</span> 切入点注解</span></span><br><span class="line"><span class="comment">     * &quot;execution(void com.eoezora.aop_spring.dao.BookDao.update())&quot; 执行目标包下的某个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.eoezora.aop_spring.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">commonUpdate</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个 &lt;通知&gt; 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Before</span> 在方法执行前通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@After</span> 在方法执行后通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@AfterReturning</span> 放回后通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@AfterThrowing</span> 发生异常后通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Around</span> 在方法执行前和执行后通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;commonUpdate()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commonMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Now: &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//环绕方法的使用， 因为无法预测原始方法是否会出异常, 所以这里需要把他抛出去</span></span><br><span class="line">    <span class="comment">//获取原始方法相关签名信息 使用point.getSignature(); 可以获取原始代码的类名, 增强的方法名等</span></span><br><span class="line">    <span class="meta">@Around(&quot;commonSelect()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">commonMethod</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A: &quot;</span> + System.currentTimeMillis());</span><br><span class="line">        <span class="comment">//原始方法的调用并获取原始方法执行后的的返回值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> point.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;B: &quot;</span> + System.currentTimeMillis());</span><br><span class="line">        <span class="comment">//返回原始方法执行后的返回值</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="接口实现类"><a href="#接口实现类" class="headerlink" title="接口实现类"></a>接口实现类</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;book save...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&lt;连接点&gt; 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book update...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book select...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="Spring配置类"><a href="#Spring配置类" class="headerlink" title="Spring配置类"></a>Spring配置类</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.eoezora&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="comment">//开启aop自动代理</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol>
<li>Spring容器启动</li>
<li>读取所有切面配置中的切入点</li>
<li>初始化Bean, 判定Bean对应类中的方法是否匹配到任意切入点</li>
</ol>
<ul>
<li>匹配失败: 创建对象</li>
<li>匹配成功: 创建原始对象的代理对象</li>
</ul>
<ol start="4">
<li>获取Bean执行方法</li>
</ol>
<ul>
<li>获取Bean, 调用方法并执行</li>
<li>获取的Bean是代理对象,根据代理对象的运行模式运行原始方法与增强内容</li>
</ul>
<p><strong>整个实现过程使用代理模式实现</strong></p>
<h2 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h2><p>切入点表达式标准格式: 动作关键字(访问修饰符 返回值 包名.类&#x2F;接口名.方法名(参数) 异常名)</p>
<p>可以使用通配符描述切入点,快速描述,例如</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配 com.eoezora包下的任意包中的BookDao类或接口中update开头的带头一个任意参数的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> * com.eoezora.*.BookDao.update*(*))</span><br><span class="line"><span class="comment">//匹配com包下的任意包中的BookDao类或接口中所有update方法</span></span><br><span class="line">execution(<span class="keyword">public</span> BookDao com..BookDao.update(..))</span><br><span class="line"><span class="comment">// + 用于匹配子类类型, 任意返回值,任意包下的以BookDao结尾的类或接口的子类中的任意方法 </span></span><br><span class="line">execution(* *..*BookDao+.(..))</span><br></pre></td></tr></table></figure></div>

<h2 id="获取通知数据"><a href="#获取通知数据" class="headerlink" title="获取通知数据"></a>获取通知数据</h2><h3 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h3><p><strong>JoinPoint</strong>: 适用于前置, 后置 返回后, 抛出异常后通知</p>
<p><strong>ProceedJoinPoint</strong>: 适用于环绕通知</p>
<h3 id="获取返回值"><a href="#获取返回值" class="headerlink" title="获取返回值"></a>获取返回值</h3><p><strong>返回后通知</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此方法里带参数,有JoinPoint的话,始终保持第一个参数, 后面接返回的</span></span><br><span class="line"><span class="comment"> * returning = &quot;ret&quot; ret是该方法的参数, 也是<span class="doctag">@AfterReturning</span>返回的原始方法的返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AfterReturning(value = &quot;commonTest()&quot;, returning = &quot;ret&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">commonMethod</span><span class="params">(JoinPoint point, Object ret)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>环绕通知</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 环绕方法执行原型方法后会返回原始方法的返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Around(&quot;commonTest()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">commonMethod</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">//如果原始方法返回100, 则ret就是100</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> point.proceed();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="获取异常"><a href="#获取异常" class="headerlink" title="获取异常"></a>获取异常</h3><p><strong>抛出异常后通知</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抛出异常后返回 &quot;异常&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AfterThrowing(value = &quot;commonTest()&quot;, throwing = &quot;t&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commonMethod</span><span class="params">(Throwable t)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>环绕通知</strong></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Long <span class="title function_">getDataId</span><span class="params">(ProceedingJoinPoint point, Authorization auth)</span> &#123; </span><br><span class="line">	<span class="comment">// 通过joinPoint获取被注解方法  </span></span><br><span class="line">		<span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) point.getSignature();</span><br><span class="line">	<span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methodSignature.getMethod();  </span><br><span class="line">	<span class="comment">// 使用spring的DefaultParameterNameDiscoverer获取方法形参名数组  </span></span><br><span class="line">	String[] paramNames = nameDiscoverer.getParameterNames(method);  </span><br><span class="line">	<span class="comment">// 解析过后的Spring表达式对象, 获取注解上的 id 值</span></span><br><span class="line">	<span class="type">Expression</span> <span class="variable">storeExpSQL</span> <span class="operator">=</span> parser.parseExpression(auth.id());  </span><br><span class="line">	<span class="comment">// spring的表达式上下文对象  </span></span><br><span class="line">	<span class="type">EvaluationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>();  </span><br><span class="line">	Object[] args = point.getArgs();  </span><br><span class="line">	<span class="comment">// 给上下文赋值  </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) context.setVariable(Objects.requireNonNull(paramNames)[i], args[i]);  </span><br><span class="line">	<span class="keyword">return</span> (Long) storeExpSQL.getValue(context);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>note</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>spring</tag>
        <tag>aop</tag>
        <tag>Aspectj</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-Spring核心容器</title>
    <url>/spring/spring-IoC%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="控制反转Ioc"><a href="#控制反转Ioc" class="headerlink" title="控制反转Ioc"></a><strong>控制反转Ioc</strong></h2><p>使用对象时,由主动new产生对象转换为由<strong>外部</strong>提供对象, 此过程中创建对象控制权由程序转移到外部,此思想称为控制反转</p>
<p>Spring对Ioc思想的实现</p>
<ul>
<li>Spring提供了一个容器,称为Ioc容器，用来充当Ioc思想中的”外部”</li>
<li>Ioc容器负责对象创建,初始化等一系工作, 被创建或被管理的对象在Ioc容器中被称为<strong>Bean</strong></li>
</ul>
<p>DI(Dependency Injection): 依赖注入</p>
<ul>
<li>在容器中建立的Bean与Bean之间的依赖关系的整个过程,称为依赖注入</li>
</ul>
<p>目标: 充分解耦</p>
<ul>
<li>使用Ioc容器管理Bean</li>
<li>在Ioc容器内将有依赖关系的Bean进行关系绑定(DI)</li>
</ul>
<p>适合给容器管理的Bean</p>
<ul>
<li>表现层对象</li>
<li>业务层对象</li>
<li>数据层对象</li>
<li>工具对象</li>
</ul>
<p>不适合给容器管理的Bean</p>
<ul>
<li>封装实体的域对象</li>
</ul>
<h2 id="xml配置Bean"><a href="#xml配置Bean" class="headerlink" title="xml配置Bean"></a>xml配置Bean</h2><p>一个Bean配置文件</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--id为Bean名字--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--name 为bean起别名--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Class是bean接口对应实现类--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--scope时bean的作用范围,默认singleton单例 | prototype非单例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookInfo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.eoezora.springdemo.dao.impl.PysBookImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--id为Bean名字 Class是bean接口对应实现类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.eoezora.springdemo.services.impl.BookServerImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置当前Bean的属性--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--name属性表示配置哪一个属性--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--ref表示参照哪个Bean--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookInfo&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookInfo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>Java使用代码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//根据配置文件获取IoC容器</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//ctx.getBean(bean的id);</span></span><br><span class="line">    <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">    bookService.addBook(<span class="number">1</span>, <span class="string">&quot;weee&quot;</span>);</span><br><span class="line">    bookService.getBook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>业务层例子</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.eoezora.springdemo.services.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.eoezora.springdemo.dao.BookInfo;</span><br><span class="line"><span class="keyword">import</span> com.eoezora.springdemo.services.BookService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServerImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//使用DI依赖注入时, 业务层Service中使用new的方式创建的对象要删除</span></span><br><span class="line">    <span class="comment">//在xml配置DI注入，运行后容器会帮我们自动</span></span><br><span class="line">    BookInfo bookInfo;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BookInfo <span class="title function_">getBook</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;return a book...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBook</span><span class="params">(<span class="type">int</span> id, String bName)</span> &#123;</span><br><span class="line">        bookInfo.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;add a book -&gt; &quot;</span> + id + <span class="string">&quot; - &quot;</span> + bName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Set方法, IoC供容器调用赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookInfo</span><span class="params">(BookInfo bookInfo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookInfo = bookInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="加载properties文件"><a href="#加载properties文件" class="headerlink" title="加载properties文件"></a>加载properties文件</h2><p>在applicationContext.xml里开辟一块新的命名空间</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 新增下面这三行 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--xmlns:context=&quot;http://www.springframework.org/schema/context&quot;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--http://www.springframework.org/schema/context--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--http://www.springframework.org/schema/context/spring-context.xsd--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 下面是新增好的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--新增一个property占位符, location是要加载的proper文件路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;bookInfo.properties&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.eoezora.springdemo.services.impl.BookServerImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置当前Bean的属性--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--name属性表示配置哪一个属性--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--ref表示参照哪个Bean--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookInfo&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookInfo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置完成后就可以使用$&#123;key&#125; 的形式读取目标proper文件的内容 --&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.eoezora.springdemo.services.impl.BookServerImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookInfo&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookInfo&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;book.name&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 假设 bookInfo.properties如下  --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">           book.name=kafka的城堡</span></span><br><span class="line"><span class="comment">        --&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><p>Spring3.0后使用纯注解开发,使用**@Configuration**代替了xml配置文件.</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在实现类上添加注解@Component来定义一个Bean</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Component(&quot;bean名字&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> <span class="keyword">implements</span> <span class="title class_">someInterface</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//设置bean扫描包路径</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.eoezora.spring_ano&quot;)</span></span><br><span class="line"><span class="comment">//加载外部配置文件</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//使用AnnotationConfigApplicationContext加载配置类获取容器</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">    <span class="type">IServices</span> <span class="variable">services</span> <span class="operator">=</span> context.getBean(IServices.class);</span><br><span class="line">    services.printData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="作用范围-生命周期"><a href="#作用范围-生命周期" class="headerlink" title="作用范围|生命周期"></a>作用范围|生命周期</h3><p>作用范围: 在接口实现类添加注解 @Scope() 参考xml配置的scope属性</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CommonServices</span>&#123;&#125;</span><br></pre></td></tr></table></figure></div>
<p>Bean的生命周期注解</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标注在方法上,表示该方法是Bean的初始化方法</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="comment">//标注在方法上,表示该方法是Bean的销毁方法</span></span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printData</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(commonDao.getData());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用注解@Autowired实现自动装配, 按类型来</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="comment">//当有多个同一接口的实现类时,使用@Qualifier实现指定装配</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;bean的名字&quot;)</span></span><br><span class="line"><span class="keyword">private</span> CommonDao commonDao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Value</span>装备基本数据类型</span></span><br><span class="line"><span class="comment"> * 可以把配置文件里的数值装配到该变量</span></span><br><span class="line"><span class="comment"> * 假设在配置文件类里使用了 <span class="doctag">@PropertySource</span>(&quot;jdbc.properties&quot;) 加载了jdbc配置</span></span><br><span class="line"><span class="comment"> * 可以使用 $&#123;key-name&#125; 的形式获取数据</span></span><br><span class="line"><span class="comment"> *  jdbc.url=http://localhost:3306/eoezora</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String url;</span><br></pre></td></tr></table></figure></div>

<p>注解管理第三方Bean</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加@Bean注解表示该方法返回值是一个Bean</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    ds.setXXXX();</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第三方Bean的依赖注入</span></span><br><span class="line"><span class="comment"> * 添加<span class="doctag">@Bean</span>注解表示该方法返回值是一个Bean</span></span><br><span class="line"><span class="comment"> * 如果要给第三方的Bean依赖注入,用形参的形式给到对应方法里</span></span><br><span class="line"><span class="comment"> * spring会从容器里找到该形参的Bean然后传到指定方法</span></span><br><span class="line"><span class="comment"> * 以下方方法为例, 我要传入数据库配置信息获得Druid连接池</span></span><br><span class="line"><span class="comment"> * 我定义一个SqlConfig存放数据库信息</span></span><br><span class="line"><span class="comment"> * 然后给到dataSource()方法</span></span><br><span class="line"><span class="comment"> * Spring会自动帮我们装配参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(SqlConfig sc)</span> &#123;</span><br><span class="line">    <span class="comment">//bd do something...</span></span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    ds.setUrl(sc.getUrl());</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>note</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>spring</tag>
        <tag>ioc</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-SpringBoot</title>
    <url>/spring/spring-boot/</url>
    <content><![CDATA[<h2 id="Maven坐标"><a href="#Maven坐标" class="headerlink" title="Maven坐标"></a>Maven坐标</h2><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--德鲁伊连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.13-SNSAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>note</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-SpringMVC</title>
    <url>/spring/spring-mvc/</url>
    <content><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><hr>
<h2 id="SpringMVC与Tomcat整合"><a href="#SpringMVC与Tomcat整合" class="headerlink" title="SpringMVC与Tomcat整合"></a>SpringMVC与Tomcat整合</h2><p>需要注意的是Tomcat 10与spring mvc不兼容. 请使用tomcat 8</p>
<h3 id="导入maven坐标"><a href="#导入maven坐标" class="headerlink" title="导入maven坐标"></a>导入maven坐标</h3><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax-servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="创建控制类"><a href="#创建控制类" class="headerlink" title="创建控制类"></a>创建控制类</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Controller 注解表示这是一个Spring Bean</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问入口</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/sign-in&quot;)</span></span><br><span class="line">    <span class="comment">//设置返回值为响应内容</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">OnAccountSignIn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Account: Sign In&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;msg&#x27;:&#x27;success&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="创建Spring配置类"><a href="#创建Spring配置类" class="headerlink" title="创建Spring配置类"></a>创建Spring配置类</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring配置类</span></span><br><span class="line"><span class="comment"> * 设置组件扫描路径,加载Bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.eoezora&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="创建SpringMVC配置"><a href="#创建SpringMVC配置" class="headerlink" title="创建SpringMVC配置"></a>创建SpringMVC配置</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个Servlet容器启动的配置类,在里面加载Spring的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载Spring mvc 容器配置</span></span><br><span class="line"><span class="comment">     * SpringMVC的配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        <span class="comment">//SpringMVConfig.class</span></span><br><span class="line">        context.register(SpringMVConfig.class);</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置哪些请求归SpringMVC处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;&quot;/&quot;&#125; 表示所有请求归SpringMVC处理</span></span><br><span class="line"><span class="comment">         * 这个设置会把静态资源也给Spring处理</span></span><br><span class="line"><span class="comment">         * 因为静态资源要给tomcat处理, 所以这个操作会导致静态资源访问不到</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载Spring容器配置</span></span><br><span class="line"><span class="comment">     * Spring的配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        <span class="comment">//SpringConfig.class</span></span><br><span class="line">        context.register(SpringConfig.class);</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>简化版</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个Servlet容器启动的配置类,在里面加载Spring的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载Spring mvc 容器配置</span></span><br><span class="line"><span class="comment">     * SpringMVC的配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载Spring容器配置</span></span><br><span class="line"><span class="comment">     * Spring的配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置哪些请求归SpringMVC处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;&quot;/&quot;&#125; 表示所有请求归SpringMVC处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>静态资源访问不到的解决方式</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMVCSupport</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//当访问/pages/xxx时,走/pages目录里的内容 </span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/pages/**&quot;</span>).addResourceLocations(<span class="string">&quot;/pages/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="工作流程分析"><a href="#工作流程分析" class="headerlink" title="工作流程分析"></a>工作流程分析</h2><blockquote>
<p>   以上方例子为例</p>
</blockquote>
<h3 id="服务器初始化"><a href="#服务器初始化" class="headerlink" title="服务器初始化"></a>服务器初始化</h3><ol>
<li>服务器启动, 执行<strong>ServletContainersInitConfig</strong>类初始化web容器</li>
<li>执行 <strong>createServletApplicationContext()</strong> 方法, 创建 <strong>WebApplicationContext</strong> 对象</li>
<li>加载<strong>SpringConfig</strong></li>
<li>执行 <strong>@ComponentScan(“com.eoezora”)</strong> 扫描对应包里的<strong>Bean</strong></li>
<li>加载 <strong>Controller</strong> [<strong>AccountController.calss</strong>] 每个 <strong>@RequestMapping</strong> 里都是一个方法</li>
<li>执行 <strong>getServletMappings()</strong> 方法, 定义所有请求都走SpringMVC</li>
</ol>
<h3 id="单词请求过程"><a href="#单词请求过程" class="headerlink" title="单词请求过程"></a>单词请求过程</h3><ol>
<li>发送请求: <a class="link"   href="http://localhost/sign-in" >http://localhost/sign-in <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>web容易检测到所有请求都走SpringMVC, 所以转交给SpringMVC处理</li>
<li>解析请求路径 localhost&#x2F;sign-in -&gt; sign-in</li>
<li>根据请求路径,执行对象方法 sign-in -&gt; OnAccountSignIn()</li>
<li>执行方法 -&gt; OnAccountSignIn()</li>
<li>检测到有 @ResponseBody 将方法返回值作为响应体返回给请求方</li>
</ol>
<h2 id="Bean的加载控制"><a href="#Bean的加载控制" class="headerlink" title="Bean的加载控制"></a>Bean的加载控制</h2><p>在开发中SpringMVC一般只管controller包下的bean,也就是表现层的bean.</p>
<p>而Spring管理的是业务层,数据层的bean (service,dao)</p>
<p><strong>应功能不同, 我们应该避免spring错误地加载到SpringMVC的bean</strong></p>
<h3 id="SpringMVC相关Bean管理"><a href="#SpringMVC相关Bean管理" class="headerlink" title="SpringMVC相关Bean管理"></a>SpringMVC相关Bean管理</h3><p>SpringMVC加载的bean对应的包应均在com.xxx.controller里,在扫描时,精确写到 com.xxx.controller</p>
<h3 id="Spring相关Bean管理"><a href="#Spring相关Bean管理" class="headerlink" title="Spring相关Bean管理"></a>Spring相关Bean管理</h3><p>Spring加载Bean设定扫描范围为com.xxxx, 然后排除掉controller包内的bean</p>
<p>Spring加载Bean设定扫描范围为精准范围, 如com.xxx.service, com.xxx.dao</p>
<p><strong>例子</strong></p>
<p>spring精准扫描</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.eoezora.service&quot;, &quot;com.eoezora.dao&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>排除指定的bean</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按照注解过滤</span></span><br><span class="line"><span class="comment"> * 排除注解为 <span class="doctag">@Controller</span> 的Bean</span></span><br><span class="line"><span class="comment"> * includeFilters: 包含</span></span><br><span class="line"><span class="comment"> * excludeFilters: 排除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.eoezora&quot;, excludeFilters = @ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">        type = FilterType.ANNOTATION,</span></span><br><span class="line"><span class="meta">        classes = Controller.class</span></span><br><span class="line"><span class="meta">))</span></span><br></pre></td></tr></table></figure></div>

<h1 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h1><hr>
<h2 id="请求映射路径"><a href="#请求映射路径" class="headerlink" title="请求映射路径"></a>请求映射路径</h2><p><strong>@RequestMapping: 设置当前控制器的请求路径, 可以设置在方法跟类上, 设置在类上表示整个类的方法访问前缀, 加载方法上表示访问的具体路径.</strong></p>
<p>请求映射路径重复问题: 在开发中，我们可能会遇到不同模块<strong>同个访问入口名</strong>的问题, 一般解决方法是在访问路口前面加上模块的名字, 比如: User和Book模块下都有一个save的入口.如果都在这两模块里定义save. Spring启动时会报错, 只需在save前面加上模块名即可解决</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">//访问入口前面加上模块名解决入口重复问题</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OnSave</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user save&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">     <span class="comment">//访问入口前面加上模块名解决入口重复问题</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/book/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OnSave</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Book save&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上述的方法可以解决入口重复的问题, 但是当几个模块里有很多的重名入口时, 你一个个去写会很耗时, 且耦合度很高.所以我们可以把 @RequestMapping(“&#x2F;模块名”) 写在类上, 如下方所示, 访问</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">//在类上添加 @RequestMapping(&quot;/user&quot;), </span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">//访问入口前面加上模块名解决入口重复问题</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OnSave</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user save&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/book&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">     <span class="comment">//访问入口前面加上模块名解决入口重复问题</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OnSave</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Book save&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>访问路劲都是: <a class="link"   href="https://localhost/user/save" >https://localhost/user/save <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 或 <a class="link"   href="https://localhost/book/save" >https://localhost/book/save <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h2><h3 id="普通参数"><a href="#普通参数" class="headerlink" title="普通参数"></a>普通参数</h3><p><strong>url地址传参, 地址参数名和形参变量名相同, 定义形参即可接收参数</strong></p>
<p>例如: 请求地址是 <a class="link"   href="http://127.0.0.1/testAccount/login?name=test&password=35r356464467" >http://127.0.0.1/testAccount/login?name=test&amp;password=35r356464467 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">OnAccountSignIn</span><span class="params">(String name, String password)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Account: &quot;</span> + name + <span class="string">&quot; Sign In - &quot;</span> + password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印 Account: test Sign In - 35r356464467</span></span><br></pre></td></tr></table></figure></div>

<p>形参变量名与请求参数名不一样怎么办？通过@RequestParam 把形参变量与请求变量绑定一起 </p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形参与请求参数名字不一样的</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">OnAccountSignIn</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String userName, <span class="meta">@RequestParam(&quot;name&quot;)</span> String pwd)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Account: &quot;</span> + userName + <span class="string">&quot; Sign In - &quot;</span> + pwd);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印 Account: test Sign In - 35r356464467</span></span><br></pre></td></tr></table></figure></div>

<h3 id="POJO参数"><a href="#POJO参数" class="headerlink" title="POJO参数"></a>POJO参数</h3><p>spring可以会按请求参数跟你给的形参pojo的属性名进行匹配. 并自动赋值, 且支持为pojo里的引用行对象赋值, 以下为例子</p>
<p>假设请求地址为: <a class="link"   href="http://127.0.0.1:81/testAccount/login?name=test&password=35r356464467&address.city=%E7%85%8E%E9%B1%BC%E8%A1%97&address.country=%E8%8D%94%E6%9E%9D%E6%98%9F" >http://127.0.0.1:81/testAccount/login?name=test&amp;password=35r356464467&amp;address.city=煎鱼街&amp;address.country=荔枝星 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>控制器访问入口</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">OnAccountSignIn</span><span class="params">(User user)</span> &#123;<span class="comment">//这里形参是一个POJO</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Account: &quot;</span> + user.getName() + <span class="string">&quot; Sign In - &quot;</span> + user.getPassword());</span><br><span class="line">    <span class="keyword">return</span> user.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>User类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>Address类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String country;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>Spring会把接受到的参数一一与形参的属性名进行匹配,并赋值, 且当形参属性有引用类型时, Spring也会自动解析并赋值.</p>
<p><strong>name&#x3D;test&amp;password&#x3D;35r356464467&amp;address.city&#x3D;煎鱼街&amp;address.country&#x3D;荔枝星</strong></p>
<p>参数有<strong>name password address.city address.country</strong> 其中name和password是基本数据类型会直接赋值给User中的name和password, 而address.city address.country是引用数据类型则会赋值给对象Address中的city和country</p>
<h3 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h3><p>有时候我们的参数会以数组的形式过来</p>
<p>假设请求地址为: <a class="link"   href="http://127.0.0.1:81/testAccount/login?name=test&password=35r356464467&address.city=%E7%85%8E%E9%B1%BC%E8%A1%97&address.country=%E8%8D%94%E6%9E%9D%E6%98%9F&hobby=c&hobby=t&hobby=r&hobby=l" >http://127.0.0.1:81/testAccount/login?name=test&amp;password=35r356464467&amp;address.city=煎鱼街&amp;address.country=荔枝星&amp;hobby=c&amp;hobby=t&amp;hobby=r&amp;hobby=l <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">OnAccountSignIn</span><span class="params">(User user, <span class="meta">@RequestParam</span> List&lt;String&gt; hobby)</span> &#123;</span><br><span class="line">    System.out.println(user.toString());</span><br><span class="line">    <span class="keyword">return</span> user + hobby.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印 &#123;name=&#x27;test&#x27;, password=&#x27;35r356464467&#x27;, address=Address(country=afafgfg, city=asdfas)&#125;[c, t, r, l]</span></span><br></pre></td></tr></table></figure></div>

<p><strong>需要注意的是hobby 可以是数组String[] 也可以是集合,若写集合则需要添加注解@RequestParam</strong></p>
<h3 id="JSON数据参数"><a href="#JSON数据参数" class="headerlink" title="JSON数据参数"></a>JSON数据参数</h3><p>导入坐标</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.0-rc1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>在Spring配置类开启json解析支持</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br></pre></td></tr></table></figure></div>

<p>JSON数据模型, 参考User类与Address类</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="comment">//第一条数据</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eoezora&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;afgeajgoij4354&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;country&quot;</span><span class="punctuation">:</span> <span class="string">&quot;afjwoif&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;awffg&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">//第二条数据</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eoezora42&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;afgeajgoij43555554&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;country&quot;</span><span class="punctuation">:</span> <span class="string">&quot;afjwoif&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;awffg&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></div>

<p>访问入口</p>
<p>因为JSON数据是在Body里的所以需要在对应形参面前添加@RequestBody, <strong>且一个方法只能添加一个.</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//访问入口</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="comment">//设置返回值为响应内容</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">OnAccountSignIn</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; jsonData)</span> &#123;</span><br><span class="line">    System.out.println(jsonData);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制台输出 [&#123;name=&#x27;eoezora&#x27;, password=&#x27;afgeajgoij4354&#x27;, address=Address(country=afjwoif, city=awffg)&#125;, &#123;name=&#x27;eoezora42&#x27;, password=&#x27;afgeajgoij43555554&#x27;, address=Address(country=afjwoif, city=awffg)&#125;] </span></span><br></pre></td></tr></table></figure></div>

<h2 id="日期类型参数传递"><a href="#日期类型参数传递" class="headerlink" title="日期类型参数传递"></a>日期类型参数传递</h2><p>日期时间类型的参数, 由于日期类型数据基于系统不同格式也不尽相同, 例如以下几种</p>
<p><strong>SpringMVC默认支持自动解析第二种格式的时间</strong>, 也就是<strong>2012&#x2F;04&#x2F;01</strong></p>
<ol>
<li>2012-04-01</li>
<li>2012&#x2F;04&#x2F;01</li>
<li>04&#x2F;01&#x2F;2012</li>
</ol>
<p>遇到时间类型参数的时间格式不一致时, 我们可以使用注解 @DateTimeFormat 注解在方法形参上. <strong>其中pattern属性为时间格式</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/time&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">OnTime</span><span class="params">(<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date date)</span> &#123;</span><br><span class="line">    System.out.println(date);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入 http://127.0.0.1:81/time?date=2021-04-01</span></span><br><span class="line"><span class="comment">//输出Thu Apr 01 00:00:00 CST 2021</span></span><br></pre></td></tr></table></figure></div>

<h2 id="响应json数据"><a href="#响应json数据" class="headerlink" title="响应json数据"></a>响应json数据</h2><p>响应数据需要在对应方法添加@ResponseBody注解, 作用是<strong>设置当前方法的返回值为此次请求的响应内容</strong>,一般我们返回的响应内容都是JSON数据, 只要我们添加依赖 <strong>jackson-databind</strong> SpringMVC就会自动把我们的POJO对象解析成JSON数据并返回响应, 同时Jackson也会把接受的参数解析成POJO参数供我们使用. 这里演示的是多个POJO对象, 用了集合, 也是可以接受单个POJO的</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">OnAccountSignIn</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; jsonData)</span> &#123;</span><br><span class="line">    System.out.println(jsonData);</span><br><span class="line">    <span class="keyword">return</span> jsonData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入http://127.0.0.1:81/login</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        &quot;name&quot;: &quot;eoezora&quot;,</span></span><br><span class="line"><span class="comment">        &quot;password&quot;: &quot;asdexasdex&quot;,</span></span><br><span class="line"><span class="comment">        &quot;address&quot;: &#123;</span></span><br><span class="line"><span class="comment">            &quot;country&quot;: &quot;usa&quot;,</span></span><br><span class="line"><span class="comment">            &quot;city&quot;: &quot;dc&quot;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        &quot;name&quot;: &quot;eoezora17&quot;,</span></span><br><span class="line"><span class="comment">        &quot;password&quot;: &quot;asdexasdex&quot;,</span></span><br><span class="line"><span class="comment">        &quot;address&quot;: &#123;</span></span><br><span class="line"><span class="comment">            &quot;country&quot;: &quot;usa&quot;,</span></span><br><span class="line"><span class="comment">            &quot;city&quot;: &quot;dc&quot;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">//输出[&#123;name=&#x27;eoezora&#x27;, password=&#x27;asdexasdex&#x27;, address=Address(country=usa, city=dc)&#125;, &#123;name=&#x27;eoezora17&#x27;, password=&#x27;asdexasdex&#x27;, address=Address(country=usa, city=dc)&#125;]</span></span><br></pre></td></tr></table></figure></div>

<h1 id="REST风格开发"><a href="#REST风格开发" class="headerlink" title="REST风格开发"></a>REST风格开发</h1><hr>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>REST: Representational State Transfer - 表现形式状态转换</p>
<p>REST是一种风格,是一种约定,不是规范,可以被打破</p>
<p>根据REST风格对资源进行访问称为RESTfull</p>
<ul>
<li>传统风格:<ul>
<li><a class="link"   href="http://127.0.0.1:81/user/getByID?id=114514" >http://127.0.0.1:81/user/getByID?id=114514 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  获取用户</li>
<li><a class="link"   href="http://127.0.0.1:81/user/login" >http://127.0.0.1:81/user/login <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>              用户登录</li>
</ul>
</li>
<li>REST风格:<ul>
<li><a class="link"   href="http://127.0.0.1:81/user/114514" >http://127.0.0.1:81/user/114514 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>             获取用户</li>
<li><a class="link"   href="http://127.0.0.1:81/user" >http://127.0.0.1:81/user <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>                    用户登录</li>
</ul>
</li>
</ul>
<p><strong>优点:</strong> </p>
<ol>
<li>书写简化</li>
<li>隐藏访问行文, 无法得知地址获取资源操作信息</li>
</ol>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以POST方式请求</span></span><br><span class="line"><span class="comment"> * 访问路径: https://localhost/users/1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id 地址上的参数 1 参数名字要与 value = &quot;/users/&#123;id&#125;&quot;中的一致</span></span><br><span class="line"><span class="comment"> * 方法上的形参前面要添加注解 <span class="doctag">@PathVariable</span> 表示这是一个RESTfull风格的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/users/&#123;id&#125;&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OnAccountLogin</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;login request data -&gt; &quot;</span> + id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以GET方式请求</span></span><br><span class="line"><span class="comment"> * 访问路径: https://localhost/users/1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id 地址上的参数 1 参数名字要与 value = &quot;/users/&#123;id&#125;&quot;中的一致</span></span><br><span class="line"><span class="comment"> * 方法上的形参前面要添加注解 <span class="doctag">@PathVariable</span> 表示这是一个RESTfull风格的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/users/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OnAccountRegister</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;register request data -&gt; &quot;</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h2><p>一个控制类里会有很多的入口方法, 如果一个个写@RequestMapping,然后指定请求方式 GET or POST,访问入口会很麻烦,重复的代码会很多. 我们可以提取共同点出来. 例如以下例子</p>
<h3 id="一般写法"><a href="#一般写法" class="headerlink" title="一般写法"></a><strong>一般写法</strong></h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/users/&#123;id&#125;&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">OnAccountLogin</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;login request data -&gt; &quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/users/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">OnAccountRegister</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;register request data -&gt; &quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="简化后"><a href="#简化后" class="headerlink" title="简化后"></a><strong>简化后</strong></h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果该Controller里的所有方法都有返回值,那么可以使用 <span class="doctag">@RestController</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RestController</span> 等于 <span class="doctag">@Controller</span>和<span class="doctag">@ResponseBody</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提取入口的访问前缀注解到类上</span></span><br><span class="line"><span class="comment"> * 代表该类下的所有访问入口都带此前缀</span></span><br><span class="line"><span class="comment"> * http://localhost/users/xxx</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * POST请求的入口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 路径参数</span></span><br><span class="line"><span class="comment">     * 示例请求地址 http://localhost/users/1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OnAccountLogin</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;login request data -&gt; &quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GET请求的入口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 路径参数</span></span><br><span class="line"><span class="comment">     * 示例请求地址 http://localhost/users/1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OnAccountRegister</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;register request data -&gt; &quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>note</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>spring</tag>
        <tag>mybatis</tag>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-Spring事务</title>
    <url>/spring/spring-%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>事务作用</strong>: 在数据层保证一系列数据库操作同时成功或同时失败</p>
<p><strong>Spring事务作用</strong>: 在<strong>数据层</strong>或<strong>业务层</strong>的一些列数据库操作同时成功或同时失败</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>通过相同的数据源<strong>DataSource</strong>来管理sql的事务</p>
<ol>
<li>在业务层的接口上, 要添加Spring事务的方法上添加注解 <strong>@Transactional</strong>, 一般是使用在业务层接口上,不会用在实现类上.</li>
<li><strong>@Transactional</strong>也可以使用在类上,使用在类上表示该类所有方法都开启事务</li>
<li>设置事务管理器</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">    <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    transactionManager.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> transactionManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>在Spring设置里打开注解事务驱动</li>
</ol>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开起启用注解事务</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//事务简单例子</span></span><br><span class="line"><span class="comment">//本方法中有三个事务分别是 test_Tran() print_a() print_b()</span></span><br><span class="line"><span class="comment">//在实际运行中print_a()和print_b()会加入到test_Tran()中形成一个新的事务, 从而实现print_a()和print_b()的同时成功或同时失败</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_Tran</span><span class="params">()</span>&#123;</span><br><span class="line">    common.print_a();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    common.print_b();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">common</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print_a</span><span class="params">()</span> &#123;</span><br><span class="line">        sout(<span class="string">&quot;2333&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print_b</span><span class="params">()</span> &#123;</span><br><span class="line">        sout(<span class="string">&quot;12345&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="事务角色"><a href="#事务角色" class="headerlink" title="事务角色"></a>事务角色</h2><p>事务管理员: 发起事务方, 在Spring中通常指代业务开始事务的方法</p>
<p>事务协调员: 加入事务方, 在Spring中通常指数据层方法,也可以是业务层方法</p>
<p>在sql中事务是隔离互不影响的, 比如事务T1成功-事务T2失败, 这两都不会回滚,而Spring的事务, 会让指定的事务T1,T2加入自己的事务中成为一个新的事务T3,T3如果执行到某一布出错就会回滚事务,</p>
<h2 id="事务配置"><a href="#事务配置" class="headerlink" title="事务配置"></a>事务配置</h2><table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>readOnly</td>
<td>设置事务是否只读</td>
<td>readOnly&#x3D;true 只读</td>
</tr>
<tr>
<td>timeout</td>
<td>设置事务超时时间</td>
<td>timeout&#x3D;-1 永不超时</td>
</tr>
<tr>
<td>rollbackFor</td>
<td>设置事务回滚异常(Class : Class)</td>
<td>rollbackFor &#x3D; (Exception.class)</td>
</tr>
<tr>
<td>rollbackForClassName</td>
<td>设置事务回滚异常(className : String)</td>
<td>rollbackForName&#x3D;”Exception.class”</td>
</tr>
<tr>
<td>noRollbackFor</td>
<td>设置事务不回滚异常(Class : Class)</td>
<td>同上</td>
</tr>
<tr>
<td>noRollbackForClassName</td>
<td>设置事务不回滚异常(className : String)</td>
<td>同上</td>
</tr>
<tr>
<td>propagation</td>
<td>设置事务传播行为</td>
<td></td>
</tr>
</tbody></table>
<h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a><strong>事务传播行为</strong></h3><table>
<thead>
<tr>
<th>传播属性</th>
<th>作用</th>
<th>人话</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED</td>
<td>如果管理员有事务就加入,没有就新建</td>
<td>拥有此属性的方法,被调用时,调用者有事务此方法就加入到调用者的事务中</td>
</tr>
<tr>
<td>REQUIRES_NEW</td>
<td>不管管理员有没有事务,都创建一个新事务</td>
<td>拥有此属性的方法,被调用时,调用者不管有没有事务此方法都不加入,自己创建一个新的</td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>如果管理员有事务就加入,没有无操作</td>
<td>拥有此属性的方法,,被调用时,调用者有事务就加入,没有就照常运行</td>
</tr>
<tr>
<td>NOT_SUPPORTED</td>
<td>不管, 管理员有没有事务, 都不做出操作</td>
<td>拥有此属性的方法,,被调用时,不管调用者有没有事务,此方法都加入</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>如果管理员有事务就加入,没有就报错</td>
<td>拥有此属性的方法,要求此方法一定<strong>带事务运行</strong></td>
</tr>
<tr>
<td>NERVER</td>
<td>如果管理员有事务就报错,没有就无操作</td>
<td>拥有此属性的方法,要求此方法一定<strong>不带事务运行</strong></td>
</tr>
<tr>
<td>NESTED</td>
<td>创建savePoint, 一旦事务回滚, 事务将回滚到savePoint处,由客户响应提交&#x2F;回滚</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>note</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>spring</tag>
        <tag>transactional</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-Spring异常处理</title>
    <url>/spring/spring-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h2><p>出现异常现象的常见位置与诱因如下:</p>
<p>框架内部抛出的异常: 使用不合规导致</p>
<p>数据层抛出的异常: 因外部服务器故障导致(如: 服务器访问超时)</p>
<p>业务层抛出的异常: 因业务逻辑编写错误导致(如: 遍历业务编写不当, 导致索引异常)</p>
<p>表现层抛出的异常: 因数据收集, 检验等规则导致(如: 不匹配的数据类型)</p>
<p>工具类抛出的异常: 因工具类编写不严谨(如: 必要的释放的链接长期未释放等)</p>
<blockquote>
<p><strong>所有异常均抛到表现层进行处理</strong></p>
</blockquote>
<h3 id="定义一个异常处理器"><a href="#定义一个异常处理器" class="headerlink" title="定义一个异常处理器"></a>定义一个异常处理器</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//与表现层的注解一致, 我使用的时rest风格的所以使用下面那个 @RestControllerAdvice</span></span><br><span class="line"><span class="comment">//@ControllerAdvice</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserExceptionAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 括号里是要处理的异常类型</span></span><br><span class="line"><span class="comment">     * 当出现异常时, 会调用下面这个方法进行处理</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Object&gt; <span class="title function_">doException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;错误, 出现异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="项目异常处理方案"><a href="#项目异常处理方案" class="headerlink" title="项目异常处理方案"></a>项目异常处理方案</h2><h3 id="业务异常-BusinessException"><a href="#业务异常-BusinessException" class="headerlink" title="业务异常(BusinessException)"></a>业务异常(BusinessException)</h3><p>规范的用户行为产生的异常</p>
<p>不规范的用户行为操作产生的异常</p>
<p><strong>解决方案: 发送对应消息给用户, 提醒规范操作</strong></p>
<h3 id="系统异常-SystemException"><a href="#系统异常-SystemException" class="headerlink" title="系统异常(SystemException)"></a>系统异常(SystemException)</h3><p>项目运行过程中可预计但不可避免的异常</p>
<p><strong>解决方案: 发送固定消息给用户.安抚用户, 发送特定消息给运维人员,提醒维护, 记录日志</strong></p>
<h3 id="其他异常-Exception"><a href="#其他异常-Exception" class="headerlink" title="其他异常(Exception)"></a>其他异常(Exception)</h3><p>开发者未预期到的异常</p>
<p><strong>解决方案: 发送固定消息给用户.安抚用户, 发送特定消息给运维人员,提醒维护, 记录日志</strong></p>
<h3 id="项目中的使用"><a href="#项目中的使用" class="headerlink" title="项目中的使用"></a>项目中的使用</h3><p><strong>自定义异常</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个自定义异常</span></span><br><span class="line"><span class="comment"> * code 是状态码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(<span class="type">int</span> code, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(<span class="type">int</span> code, String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(<span class="type">int</span> code, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(<span class="type">int</span> code, String message, Throwable cause, <span class="type">boolean</span> enableSuppression, <span class="type">boolean</span> writableStackTrace)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause, enableSuppression, writableStackTrace);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>在可能会出异常的位置利用try catch把代码块包围起来然后抛出自定义异常</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">OnAccountGet</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="comment">//模拟系统错误</span></span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="number">233</span>,<span class="string">&quot;错误, 系统出现异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟系统错误</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>  <span class="number">1</span>/ <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="number">255</span>,<span class="string">&quot;错误, 系统禁止此操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userService.selectUserByID(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在异常处理器对异常进行处理</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserExceptionAdvice</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可预期的业务异常处理</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Object&gt; <span class="title function_">doBusinessException</span><span class="params">(BusinessException e)</span> &#123;</span><br><span class="line">        <span class="comment">//日志记录</span></span><br><span class="line">        <span class="comment">//提醒运营人员</span></span><br><span class="line">        <span class="comment">//提醒开发者</span></span><br><span class="line">        <span class="keyword">return</span> Result.error(e.getCode(),<span class="literal">null</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其他的不可预期的异常处理</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Object&gt; <span class="title function_">doException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="comment">//日志记录</span></span><br><span class="line">        <span class="comment">//提醒运营人员</span></span><br><span class="line">        <span class="comment">//提醒开发者</span></span><br><span class="line">        <span class="keyword">return</span> Result.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>以上两个异常将会各返回两个JSON数据</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">233</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;错误, 系统出现异常&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">255</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;错误, 系统禁止此操作&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>note</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-Spring拦截器</title>
    <url>/spring/spring-%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><p>定义一个拦截器Bean,实现<strong>HandlerInterceptor</strong>接口</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拦截之前触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle&quot;</span>);</span><br><span class="line">        <span class="comment">//返回false表示不放行 中止原始操作, 也会影响拦截器链的运行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拦截之后触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle&quot;</span>);</span><br><span class="line">        HandlerInterceptor.<span class="built_in">super</span>.postHandle(request, response, handler, modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拦截完成后触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion&quot;</span>);</span><br><span class="line">        HandlerInterceptor.<span class="built_in">super</span>.afterCompletion(request, response, handler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>定义配置类, 继承<strong>WebMvcConfigurationSupport</strong>实现<strong>addInterceptors()<strong>方法 或者 在SpringMvcConfig里实现</strong>WebMvcConfigurer</strong>接口</p>
<p>继承WebMvcConfigurationSupport的方式</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMVCSupport</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserInterceptor userInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态资源过滤</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//当访问/pages/xxx时,走/pages目录里的内容</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/pages/**&quot;</span>).addResourceLocations(<span class="string">&quot;/pages/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//访问 /users 时拦截</span></span><br><span class="line">        registry.addInterceptor(userInterceptor1).addPathPatterns(<span class="string">&quot;/users&quot;</span>,<span class="string">&quot;/users/*&quot;</span>);</span><br><span class="line">        <span class="comment">//如果有多个拦截器,只要这边再次添加即可</span></span><br><span class="line">        registry.addInterceptor(userInterceptor2).addPathPatterns(<span class="string">&quot;/users&quot;</span>,<span class="string">&quot;/users/*&quot;</span>);</span><br><span class="line">        registry.addInterceptor(userInterceptor3).addPathPatterns(<span class="string">&quot;/users&quot;</span>,<span class="string">&quot;/users/*&quot;</span>);</span><br><span class="line">        registry.addInterceptor(userInterceptor4).addPathPatterns(<span class="string">&quot;/users&quot;</span>,<span class="string">&quot;/users/*&quot;</span>);</span><br><span class="line">        <span class="comment">//上述拦截器执行顺序 1 -&gt; 2 -&gt; 3 -&gt; 4  与你的代码书写顺序挂钩, 如果上面代码里 userInterceptor4写在userInterceptor3前面那执行顺序就变成了  1 -&gt; 2 -&gt; 4 -&gt; 3 </span></span><br><span class="line">        <span class="comment">//上方多个拦截器的执行顺序根据你上面书写的顺序有关. 且拦截器里的三个方法遵循先进后出,后进先出的规则, 与Servlet的过滤器一致</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实现<strong>WebMvcConfigurer</strong>接口的方式(此方法侵入式较强, 与Spring绑定)</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.eoezora.controller&quot;, &quot;com.eoezora.exception&quot;, &quot;com.eoezora.interceptor&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMVCConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserInterceptor userInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(userInterceptor).addPathPatterns(<span class="string">&quot;/users&quot;</span>, <span class="string">&quot;/users/*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/pages/**&quot;</span>).addResourceLocations(<span class="string">&quot;/pages/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>两者方式都一样, 只是写的地方不同而已</p>
<h2 id="拦截器参数"><a href="#拦截器参数" class="headerlink" title="拦截器参数"></a>拦截器参数</h2><blockquote>
<p>  <strong>处理器: @Controller里的方法</strong></p>
</blockquote>
<p><strong>boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</strong></p>
<ul>
<li>返回值: 当返回值为false时, 被拦截的处理器将不再执行</li>
</ul>
<p><strong>postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</strong></p>
<ul>
<li>ModelAndView modelAndView: 如果处理器执行完成后有返回结果, 可以根据modelAndView读取对应数据与页面信息,并进行调整</li>
</ul>
<p><strong>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</strong></p>
<ul>
<li>Exception ex:  如果处理器遇到异常,可以针对异常进行处理</li>
</ul>
<p><strong>这个三个方法共有的参数</strong></p>
<ul>
<li>HttpServletRequest request: 请求对象, 可以根据这个获取该次请求的<strong>请求数据</strong></li>
<li>HttpServletResponse response: 响应对象，可以根据这个获取该次请求的<strong>响应数据</strong></li>
<li>Object handler: 被调用的处理器对象,本质是一个方法, 对反射技术中的Method进行封装</li>
</ul>
]]></content>
      <categories>
        <category>note</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务笔记</title>
    <url>/springCloud/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<blockquote>
<p>微服务是一种经过良好架构设计的分布式架构方案</p>
</blockquote>
<p><strong>微服务架构特征</strong></p>
<ul>
<li>单一职责：微服务拆分粒度更小，每一个服务对应唯一的业务能力，做到单一职责，避免重复开发</li>
<li>面向服务：微服务对外暴露业务接口</li>
<li>自治：团队独立，技术独立，数据独立，部署独立</li>
<li>隔离性强：服务调用做好隔离，容错，降级，避免出现级联问题</li>
</ul>
<h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><h3 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h3><p>微服务把业务模块拆分出来，单个模块只做自己业务相关的事，例如订单模块只负责订单的创建，查询等。用户模块负责记录用户信息。每个模块都有自己对应的数据库，在编码中我们不应该去做重复业务，如：用户模块中有增删改查用户的方法。而订单模块查询订单需要一起返回用户信息，这时。我们不应该在订单模块中去查询用户的信息，而是发送请求调用用户模块暴露的接口来获取用户信息。服务模块之间互相调用的方法，有以下几种。</p>
<h4 id="提供者与消费者"><a href="#提供者与消费者" class="headerlink" title="提供者与消费者"></a>提供者与消费者</h4><p>服务提供者：一次业务中，被其他微服务调用的服务（提供接口）<br>服务消费者：一次业务中，调用其他微服务的服务（调用接口）<br>一个服务既可以是提供者，也可以是消费者。如服务A -&gt; B -&gt; C | A调用B。A是B的消费者，B是A的提供者。B调用C，B是C的消费者，C是B的提供者。提供者与消费者角色是相对的。</p>
<h4 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h4><p>当我们需要远程调用一个 HTTP 接口时，我们经常会用到 RestTemplate 这个类。这个类是 Spring 框架提供的一个工具类</p>
<h5 id="RestTemplate简单使用"><a href="#RestTemplate简单使用" class="headerlink" title="RestTemplate简单使用"></a>RestTemplate简单使用</h5><p>RestTemplate提供高度封装的接口，让我们可以非常方便地进行API调用。例如：使用 <code>GET</code> 发起请求的方法 <code>getForObject</code>， 使用 <code>POST</code> 方法发起请求的 <code>postForObject</code> 方法。这些方法并不用记忆，因为方法名基本与HTTP 方法一致。</p>
<p>创建RestTemplate，注册为Bean，使用时注入RestTemplate即可</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最简单的使用，如果需要统一超时时间，设置代理等，可以配置个ClientHttpRequestFactory，并传给RestTemplate当参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Bean</span>  </span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();  </span><br><span class="line">    <span class="keyword">return</span> restTemplate;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用其他服务的接口</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8080/user/&quot;</span> + order.getUserId();  </span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class);</span><br><span class="line"><span class="comment">//getForObject 可以将返回的JSON字符串转成实体</span></span><br></pre></td></tr></table></figure></div>


<h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><h4 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/16/mZKGTdAJV5pWv2P.png"
                      alt="image-20210713220104956.png"
                ></p>
<ul>
<li>角色<ul>
<li>EurakaServer：服务端，即注册中心，负责服务管理，健康管理，</li>
<li>EurakaClient：客户端，即每一个微服务模块，微服务启动时会将自己信息注册到EurekaServer</li>
</ul>
</li>
<li>服务启动时向Eureka注册自己的服务信息，Eureka保存这些信息</li>
<li>消费者根据服务名称向Eureka拉取提供者信息</li>
<li>如果有多个服务，会利用负载均衡算法从服务列表中挑选</li>
<li>每个服务每30秒会向Euraka发送心跳信息，报告健康状态。Euraka会根据健康信息判断，剔除宕机服务</li>
</ul>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><h6 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h6><p>新建一个 <code>eureka-service</code> 模块项目并添加依赖，下面这个依赖添加到 <code>eureka-service</code> 模块的pom里</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>在 <code>eureka-service</code> 的启动类添加注解 <code>@EnableEurekaServer</code><br>然后配置文件 <code>application.yml</code></p>
<div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span>  </span><br><span class="line">  <span class="attr">port:</span> <span class="number">8100</span>  <span class="comment"># 该服务端口</span></span><br><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">application:</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span> <span class="comment"># 服务名称</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span>  </span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment"># 实例名，没写的话根据操作系统猜出</span></span><br><span class="line">  <span class="attr">client:</span>  </span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># eureka服务地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:8100/eureka</span>  <span class="comment"># 单机版注册中心，若有多个用逗号 , 隔开</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span>  </span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></div>
<p>启动项目，一个简单的Eureka服务注册中心就启动了</p>
<h6 id="搭建服务提供者（业务模块注册到Eureka）"><a href="#搭建服务提供者（业务模块注册到Eureka）" class="headerlink" title="搭建服务提供者（业务模块注册到Eureka）"></a>搭建服务提供者（业务模块注册到Eureka）</h6><p>在业务模块里添加依赖</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--eureka客户端--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>在配置文件 <code>application.yml</code> 添加如下配置</p>
<div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span>  </span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span> <span class="comment"># 你的服务模块端口</span></span><br><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">application:</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">you-server</span> <span class="comment"># 你的服务模块名称，服务发现将根据这个名字来，所以非常重要</span></span><br><span class="line"><span class="attr">eureka:</span>  </span><br><span class="line">  <span class="attr">client:</span>  </span><br><span class="line">    <span class="attr">service-url:</span>  </span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:8100/eureka</span> <span class="comment"># 你的eureka服务地址</span></span><br></pre></td></tr></table></figure></div>

<h5 id="服务拉取"><a href="#服务拉取" class="headerlink" title="服务拉取"></a>服务拉取</h5><p>服务拉取是根据服务名称获取服务列表，然后对服务列表做复杂均衡</p>
<h6 id="RestTemplate例"><a href="#RestTemplate例" class="headerlink" title="RestTemplate例"></a>RestTemplate例</h6><p>给RestTemplate添加负载均衡注解 <code>@LoadBalanced</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  </span><br><span class="line"><span class="meta">@LoadBalanced</span>  </span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在调用服务接口的地方把IP地址换成对应的服务名</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//yourService是你服务模块配置文件的spring.application.name值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://yourService/user/&quot;</span> + order.getUserId();  </span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class);</span><br></pre></td></tr></table></figure></div>
<p>这样就简单实现了服务拉取</p>
<blockquote>
<p>如果你出现了异常: <mark style="background: #FF5582A6;">java.lang.IllegalStateException: No instances available for userService</mark> 有两个原因，第一个原因是Eureka需要三次心跳才会把服务加入服务列表，大概10秒一次，所以要等待30秒，第二个原因是因为负载均衡Ribbon是懒加载，只有第一次调用才会创建，把所有服务都激活访问一次就行，或者可以把Ribbon设置成饥饿加载</p>
</blockquote>
<h5 id="负载均衡-Ribbon"><a href="#负载均衡-Ribbon" class="headerlink" title="负载均衡(Ribbon)"></a>负载均衡(Ribbon)</h5><h6 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/16/Xj3eiNUrftMmoIu.png"
                      alt="image-20210713224517686.png"
                ></p>
<h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>当请求进入Ribbon后，会被一个拦截器 <code>LoadBalancerInterceptor</code> 拦截，获取请求中的 service name 服务名称，交给 <code>RibbonLoadBanlancerClient</code>，<code>RibbonLoadBalancerClient</code> 会把服务名称交给 <code>DynamicServerListLoadBalancer</code>  去 <code>Eureka</code> 获取该服务的IP地址列表，然后去 <code>IRule</code> 根据规则做负载均衡选取一个地址出来返回给 <code>RibbonLoadBalancer</code> 替换服务名称获取真实请求地址。<br>流程图如下<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/16/KOl2HN69qPfUnAs.png"
                      alt="image-20210713224724673.png"
                ></p>
<h6 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h6><p>Ribbon的负载均衡规则是一个叫IRule的接口定义的，每一个子接口都是一种规则<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/16/uZMykBiCgjT5KfX.png"
                      alt="image.png"
                ></p>
<p><strong>常见常用规则</strong></p>
<ul>
<li>RetryRule：重试机制的选择逻辑</li>
<li>RandomRule：随机选择一个可用</li>
<li>RoundRobinRule：简单轮询服务器列表，<mark style="background: #FF5582A6;">是默认的负载均衡规则</mark></li>
<li>AvailabilityFilteringRule：对以下两种服务器进行忽略<ol>
<li>在默认情况下，如果这台服务器3次连接失败，那么这台服务器就会被设置为 “短路” 状态，短路状态持续30秒，如果再次连接失败，短路持续时间会几何级地增加</li>
<li>并发数过高的服务器，如果一个服务器并发连接数过高</li>
</ol>
</li>
<li>WeightedResponseTimeRule：为每一个服务器赋予一个权重值。服务响应时间越长，权重越小。会随机选择服务器，权重值会影响服务器的选择</li>
<li>ZoneAvoidanceRule：以区域可用的服务器为基础进行服务器选择。使用Zone对服务器分类</li>
<li>BestAvailableRule：忽略哪些短路服务器，选择并发次数较低的服务器</li>
</ul>
<p>规则配置方式</p>
<ol>
<li><p>通过代码配置<br>添加一个Bean返回你想设置的 IRule 实现类，此方案是全局规则，不管调用哪个服务的接口都会应用此规则</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  </span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>配置文件方式<br>在 <code>application,.yml</code> 中添加如下配置，此方案是针对某个服务</p>
<div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">youservice:</span> <span class="comment"># 目标服务名称</span></span><br><span class="line">	<span class="attr">ribbon:</span></span><br><span class="line">		<span class="attr">NFLoadBalancerRuleClassNamme:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment"># 此服务要应用的规则</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h6 id="懒加载与饥饿加载"><a href="#懒加载与饥饿加载" class="headerlink" title="懒加载与饥饿加载"></a>懒加载与饥饿加载</h6><p>Ribbon默认启用懒加载，即第一次访问时才会去创建 <code>LoadBalanceClient</code>，请求时间会较长<br>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载</p>
<div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">	<span class="attr">eager-load:</span></span><br><span class="line">		<span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">		<span class="attr">clients:</span> <span class="string">youservice</span> <span class="comment"># 针对这个服务开启饥饿加载</span></span><br><span class="line">	<span class="comment">#	clients:  若需设置多个</span></span><br><span class="line">	<span class="comment">#		- service1</span></span><br><span class="line">	<span class="comment">#		- service2</span></span><br><span class="line">	<span class="comment">#		- ....</span></span><br></pre></td></tr></table></figure></div>

<h6 id="Ribbon总结"><a href="#Ribbon总结" class="headerlink" title="Ribbon总结"></a>Ribbon总结</h6><ul>
<li>负载均衡规则<ul>
<li>规则接口是 <code>IRule</code></li>
<li>默认实现是 <code>ZoneAvoidanceRule</code> 根据zone选择服务列表，然后轮询</li>
</ul>
</li>
<li>负载均衡配置<ul>
<li>代码方式：通过添加Bean的方式，实现全局规则</li>
<li>配置方式：在配置文件添加相关配置，可以针对某个服务的规则</li>
</ul>
</li>
<li>饥饿加载：<code>LoadBalanceClient</code> 第一次访问才会创建，饥饿加载能够在启动时就创建</li>
</ul>
<h4 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h4><h5 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h5><p>首先在父工程引入依赖</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos依赖--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;alibaba.cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>然后给每个服务模块（服务提供者）添加nacos客户端依赖</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos客户端依赖--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>接着在每个服务模块配置nacos注册中心地址即可</p>
<div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">    <span class="attr">cloud:</span>  </span><br><span class="line">        <span class="attr">nacos:</span>  </span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos中心地址</span></span><br></pre></td></tr></table></figure></div>
<p>因为 <code>Eureka</code> 跟 <code>Nacos</code> 都实现了接口 <code>DiscoveryClient</code> 和 <code>ServiceRegistry</code> 所以代码使用是一样的都是，<code>restTemplate.xxxx</code></p>
<h5 id="Nacos服务分级模型"><a href="#Nacos服务分级模型" class="headerlink" title="Nacos服务分级模型"></a>Nacos服务分级模型</h5><p>Nacos服务分级为：服务 -&gt; 集群 -&gt; 实例。</p>
<ul>
<li>一级是服务，例如 userService等微服务模块</li>
<li>二级是地区集群，为了保证服务高可用，我们会做集群，但不会把所有集群都放在同个地区，一是防止不可抗拒因素导致服务器宕机。二是让用户访问就近集群提高访问速度</li>
<li>三级是实例，每个部署了服务(例如部署了userService)的服务器都可以叫实例</li>
</ul>
<h6 id="设置集群属性"><a href="#设置集群属性" class="headerlink" title="设置集群属性"></a>设置集群属性</h6><p>修改服务模块的配置文件</p>
<div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">    <span class="attr">cloud:</span>  </span><br><span class="line">        <span class="attr">nacos:</span>  </span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos中心地址</span></span><br><span class="line">            <span class="attr">discovery:</span>  </span><br><span class="line">	            <span class="attr">cluster-name:</span> <span class="string">Shanghai</span>  <span class="comment"># 集群名称，不能中文</span></span><br></pre></td></tr></table></figure></div>

<p>设置完成后打开浏览器访问Nacos我们可以看到，两台userService被划分到了不同集群组<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s2.loli.net/2023/03/17/hCFVyjRS714HQeP.png"
                      alt="屏幕截图 2023-03-17 104143.png"
                ></p>
]]></content>
      <categories>
        <category>note</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>spring</tag>
        <tag>spring-cloud</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWEB笔记-Spring整合mybatis</title>
    <url>/spring/spring-%E6%95%B4%E5%90%88mybatis/</url>
    <content><![CDATA[<h2 id="Maven坐标"><a href="#Maven坐标" class="headerlink" title="Maven坐标"></a>Maven坐标</h2><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--德鲁伊连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.13-SNSAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--数据库连接组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--spring操作数据库需要的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--spring整合mybatis需要的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="JDBC配置类"><a href="#JDBC配置类" class="headerlink" title="JDBC配置类"></a>JDBC配置类</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">druidDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        druidDataSource.setDriverClassName(driverClass);</span><br><span class="line">        druidDataSource.setUrl(url);</span><br><span class="line">        druidDataSource.setUsername(username);</span><br><span class="line">        druidDataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Mybatis配置类"><a href="#Mybatis配置类" class="headerlink" title="Mybatis配置类"></a>Mybatis配置类</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="comment">//创建SqlSessionFactoryBean</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="comment">//设置mybatis别名扫描</span></span><br><span class="line">        sfb.setTypeAliasesPackage(<span class="string">&quot;com.eoezora.spring_mybatis.domain&quot;</span>);</span><br><span class="line">        <span class="comment">//设置数据源</span></span><br><span class="line">        sfb.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> sfb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建映射文件配置MapperScannerConfigurer</span></span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        <span class="comment">//设置映射文件所在的包路径</span></span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.eoezora.spring_mybatis.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Spring配置类"><a href="#Spring配置类" class="headerlink" title="Spring配置类"></a>Spring配置类</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.eoezora.spring_mybatis&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;MybatisConfig.class, JDBCConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>至此Spring和Mybatis整和完毕</p>
]]></content>
      <categories>
        <category>note</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>note</tag>
        <tag>spring</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
</search>
